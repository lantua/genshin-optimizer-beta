{"version":3,"sources":["Formula/index.ts","Components/Card/CardLight.tsx","Formula/utils.ts","ReactHooks/usePromise.tsx","Components/Card/CardDark.tsx","Components/Image/ImgIcon.tsx","Components/SqBadge.tsx","Components/DropdownMenu/DropdownButton.tsx","Data/Characters/CharacterSheet.tsx","Assets/icon_bow.png","Assets/Assets.ts","Assets/icon_catalyst.png","Assets/icon_claymore.png","Assets/icon_polearm.png","Assets/icon_sword.png","Assets/Item_Fragile_Resin.png","Assets/Item_Condensed_Resin.png","Assets/Item_Wanderer's_Advice.png","Assets/Item_Hero's_Wit.png","Assets/Item_Adventurer's_Experience.png","Components/StarDisplay.tsx","Formula/api.tsx","Components/StatIcon.tsx","Data/Weapons/WeaponSheet.tsx","Components/CloseButton.tsx","Formula/uiData.tsx","Components/ModalWrapper.tsx","Components/SolidToggleButtonGroup.tsx","ReactHooks/useForceUpdate.tsx","Components/ConditionalWrapper.tsx","Formula/reaction.ts","Formula/optimization.ts","Formula/internal.ts"],"names":["pivot","allElements","allElementsWithPhy","allTalents","allMoves","allArtModStats","allArtNonModStats","allTransformative","allAmplifying","allModStats","map","x","allNonModStats","allEleEnemyResKeys","talent","objectKeyMap","_","read","allModStatNodes","key","undefined","allNonModStatNodes","ele","info","variant","reaction","withDefaultInfo","value","deepClone","crawlObject","operation","accu","input","setReadNodeKeys","activeCharKey","stringRead","charKey","charEle","infusion","weaponType","lvl","prefix","constellation","asc","special","base","customBonus","bonus","premod","total","objectKeyValueMap","cappedCritRate","art","asConst","allSlotKeys","id","set","artSet","allArtifactSets","weapon","type","refinement","refineIndex","main","sub","sub2","team","enemy","def","level","defRed","defIgn","hit","move","hitMode","dmgBonus","dmgInc","dmg","stat","auto","skill","burst","atk","critRate_","baseAmpBonus","sum","unit","prod","frac","eleMas","effectiveReaction","lookup","pyro","vaporize","constant","melt","hydro","equalStr","cryo","common","operands","push","percent","filter","stamina","max","min","naught","all_dmg_","all_dmgInc","NaN","critHit","critDMG_","avgHit","enemyDefRed_","res","infoMut","target","uiInput","allRegions","CardLight","styled","Card","backgroundColor","theme","palette","contentLight","Number","MAX_VALUE","Infinity","node","index","table","defaultV","intoV","values","intoOps","c","equal","v1","v2","pass","emptyOn","unequal","greaterEq","greaterEqStr","lessThan","nodeList","Error","path","Object","keys","data","resetData","reset","customRead","customStringRead","stringPrio","subscript","list","matchFull","match","unmatch","usePromise","promise","dependencies","useState","setRes","useEffect","pending","then","console","error","CardDark","contentDark","ImgIcon","name","slot","size","display","width","height","verticalAlign","SqBadge","color","padding","fontSize","fontWeight","lineHeight","textAlign","whiteSpace","borderRadius","contrastText","DropdownButton","title","children","props","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","fallback","endIcon","onClick","onClose","MenuListProps","characterSheets","imp","default","CharacterSheet","charSheet","sheet","isMelee","weaponTypeKey","getTalent","eleKey","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","sx","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","getLevelString","ascension","ascensionMaxLevel","talentTemplate","tr","img","fields","sections","text","talentStrMap","passive","passive1","passive2","passive3","sprint","constellation1","constellation2","constellation3","constellation4","constellation5","constellation6","conditionalHeader","icon","m","action","normalSrc","weaponKey","Assets","weaponTypes","bow","catalyst","claymore","polearm","sword","resin","fragile","condensed","exp_books","advice","wit","experience","StarIcon","faStar","Stars","stars","colored","component","Array","i","inferInfoMut","source","slice","reference","objPathValue","dataObjForArtifact","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatValue","mainStatKey","Math","stats","substats","forEach","accurateValue","fromEntries","endsWith","slotKey","setKey","dataObjForCharacter","char","result","enemyOverride","enemyLevel","entries","bonusStats","enemyDefIgn_","basic","reactions","layeredAssignment","conditional","dataObjForWeapon","teamBuff","uiDataForTeam","teamData","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","custom","newNode","sourceKey","sourceBuff","buff","calc","readNode","targetKey","assign","origin","UIData","length","internal","Set","flatMap","computeUIData","HPIcon","className","faHpPrimary","faHpSecondary","style","CdRedIcon","faCdReductionPrimary","faCdReductionSecondary","EnerRechIcon","faEnergyRechargePrimary","faEnergyRechargeSecondary","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","faHydro","faPyro","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","StatIcon","characterHP","finalHP","hp_","hp","baseATK","faAtk","characterATK","finalATK","atk_","characterDEF","faDef","finalDEF","def_","faElementalMastery","faCritRate","faDiceD20","enerRech_","heal_","faHealingBonus","cdRed_","shield_","faShieldStrength","faMaxStamina","weaponSheets","WeaponSheet","weaponSheet","weaponData","strKey","ns","key18","passiveDescription","iconAwaken","document","w","getWeaponsOfType","CloseButton","large","t","useTranslation","startIcon","p","minWidth","shouldWrap","valueString","fixed","isFinite","isInteger","abs","toFixed","parent","Map","nodes","processed","getAll","calculated","trace","isEmpty","formulas","old","formula","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","first","find","illformed","assertUnreachable","mayNeedWrapping","valueDisplay","prefixDisplay","getPrefixStr","sourceDisplay","getNoUnit","createDisplay","readFirst","_accumulate","readAll","selected","v1Node","v2Node","matchNode","unmatchNode","matching","makeEmpty","valueNode","thresholdNode","fail","threshold","child","operand","unique","delete","next","mergeVariants","identity","allOperations","fStr","separator","every","strings","predisplay","string","item","array","itemFormula","createFormulaComponent","add","mergeFormulaComponents","components","emptyValue","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","dark","useForceUpdate","stateDirty","update","ConditionalWrapper","condition","wrapper","falseWrapper","crystalizeMulti1","crystalizeLevelMultipliers","crystalizeElemas","crystalizeHit","transMulti1","transformativeReactionLevelMultipliers","transMulti2","trans","transformativeReactions","multi","variants","swirl","swirl_dmg_","electroSwirl","pyroSwirl","cryoSwirl","hydroSwirl","shattered","overloaded","electrocharged","superconduct","allCommutativeMonoidOperations","reduce","a","b","mul","sum_frac","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","mapFormulas","f","has","flattened","dep","elementCounts","wrap","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","nextContextMap","fold","context","numericOperands","formulaOperands","folded","numericValue","op","nextContext","forEachNodes","topDown","bottomUp","visiting","visited","traverse","topDownMap","bottomUpMap","topDownMapped","bottomUpMapped","check","arrayEqual"],"mappings":"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","file":"static/js/4.bf404c0f.chunk.js","sourcesContent":["import { allEleEnemyResKeys } from \"../KeyMap\"\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\nimport { constant, equalStr, frac, infoMut, lookup, max, min, naught, percent, prod, read, res, setReadNodeKeys, stringRead, sum, unit } from \"./utils\"\n\nconst asConst = true as const, pivot = true as const\n\nconst allElements = allElementsWithPhy\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\", \"elemental\"] as const\nconst allArtModStats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\"] as const\nconst allArtNonModStats = [\"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"heal_\"] as const\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\nconst allMisc = [\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\"\n] as const\n\nconst allModStats = [\n  ...allArtModStats,\n  ...([\"all\", \"burning\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\n]\nconst allNonModStats = [\n  ...allArtNonModStats,\n  ...([\"all\", ...allMoves] as const).map(x => `${x}_dmgInc` as const),\n  ...([...allElements] as const).map(x => `${x}_critDMG_` as const),\n  ...allElements.map(x => `${x}_res_` as const),\n  ...allMoves.map(x => `${x}_critRate_` as const),\n  ...allEleEnemyResKeys,\n  \"enemyDefRed_\" as const,\n  ...allMisc,\n]\n\nconst talent = objectKeyMap(allTalents, _ => read())\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\n\nfor (const ele of allElements) {\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_dmg_`].info!.variant = ele\n}\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\n  allModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\n}\n\nfunction withDefaultInfo<T>(info: Info, value: T): T {\n  value = deepClone(value)\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\n  return value\n}\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\n  })\n}\n\n/** All read nodes */\nconst input = setReadNodeKeys(deepClone({\n  activeCharKey: stringRead(),\n  charKey: stringRead(), charEle: stringRead(), infusion: stringRead(), weaponType: stringRead(),\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\n\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\n    ...allModStatNodes, ...allNonModStatNodes,\n  }),\n  bonus: { ...talent },\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\n    ...allModStatNodes, ...allNonModStatNodes,\n    /** Total Crit Rate capped to [0%, 100%] */\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\n  }),\n\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\n    ...objectKeyMap(allArtModStats, key => allModStatNodes[key]),\n    ...objectKeyMap(allArtNonModStats, key => allNonModStatNodes[key]),\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\n  }),\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\n\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\n    key: stringRead(), type: stringRead(),\n\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\n    main: read(), sub: read(), sub2: read(),\n  }),\n\n  team: { infusion: stringRead() },\n\n  enemy: {\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\n\n    level: read(undefined, { key: \"enemyLevel\" }),\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\n    defRed: read(undefined),\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\n  },\n\n  hit: {\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\n    base: read(\"add\", { key: \"base\" }),\n\n    dmgBonus: read(undefined, { key: \"dmg_\", pivot }),\n    dmgInc: read(undefined, { key: \"dmgInc\", pivot }),\n    dmg: read(),\n  },\n}))\n\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\n\n// Adjust `info` for printing\nmarkAccu('add', {\n  bonus, customBonus, premod, art,\n  total: objectKeyMap(allModStats, stat => total[stat]),\n})\nbonus.auto.info = { key: \"autoBoost\" }\nbonus.skill.info = { key: \"skillBoost\" }\nbonus.burst.info = { key: \"burstBoost\" }\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\ndelete total.critRate_.info!.pivot\ntotal.critRate_.info!.prefix = \"uncapped\"\n\n// Nodes that are not used anywhere else but `common` below\n\n/** Base Amplifying Bonus */\nconst baseAmpBonus = sum(unit, prod(25 / 9, frac(total.eleMas, 1400)))\n/** Effective reaction, taking into account the hit's element */\nexport const effectiveReaction = lookup(hit.ele, {\n  pyro: lookup(hit.reaction, { vaporize: constant(\"vaporize\"), melt: constant(\"melt\") }, undefined),\n  hydro: equalStr(hit.reaction, \"vaporize\", \"vaporize\"),\n  cryo: equalStr(hit.reaction, \"melt\", \"melt\"),\n}, undefined)\n\nconst common: Data = {\n  premod: {\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\n    ...objectKeyMap([...allModStats, ...allArtNonModStats] as const, key => {\n      const operands: NumNode[] = []\n      switch (key) {\n        case \"atk\": case \"def\": case \"hp\":\n          operands.push(prod(base[key], sum(unit, premod[`${key}_`])))\n          break\n        case \"critRate_\":\n          operands.push(percent(0.05, { key, prefix: \"default\" }),\n            lookup(hit.move, objectKeyMap(allMoves, move => customBonus[`${move}_critRate_`]), 0))\n          break\n        case \"critDMG_\":\n          operands.push(percent(0.5, { key, prefix: \"default\" }),\n            lookup(hit.ele, objectKeyMap(allElements, ele => customBonus[`${ele}_critDMG_`]), 0))\n          break\n        case \"enerRech_\":\n          operands.push(percent(1, { key, prefix: \"default\" }))\n          break\n      }\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\n    }),\n  },\n  total: {\n    ...objectKeyMap(allTalents, talent => premod[talent]),\n    ...objectKeyMap(allModStats, key => premod[key]),\n    ...objectKeyMap(allNonModStats, key => premod[key]),\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\n\n    cappedCritRate: max(min(total.critRate_, unit), naught),\n  },\n\n  hit: {\n    dmgBonus: sum(\n      total.all_dmg_,\n      lookup(effectiveReaction, objectKeyMap(allAmplifying, reaction => total[`${reaction}_dmg_`]), naught),\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\n    ),\n    dmgInc: sum(\n      total.all_dmgInc,\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\n    ),\n    dmg: prod(\n      sum(hit.base, hit.dmgInc),\n      sum(unit, hit.dmgBonus),\n      lookup(hit.hitMode, {\n        hit: unit,\n        critHit: sum(unit, total.critDMG_),\n        avgHit: sum(unit, prod(total.cappedCritRate, total.critDMG_)),\n      }, NaN),\n      enemy.def,\n      lookup(hit.ele,\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\n      lookup(effectiveReaction, {\n        melt: lookup(hit.ele, {\n          pyro: prod(2, baseAmpBonus),\n          cryo: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"melt_dmg_\" }),\n        vaporize: lookup(hit.ele, {\n          hydro: prod(2, baseAmpBonus),\n          pyro: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"vaporize_dmg_\" }),\n      }, 1),\n    ),\n  },\n\n  enemy: {\n    // TODO: shred cap of 90%\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(1, prod(-1, enemy.defRed)), sum(1, prod(-1, enemy.defIgn)))),\n    defRed: total.enemyDefRed_,\n    ...objectKeyValueMap(allElements, ele =>\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\n  },\n}\n\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\nconst tally = setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"])\n\n/**\n * List of `input` nodes, rearranged to conform to the needs of the\n * UI code. This is a separate list so that the evolution of the UIs\n * does not rely on the structure of `input`. So the UI code can rearrange\n * nodes as it sees fit without requiring updates to data sheets, which\n * pertains ~90% of all `input`-related code, and so are very sensitive\n * to any changes to `input`. For zero overhead, use the nodes directly\n * from `input` instead of a copy.\n */\nconst uiInput = input\n\nexport {\n  input, uiInput, common, customBonus,\n\n  target, tally,\n}\n","import { Card, styled } from \"@mui/material\";\n\nconst CardLight = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentLight.main\n}));\n\nexport default CardLight","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const unit = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\nexport function stringRead(): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/*\n * Deprecated\n */\n\n/**\n * value >= threshold ? value : emptyValue\n * @deprecated Use `greaterEq`, `lessEq`, or `greaterEqStr` instead\n */\nexport function threshold(value: Num, threshold: Num, pass: Str, fail: Str, info?: Info): StrNode\nexport function threshold(value: Num, threshold: Num, pass: Num, fail: Num, info?: Info): NumNode\nexport function threshold(value: Num, threshold: Num, pass: Num | Str, fail: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(value), intoV(threshold), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n/**\n * value >= threshold ? addition : 0\n * @deprecated Use `greaterEq` or `lessEq` instead\n */\nexport function threshold_add(value: Num, thres: Num, addition: Num, info?: Info): NumNode {\n  return threshold(value, thres, addition, 0, info)\n}\n\n/**\n * `v1` === `v2` ? `match` : 0\n * @deprecated Use `equal` instead\n */\nexport function match(v1: Str, v2: Str, match: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/**\n * `v1` === `v2` ? 0 : `unmatch`\n * @deprecated Use `unequal` instead\n */\nexport function unmatch(v1: Str, v2: Str, unmatch: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(unmatch)], info, emptyOn: \"match\" }\n}\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n","import { useEffect, useState } from \"react\";\n\nexport default function usePromise<T>(promise: Promise<T> | undefined, dependencies: any[]): T | undefined {\n  const [res, setRes] = useState<T | undefined>(undefined);\n  useEffect(() => {\n    let pending = true\n    promise?.then(res => pending && setRes(() => res), console.error) ?? setRes(undefined)\n    return () => {\n      pending = false\n      setRes(undefined)\n    }\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\n  return res\n}","import { Card, styled } from \"@mui/material\";\n\nconst CardDark = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentDark.main\n}));\n\nexport default CardDark","import { styled } from \"@mui/material\"\ninterface ImgIconProps {\n  size?: number;\n}\nconst ImgIcon = styled(\"img\", {\n  name: 'ImgIcon',\n  slot: 'Root',\n})<ImgIconProps>(({ size = 1 }) => ({\n  display: \"inline-block\",\n  width: \"auto\",\n  height: `${size * 1.2}em`,\n  verticalAlign: \"text-bottom\"\n}))\n\nexport default ImgIcon","import { styled } from \"@mui/material\";\n\nconst SqBadge = styled(\"span\", {\n  name: 'SqBadge',\n  slot: 'Root',\n})(({ theme, color = \"primary\" }) => ({\n  display: \"inline-block\",\n  padding: \".25em .4em\",\n  fontSize: \"75%\",\n  fontWeight: 700,\n  lineHeight: 1,\n  textAlign: \"center\",\n  whiteSpace: \"nowrap\",\n  verticalAlign: \"baseline\",\n  borderRadius: \".25em\",\n  backgroundColor: theme.palette[color]?.main,\n  color: theme.palette[color]?.contrastText\n}))\nexport default SqBadge","import { KeyboardArrowDown } from \"@mui/icons-material\";\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\nimport { Suspense, useCallback, useState } from \"react\";\n\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\n  title: React.ReactNode,\n  id?: string,\n  children: React.ReactNode\n}\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n  const open = Boolean(anchorEl);\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\n    [setAnchorEl],\n  )\n  const handleClose = useCallback(\n    () => setAnchorEl(null),\n    [setAnchorEl],\n  )\n\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\n    <Button\n      {...props}\n      id={id}\n      aria-controls=\"basic-menu\"\n      aria-haspopup=\"true\"\n      aria-expanded={open ? 'true' : undefined}\n      onClick={handleClick}\n      endIcon={<KeyboardArrowDown />}\n    >\n      {title}\n    </Button>\n    <Menu\n      id=\"basic-menu\"\n      anchorEl={anchorEl}\n      open={open}\n      onClose={handleClose}\n      MenuListProps={{\n        'aria-labelledby': id,\n      }}\n      onClick={handleClose}\n    >\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\n        {children}\n      </Suspense>\n    </Menu>\n  </Suspense>\n}","import ImgIcon from \"../../Components/Image/ImgIcon\";\nimport { ascensionMaxLevel } from \"../LevelData\";\nimport { Data } from \"../../Formula/type\";\nimport { TalentSheet, TalentSheetElement, TalentSheetElementKey } from \"../../Types/character_WR\";\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\nimport SqBadge from \"../../Components/SqBadge\";\nimport Assets from \"../../Assets/Assets\";\nimport IConditional from \"../../Types/IConditional_WR\";\nimport { IFieldDisplay } from \"../../Types/IFieldDisplay_WR\";\n\nconst characterSheets = import('.').then(imp => imp.default)\n\ninterface ICharacterSheetBase {\n  name: Displayable\n  cardImg: string\n  thumbImg: string\n  thumbImgSide: string\n  barImg?: string\n  bannerImg?: string\n  rarity: Rarity\n  weaponTypeKey: WeaponTypeKey\n  gender: string\n  constellationName: Displayable\n  title: Displayable\n}\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\n  elementKey: ElementKey\n  talent: TalentSheet\n}\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\n  talents: Dict<ElementKey, TalentSheet>\n}\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\n\nexport default class CharacterSheet {\n  sheet: ICharacterSheet;\n  data: Data;\n  constructor(charSheet: ICharacterSheet, data: Data) {\n    this.sheet = charSheet\n    this.data = data\n  }\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\n  static get getAll() { return characterSheets }\n  get name() { return this.sheet.name }\n  get nameWIthIcon() { return <span><ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> {this.name}</span> }\n  get cardImg() { return this.sheet.cardImg }\n  get thumbImg() { return this.sheet.thumbImg }\n  get thumbImgSide() { return this.sheet.thumbImgSide }\n  get bannerImg() { return this.sheet.bannerImg }\n  get rarity() { return this.sheet.rarity }\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\n  get constellationName() { return this.sheet.constellationName }\n\n  isMelee = () => {\n    const weaponTypeKey = this.sheet.weaponTypeKey\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\n  }\n  get isTraveler() {\n    return \"talents\" in this.sheet\n  }\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\n    if (\"talent\" in this.sheet) return this.sheet.talent\n    else return this.sheet.talents[eleKey]\n  }\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\n\n  static getLevelString = (level: number, ascension: number): string =>\n    `${level}/${ascensionMaxLevel[ascension]}`\n}\n\nexport const talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, fields?: IFieldDisplay[]): TalentSheetElement => ({\n  name: tr(`${talentKey}.name`),\n  img,\n  sections: [{\n    text: tr(`${talentKey}.description`),\n    fields\n  }],\n})\n\nconst talentStrMap: Record<TalentSheetElementKey, string> = {\n  auto: \"Auto\",\n  skill: \"Skill\",\n  burst: \"Burst\",\n  passive: \"Passive\",\n  passive1: \"Ascension 1\",\n  passive2: \"Ascension 4\",\n  passive3: \"Passive\",\n  sprint: \"Sprint\",\n  constellation1: \"C1\",\n  constellation2: \"C2\",\n  constellation3: \"C3\",\n  constellation4: \"C4\",\n  constellation5: \"C5\",\n  constellation6: \"C6\"\n}\nexport const conditionalHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IConditional[\"header\"] => {\n  return {\n    title: tr(`${talentKey}.name`),\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\n    action: <SqBadge color=\"success\">{talentStrMap[talentKey]}</SqBadge>,\n  }\n}\n\nexport const normalSrc = (weaponKey: WeaponTypeKey) => Assets.weaponTypes[weaponKey]\n","export default __webpack_public_path__ + \"static/media/icon_bow.7ceaa8e2.png\";","import bow from './icon_bow.png'\nimport catalyst from './icon_catalyst.png'\nimport claymore from './icon_claymore.png'\nimport polearm from './icon_polearm.png'\nimport sword from './icon_sword.png'\n\nimport fragile from './Item_Fragile_Resin.png'\nimport condensed from './Item_Condensed_Resin.png'\n\n//EXP BOOKS\nimport advice from './Item_Wanderer\\'s_Advice.png'\nimport wit from './Item_Hero\\'s_Wit.png'\nimport experience from './Item_Adventurer\\'s_Experience.png'\n\nconst Assets = {\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\n  resin: {\n    fragile,\n    condensed\n  },\n  exp_books: {\n    advice,\n    wit,\n    experience,\n  }\n};\nexport default Assets;","export default __webpack_public_path__ + \"static/media/icon_catalyst.db078b7b.png\";","export default __webpack_public_path__ + \"static/media/icon_claymore.63b1abb8.png\";","export default __webpack_public_path__ + \"static/media/icon_polearm.e5f4a2a1.png\";","export default __webpack_public_path__ + \"static/media/icon_sword.619c9c2d.png\";","export default __webpack_public_path__ + \"static/media/Item_Fragile_Resin.f9ec8223.png\";","export default __webpack_public_path__ + \"static/media/Item_Condensed_Resin.1cecf64a.png\";","export default __webpack_public_path__ + \"static/media/Item_Wanderer's_Advice.58c62cf7.png\";","export default __webpack_public_path__ + \"static/media/Item_Hero's_Wit.a79e36d0.png\";","export default __webpack_public_path__ + \"static/media/Item_Adventurer's_Experience.92b5d195.png\";","import { faStar } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Typography } from '@mui/material'\nimport { Rarity } from '../Types/consts'\n\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\n  </Typography>\n\nexport {\n  StarIcon,\n  Stars\n}\n","import Artifact from \"../Data/Artifacts/Artifact\";\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\nimport { ICachedCharacter } from \"../Types/character_WR\";\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\nimport { ICachedWeapon } from \"../Types/weapon\";\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { reactions } from \"./reaction\";\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\nimport { NodeDisplay, UIData, valueString } from \"./uiData\";\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\n\nconst asConst = true as const, pivot = true as const\n\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\n    if (path[0] === \"teamBuff\") path = path.slice(1)\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\n    if (reference)\n      x.info = { ...reference.info, prefix: undefined, source }\n    else if (path[0] !== \"tally\")\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\n  })\n\n  return data\n}\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\n  stats.push([art.mainStatKey, mainStatVal])\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\n  return {\n    art: {\n      ...Object.fromEntries(stats.map(([key, value]) =>\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\n      [art.slotKey]: {\n        id: constant(art.id), set: constant(art.setKey)\n      },\n    },\n    artSet: {\n      [art.setKey]: constant(1)\n    }\n  }\n}\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\n  const result: Data = {\n    lvl: constant(char.level),\n    constellation: constant(char.constellation),\n    asc: constant(char.ascension),\n\n    premod: {\n      auto: constant(char.talent.auto),\n      skill: constant(char.talent.skill),\n      burst: constant(char.talent.burst),\n    },\n    enemy: {\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\n    },\n    hit: {\n      hitMode: constant(char.hitMode)\n    },\n    customBonus: {},\n  }\n\n  for (const [key, value] of Object.entries(char.bonusStats))\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\n\n  if (char.enemyOverride.enemyDefRed_)\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_)\n  if (char.enemyOverride.enemyDefIgn_)\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_)\n  if (char.elementKey) {\n    result.charEle = constant(char.elementKey)\n    result.display = {\n      basic: { [`${char.elementKey}_dmg_`]: input.total[`${char.elementKey}_dmg_`] },\n      reaction: reactions[char.elementKey]\n    }\n    layeredAssignment(result, [\"teamBuff\", \"tally\", char.elementKey], constant(1))\n  }\n\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\n    layeredAssignment(result, keys, constant(x)))\n  return result\n}\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\n  return {\n    weapon: {\n      lvl: constant(weapon.level),\n      asc: constant(weapon.ascension),\n      refinement: constant(weapon.refinement),\n      refineIndex: constant(weapon.refinement - 1)\n    },\n  }\n}\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\n  // May the goddess of wisdom bless any and all souls courageous\n  // enough to attempt for the understanding of this abomination.\n\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\n  const result = Object.fromEntries(mergedData.map(([key]) =>\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\n\n  const customReadNodes = {}\n  function getReadNode(path: readonly string[]): ReadNode<number> {\n    const base = (path[0] === \"teamBuff\")\n      ? objPathValue(teamBuff, path.slice(1))\n      : objPathValue(input, path)\n    if (base) return base\n    const custom = objPathValue(customReadNodes, path)\n    if (custom) return custom\n    const newNode = customRead(path)\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\n    layeredAssignment(customReadNodes, path, newNode)\n    return newNode\n  }\n\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\n    mergedData.forEach(([sourceKey, source]) => {\n      const sourceBuff = source.teamBuff\n      // Create new copy of `calc` as we're mutating it later\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\n      buffs.push(buff)\n      calcs[sourceKey] = calc\n\n      // This construction creates a `Data` representing buff\n      // from `source` applying to `target`. It has 3 data:\n      // - `target` contains the reference for the final\n      //   data. It is not populated at this stage,\n      // - `calc` contains the calculation of the buffs,\n      // - `buff` contains read nodes that point to the\n      //   calculation in `calc`.\n\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\n\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\n\n          let readNode: ReadNode<number | string> | undefined, data: Data\n          if (x.path[0] === \"target\") { // Link the node to target data\n            readNode = getReadNode(x.path.slice(1))\n            data = targetRef\n          } else { // Link the node to source data\n            readNode = x\n            data = result[sourceKey].targetRef\n          }\n          layeredAssignment(calc, x.path, resetData(readNode, data))\n        })\n      })\n    })\n  )\n  mergedData.forEach(([targetKey, data]) => {\n    delete data.teamBuff\n    const { targetRef, buffs } = result[targetKey]\n    const buff = mergeData(buffs)\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\n      // CAUTION\n      // This is safe only because `buff` is created using only `resetData`\n      // and `mergeData`. So every node here is created from either of the\n      // two functions, so the mutation wont't affect existing nodes.\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\n    })\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\n    targetRef[\"target\"] = targetRef\n  })\n  const origin = new UIData(undefined as any, undefined)\n  const uiDataResult = Object.fromEntries(Object.entries(result).map(([key, value]) =>\n    [key, {\n      target: new UIData(value.targetRef, origin),\n      buff: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\n        [key, new UIData(value, origin)]))\n    }]))\n  return uiDataResult\n}\nfunction mergeData(data: Data[]): Data {\n  function internal(data: any[], path: string[]): any {\n    if (data.length <= 1) return data[0]\n    if (data[0].operation) {\n      if (path[0] === \"teamBuff\") path = path.slice(1)\n      const accu = path[0] === \"tally\"\n        ? \"add\" : (objPathValue(input, path) as ReadNode<number> | undefined)?.accu\n      if (accu === undefined) {\n        if (data.length !== 1)\n          throw new Error(`Multiple entries when merging \\`unique\\` for key ${path}`)\n        return data[0]\n      }\n      const result: NumNode = { operation: accu, operands: data }\n      return result\n    } else {\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\n    }\n  }\n  return data.length ? internal(data, []) : {}\n}\n\nfunction computeUIData(data: Data[]): UIData {\n  return new UIData(mergeData(data), undefined)\n}\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\n}\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\n}\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\n  if (data1?.operation || data2?.operation) {\n    const d1 = data1 as NodeDisplay | undefined\n    const d2 = data2 as NodeDisplay | undefined\n\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\n      throw new Error(\"Unmatched structure when comparing UIData\")\n\n    const result: ComparedNodeDisplay = {\n      operation: true,\n      value: 0,\n      isEmpty: true,\n      unit: d2?.unit!,\n      formulas: [],\n      ...d1,\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\n    }\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\n      // In case `string` got involved, just use the other value\n      result.value = d1?.value ?? \"\" as any\n      result.diff = d2?.value ?? \"\" as any\n    }\n    return result\n  }\n\n  if (data1 || data2) {\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\n  }\n}\n\nexport type { NodeDisplay, UIData };\nexport {\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\n  mergeData, computeUIData, valueString, inferInfoMut,\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\n};\n","import { faDiceD20 } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faAnemo, faAtk, faCdReductionPrimary, faCdReductionSecondary, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRechargePrimary, faEnergyRechargeSecondary, faGeo, faHealingBonus, faHpPrimary, faHpSecondary, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\nimport { objectKeyMap } from '../Util/Util'\nimport ColorText from './ColoredText'\n\nexport function HPIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faHpPrimary as any} />\n    <FontAwesomeIcon icon={faHpSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function CdRedIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faCdReductionPrimary as any} />\n    <FontAwesomeIcon icon={faCdReductionSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function EnerRechIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faEnergyRechargePrimary as any} />\n    <FontAwesomeIcon icon={faEnergyRechargeSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\nexport const uncoloredEleIcons = {\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\n} as const\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} >{uncoloredEleIcons[key]}</ColorText>)\n\nconst StatIcon = {\n  characterHP: <HPIcon />,\n  finalHP: <HPIcon />,\n  hp_: <HPIcon />,\n  hp: <HPIcon />,\n\n  baseATK: <FontAwesomeIcon icon={faAtk as any} />,\n  characterATK: <FontAwesomeIcon icon={faAtk as any} />,\n  finalATK: <FontAwesomeIcon icon={faAtk as any} />,\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\n\n  characterDEF: <FontAwesomeIcon icon={faDef as any} />,\n  finalDEF: <FontAwesomeIcon icon={faDef as any} />,\n  def_: <FontAwesomeIcon icon={faDef as any} />,\n  def: <FontAwesomeIcon icon={faDef as any} />,\n\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\n  critDMG_: <FontAwesomeIcon icon={faDiceD20 as any} />,\n  enerRech_: <EnerRechIcon />,\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\n\n  cdRed_: <CdRedIcon />,\n\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\n\n  ...coloredEleIcon,\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [[`${ele}_dmg_`, coloredEleIcon[ele]], [`${ele}_res_`, coloredEleIcon[ele]]]))\n}\n\nexport default StatIcon\n","import { Translate } from '../../Components/Translate';\nimport { Data } from '../../Formula/type';\nimport { Rarity, WeaponKey, WeaponTypeKey } from '../../Types/consts';\nimport { DocumentSection } from '../../Types/sheet';\nimport { ICachedWeapon } from '../../Types/weapon_WR';\nimport { ascensionMaxLevel } from '../LevelData';\nimport type { WeaponData } from 'pipeline';\nconst weaponSheets = import('.').then(imp => imp.default)\n\nexport interface IWeaponSheet {\n  icon: string,\n  iconAwaken: string,\n  document: DocumentSection[],\n}\n\nexport default class WeaponSheet {\n  readonly key: WeaponKey;\n  readonly sheet: IWeaponSheet;\n  readonly data: Data;\n  readonly rarity: Rarity;\n  readonly weaponType: WeaponTypeKey;\n  constructor(key: WeaponKey, weaponSheet: IWeaponSheet, weaponData: WeaponData, data: Data) {\n    this.rarity = weaponData.rarity\n    this.weaponType = weaponData.weaponType\n    this.key = key\n    this.sheet = weaponSheet\n    this.data = data\n  }\n  static get = (weaponKey: WeaponKey | \"\"): Promise<WeaponSheet> | undefined => weaponKey ? weaponSheets.then(w => w[weaponKey]) : undefined\n  static get getAll() { return weaponSheets }\n  static getWeaponsOfType = (sheets: StrictDict<WeaponKey, WeaponSheet>, weaponType: string): Dict<WeaponKey, WeaponSheet> => Object.fromEntries(Object.entries(sheets).filter(([key, sheet]) => (sheet as WeaponSheet).weaponType === weaponType))\n  static getLevelString = (weapon: ICachedWeapon): string => `${weapon.level}/${ascensionMaxLevel[weapon.ascension]}`\n  tr = (strKey: string) => <Translate ns={`weapon_${this.key}_gen`} key18={strKey} />\n  get name() { return this.tr(\"name\") }\n  //when there is no substat, assume there is no passive.\n  get passiveName() { return this.rarity > 2 ? this.tr(\"passiveName\") : \"\" }\n  get description() { return this.tr(\"description\") }\n  passiveDescription = (refineIndex: number) => this.rarity > 2 ? this.tr(`passiveDescription.${refineIndex}`) : \"\"\n  get img() { return this.sheet.icon }\n  get imgAwaken() { return this.sheet.iconAwaken }\n  get document() { return this.sheet.document }\n}\n","import { Close } from \"@mui/icons-material\";\nimport { Button, ButtonProps } from \"@mui/material\";\nimport { useTranslation } from \"react-i18next\";\ntype CloseButtonProps = ButtonProps & {\n  large?: boolean\n}\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\n  const { t } = useTranslation(\"ui\")\n  if (large)\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\n    <Close />\n  </Button>\n}","import { uiInput } from \".\"\nimport ColorText from \"../Components/ColoredText\"\nimport KeyMap, { KeyMapPrefix, Unit } from \"../KeyMap\"\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\nimport { allOperations } from \"./optimization\"\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\n\nconst shouldWrap = true\n\nexport function valueString(value: number, unit: Unit, fixed = -1): string {\n  if (!isFinite(value)) {\n    if (value > 0) return `\\u221E`\n    if (value < 0) return `-\\u221E`\n    return 'NaN'\n  }\n  if (unit === \"%\") value *= 100\n  else unit = '' as any\n  if (Number.isInteger(value)) fixed = 0\n  else if (fixed === -1) {\n    if (unit === \"%\") fixed = 1\n    else fixed = Math.abs(value) < 10 ? 3 : Math.abs(value) < 1000 ? 2 : Math.abs(value) < 10000 ? 1 : 0\n  }\n  return `${value.toFixed(fixed)}${unit}`\n}\nexport interface NodeDisplay<V = number> {\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\n  operation: true\n  prefix?: KeyMapPrefix\n  key?: string\n  value: V\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\n  isEmpty: boolean\n  unit: Unit\n  variant?: Variant\n  formula?: Displayable\n  formulas: Displayable[]\n}\n\nexport class UIData {\n  origin: UIData\n  children = new Map<Data, UIData>()\n\n  data: Data[]\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\n\n  display: any = undefined\n  teamBuff: any = undefined\n\n  constructor(data: Data, parent: UIData | undefined) {\n    if (data === undefined) {\n      // Secret *origin* initializer\n      this.data = []\n      this.origin = this\n    } else {\n      if (!parent)\n        parent = new UIData(undefined as any, undefined)\n\n      this.data = [data, ...parent.data]\n      this.origin = parent.origin\n    }\n  }\n\n  getDisplay(): {\n    [key: string]: DisplaySub<NodeDisplay>\n  } {\n    if (!this.display) this.display = this.getAll([\"display\"])\n    return this.display\n  }\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\n    if (!this.teamBuff) {\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\n      // Convert `input` to `uiInput`\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\n        if (node) layeredAssignment(result, path, node)\n      })\n      this.teamBuff = result\n    }\n    return this.teamBuff\n  }\n  getAll(prefix: string[]): any {\n    const result = {}\n    for (const data of this.data) {\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\n    }\n    return result\n  }\n  get(node: NumNode): NodeDisplay\n  get(node: StrNode): NodeDisplay<string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\n    if (node === undefined) {\n      console.trace(\"Please report this bug with this trace\")\n      return { operation: true, value: undefined, isEmpty: true, unit: \"flat\", formulas: [] }\n    }\n    const old = this.processed.get(node)\n    if (old) return old\n\n    const result = computeNodeDisplay(this.computeNode(node))\n    this.processed.set(node, result)\n    return result\n  }\n  private computeNode(node: NumNode): ContextNodeDisplay\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\n    const old = this.nodes.get(node)\n    if (old) return old\n\n    const { operation, info } = node\n    let result: ContextNodeDisplay<number | string | undefined>\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        result = this._compute(node); break\n      case \"threshold\": result = this._threshold(node); break\n      case \"const\": result = this._constant(node.value); break\n      case \"subscript\": result = this._subscript(node); break\n      case \"read\": result = this._read(node); break\n      case \"data\": result = this._data(node); break\n      case \"match\": result = this._match(node); break\n      case \"lookup\": result = this._lookup(node); break\n      case \"prio\": {\n        const first = node.operands.find(x => this.computeNode(x).value !== undefined)\n        if (first) result = this.computeNode(first)\n        else result = illformed\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n\n    if (info) {\n      const { key, prefix, source, variant, asConst } = info\n      let { pivot } = info\n      result = { ...result }\n\n      // Pivot all keyed nodes for debugging\n      // if (key) pivot = true\n\n      if (key) result.key = key\n      if (prefix) result.prefix = prefix\n      if (source) result.source = source\n      if (variant) result.variant = variant\n      if (pivot) result.pivot = pivot\n\n      if (asConst) {\n        delete result.formula\n        delete result.assignment\n        result.dependencies = new Set()\n      }\n      if (result.pivot || !result.formula)\n        result.mayNeedWrapping = false\n    }\n    createDisplay(result)\n\n    this.nodes.set(node, result)\n    return result\n  }\n\n  private readAll(path: readonly string[]): ContextNodeDisplay<number | string | undefined>[] {\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x).map(x => this.computeNode(x))\n  }\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\n    return data && this.computeNode(data)\n  }\n\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\n    const { path } = node\n    const result = (node.accu === undefined)\n      ? this.readFirst(path) ?? (node.type === \"string\" ? this._constant(undefined) : illformed)\n      : this._accumulate(node.accu, this.readAll(path) as ContextNodeDisplay[])\n    return result\n  }\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const key = this.computeNode(node.operands[0]).value\n    const selected = node.table[key!] ?? node.operands[1]\n    if (!selected)\n      throw new Error(`Lookup Fail with key ${key}`)\n    return this.computeNode(selected)\n  }\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\n    const matching = v1.value === v2.value\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\n      ? makeEmpty(result.value) : result\n  }\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const [valueNode, thresholdNode, pass, fail] = node.operands\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\n    return (value.value >= threshold.value)\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\n  }\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    let child = this.children.get(node.data)\n    if (!child) {\n      child = new UIData(node.data, node.reset ? this.origin : this)\n      this.children.set(node.data, child)\n    }\n    return child.computeNode(node.operands[0])\n  }\n  private _compute(node: ComputeNode): ContextNodeDisplay {\n    const { operation, operands } = node\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\n  }\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\n    const operand = this.computeNode(node.operands[0])\n    const value = node.list[operand.value] ?? NaN\n    return this._constant(value)\n  }\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\n    return {\n      value, pivot: false,\n      empty: false,\n      mayNeedWrapping: false,\n      dependencies: new Set(),\n    }\n  }\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\n    let variant: Variant | undefined\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        variant = mergeVariants(operands); break\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n        const identity = allOperations[operation]([])\n        if (process.env.NODE_ENV !== \"development\")\n          operands = operands.filter(operand => operand.value !== identity)\n        if (!operands.length)\n          return variant ? { ...this._constant(identity), variant } : this._constant(identity)\n    }\n\n    let formula: { display: Displayable, dependencies: Displayable[] }\n    let mayNeedWrapping = false\n    switch (operation) {\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap }}`; break\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\n      case \"res\": {\n        const base = operands[0].value\n        if (base < 0) {\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\n          mayNeedWrapping = true\n        }\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\n        else {\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\n          mayNeedWrapping = true\n        }\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\":\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\n        else if (operation === \"add\") mayNeedWrapping = true\n    }\n\n    const value = allOperations[operation](operands.map(x => x.value))\n    const dependencies = new Set([...operands.flatMap(x =>\n      x.pivot && x.assignment\n        ? [x.assignment, ...x.dependencies]\n        : [...x.dependencies])])\n    const result: ContextNodeDisplay = {\n      formula: formula.display,\n      empty: operands.every(x => x.empty),\n      value, mayNeedWrapping,\n      pivot: false, dependencies,\n    }\n    if (variant) result.variant = variant\n    return result\n  }\n}\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\n  const dependencies = new Set<Displayable>()\n  const predisplay: Displayable[] = []\n\n  strings.forEach((string, i) => {\n    predisplay.push(string)\n\n    const key = list[i]\n    if (key) {\n      const { operands, shouldWrap, separator = \", \" } = key\n      operands.forEach((item, i, array) => {\n        let itemFormula: Displayable\n        if (!item.pivot && item.formula) itemFormula = item.formula\n        else itemFormula = createFormulaComponent(item)\n\n        if (shouldWrap && item.mayNeedWrapping) {\n          predisplay.push(\"( \")\n          predisplay.push(itemFormula)\n          predisplay.push(\" )\")\n        } else {\n          predisplay.push(itemFormula)\n        }\n        if (i + 1 < array.length) predisplay.push(separator)\n        item.dependencies.forEach(x => dependencies.add(x))\n      })\n    }\n  })\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\n}\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): ContextNodeDisplay<V>[\"variant\"] {\n  const unique = new Set(operands.map(x => x.variant))\n  if (unique.size > 1) unique.delete(undefined)\n  if (unique.size > 1) unique.delete(\"physical\")\n  return unique.values().next().value\n}\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\n  const { key, prefix, dependencies, value, variant, formula, assignment, empty } = node\n  return {\n    operation: true,\n    key, value, variant, prefix,\n    isEmpty: empty,\n    unit: (key && KeyMap.unit(key)) || \"flat\",\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\n  }\n}\n\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, key ? KeyMap.unit(key) : \"flat\")}</ColorText>\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.getNoUnit(key!)}</ColorText>{sourceDisplay}</>\n\n    if (formula)\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  //TODO: change formula size in the formula display element instead\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\n}\n/*/\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = valueString(value, key ? KeyMap.unit(key) : \"flat\")\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? ` ${source}` : \"\"\n    node.name = `${prefixDisplay}${KeyMap.getNoUnit(key!)}${sourceDisplay}`\n\n    if (formula)\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return (components as string[]).join(\"\")\n}\n//*/\n\ninterface ContextNodeDisplay<V = number> {\n  key?: Info[\"key\"]\n  prefix?: Info[\"prefix\"]\n  source?: Info[\"source\"]\n  variant?: Info[\"variant\"]\n\n  pivot: boolean\n  empty: boolean\n\n  value: V\n\n  dependencies: Set<Displayable>\n\n  mayNeedWrapping: boolean\n\n  // Don't set these manually outside of `UIData.computeNode`\n  name?: Displayable\n  valueDisplay?: Displayable\n  formula?: Displayable\n  assignment?: Displayable\n}\n\nconst illformed: ContextNodeDisplay = {\n  value: NaN, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\n  return {\n    value: emptyValue, pivot: false, empty: true, dependencies: new Set(), mayNeedWrapping: false\n  }\n}\n","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\nimport { Suspense } from \"react\"\nimport CardLight from \"./Card/CardLight\"\n\nconst ScrollModal = styled(Modal)(({ theme }) => ({\n  overflow: \"scroll\",\n  paddingTop: theme.spacing(2),\n  paddingBottom: theme.spacing(2),\n\n}))\nconst ModalContainer = styled(Container)(({ theme }) => ({\n  padding: 0,\n  minHeight: \"100%\",\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"auto\"\n  }\n}))\n\ntype ModalWrapperProps = ModalProps & {\n  containerProps?: ContainerProps\n}\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\n  return <ScrollModal {...props}>\n    <ModalContainer {...containerProps}>\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\n        {children}\n      </Suspense>\n    </ModalContainer>\n  </ScrollModal>\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\n\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\ntype SolidToggleButtonGroupPropsPartial = {\n  baseColor?: ButtonProps[\"color\"];\n  selectedColor?: ButtonProps[\"color\"];\n}\n\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"primary\", selectedColor = \"success\" }) => ({\n  '& .MuiToggleButtonGroup-grouped': {\n    '&': {\n      backgroundColor: theme.palette[baseColor].main,\n      color: theme.palette[baseColor].contrastText,\n    },\n    '&:hover': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected': {\n      backgroundColor: theme.palette[selectedColor].main,\n      color: theme.palette[selectedColor].contrastText,\n    },\n    '&.Mui-selected:hover': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n    '&.Mui-disabled': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected.Mui-disabled': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n  },\n}));\n\nexport default SolidToggleButtonGroup","import { useCallback, useState } from \"react\"\n\nexport default function useForceUpdate(): [object, () => void] {\n  const [stateDirty, update] = useState({})\n  const forceUpdateHook = useCallback(() => update({}), [])\n  return [stateDirty, forceUpdateHook]\n}","import { ReactNode } from \"react\";\n\ntype Prop = {\n  condition: boolean,\n  wrapper: (children: ReactNode) => ReactNode\n  falseWrapper?: (children: ReactNode) => ReactNode\n  children: ReactNode\n}\n// Wrap children with element provided by wrapper func when condition is true.\nexport default function ConditionalWrapper({ condition, wrapper, falseWrapper, children }: Prop) {\n  return (condition ? wrapper(children) : (falseWrapper ? falseWrapper(children) : children)) as JSX.Element;\n}","import { crystalizeLevelMultipliers, transformativeReactionLevelMultipliers, transformativeReactions } from \"../StatConstants\";\nimport { objectKeyMap } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { frac, infoMut, prod, subscript, sum, unit } from \"./utils\";\n\nconst asConst = true as const\n\nconst crystalizeMulti1 = subscript(input.lvl, crystalizeLevelMultipliers)\nconst crystalizeElemas = prod(4000 / 9, frac(input.total.eleMas, 1400))\nconst crystalizeHit = infoMut(prod(sum(unit, /** + Crystalize bonus */ crystalizeElemas), crystalizeMulti1), { /** Crystalize Shield HP */ })\n\nconst transMulti1 = subscript(input.lvl, transformativeReactionLevelMultipliers)\nconst transMulti2 = prod(16, frac(input.total.eleMas, 2000))\nconst trans = {\n  ...objectKeyMap([\"overloaded\", \"electrocharged\", \"superconduct\", \"shattered\"] as const, reaction => {\n    const { multi, variants: [ele] } = transformativeReactions[reaction]\n    return infoMut(prod(\n      infoMut(prod(multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total[`${reaction}_dmg_`]),\n      input.enemy[`${ele}_resMulti`]),\n      { key: `${reaction}_hit`, variant: reaction })\n  }),\n  swirl: objectKeyMap(transformativeReactions.swirl.variants, ele => infoMut(\n    prod(\n      infoMut(prod(transformativeReactions.swirl.multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total.swirl_dmg_),\n      input.enemy[`${ele}_resMulti`]),\n    { key: `${ele}_swirl_hit`, variant: ele }))\n}\nexport const reactions = {\n  anemo: {\n    electroSwirl: trans.swirl.electro,\n    pyroSwirl: trans.swirl.pyro,\n    cryoSwirl: trans.swirl.cryo,\n    hydroSwirl: trans.swirl.hydro,\n    shattered: trans.shattered,\n  },\n  geo: {\n    ...objectKeyMap([\"pyro\", \"electro\", \"cryo\", \"hydro\"] as const, _ =>\n      prod(2.5, crystalizeHit)),\n    shattered: trans.shattered,\n  },\n  electro: {\n    overloaded: trans.overloaded,\n    electrocharged: trans.electrocharged,\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n  hydro: {\n    electrocharged: trans.electrocharged,\n    shattered: trans.shattered,\n  },\n  pyro: {\n    overloaded: trans.overloaded,\n    shattered: trans.shattered,\n  },\n  cryo: {\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        if (!first)\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = fold(first, context)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined)\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined)\n          result = fold(operands[0], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n"],"sourceRoot":""}