{"version":3,"file":"static/js/765.656f6f7a.chunk.js","mappings":"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","sources":["Assets/Assets.ts","Components/Card/CardDark.tsx","Components/Card/CardLight.tsx","Components/CloseButton.tsx","Components/DropdownMenu/DropdownButton.tsx","Components/Image/ImgIcon.tsx","Components/ModalWrapper.tsx","Components/SolidToggleButtonGroup.tsx","Components/SqBadge.tsx","Components/StarDisplay.tsx","Components/StatIcon.tsx","Data/Characters/CharacterSheet.tsx","Data/Characters/dataUtil.tsx","Formula/api.tsx","Formula/index.ts","Formula/internal.ts","Formula/optimization.ts","Formula/reaction.ts","Formula/uiData.tsx","Formula/utils.ts","ReactHooks/useForceUpdate.tsx","ReactHooks/usePromise.tsx"],"sourcesContent":["import bow from './icon_bow.png'\r\nimport catalyst from './icon_catalyst.png'\r\nimport claymore from './icon_claymore.png'\r\nimport polearm from './icon_polearm.png'\r\nimport sword from './icon_sword.png'\r\n\r\nimport fragile from './Item_Fragile_Resin.png'\r\nimport condensed from './Item_Condensed_Resin.png'\r\n\r\n//EXP BOOKS\r\nimport advice from './Item_Wanderer\\'s_Advice.png'\r\nimport wit from './Item_Hero\\'s_Wit.png'\r\nimport experience from './Item_Adventurer\\'s_Experience.png'\r\n\r\nconst Assets = {\r\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\r\n  resin: {\r\n    fragile,\r\n    condensed\r\n  },\r\n  exp_books: {\r\n    advice,\r\n    wit,\r\n    experience,\r\n  }\r\n};\r\nexport default Assets;","import { Card, styled } from \"@mui/material\";\r\n\r\nconst CardDark = styled(Card)(({ theme }) => ({\r\n  backgroundColor: theme.palette.contentDark.main\r\n}));\r\n\r\nexport default CardDark","import { Card, styled } from \"@mui/material\";\r\n\r\nconst CardLight = styled(Card)(({ theme }) => ({\r\n  backgroundColor: theme.palette.contentLight.main\r\n}));\r\n\r\nexport default CardLight","import { Close } from \"@mui/icons-material\";\r\nimport { Button, ButtonProps } from \"@mui/material\";\r\nimport { useTranslation } from \"react-i18next\";\r\ntype CloseButtonProps = ButtonProps & {\r\n  large?: boolean\r\n}\r\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\r\n  const { t } = useTranslation(\"ui\")\r\n  if (large)\r\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\r\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\r\n    <Close />\r\n  </Button>\r\n}","import { KeyboardArrowDown } from \"@mui/icons-material\";\r\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\r\nimport { Suspense, useCallback, useState } from \"react\";\r\n\r\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\r\n  title: React.ReactNode,\r\n  id?: string,\r\n  children: React.ReactNode\r\n}\r\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\r\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\r\n  const open = Boolean(anchorEl);\r\n  const handleClick = useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\r\n    [setAnchorEl],\r\n  )\r\n  const handleClose = useCallback(\r\n    () => setAnchorEl(null),\r\n    [setAnchorEl],\r\n  )\r\n\r\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\r\n    <Button\r\n      {...props}\r\n      id={id}\r\n      aria-controls=\"basic-menu\"\r\n      aria-haspopup=\"true\"\r\n      aria-expanded={open ? 'true' : undefined}\r\n      onClick={handleClick}\r\n      endIcon={<KeyboardArrowDown />}\r\n    >\r\n      {title}\r\n    </Button>\r\n    <Menu\r\n      id=\"basic-menu\"\r\n      anchorEl={anchorEl}\r\n      open={open}\r\n      onClose={handleClose}\r\n      MenuListProps={{\r\n        'aria-labelledby': id,\r\n      }}\r\n      onClick={handleClose}\r\n    >\r\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\r\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\r\n        {children}\r\n      </Suspense>\r\n    </Menu>\r\n  </Suspense>\r\n}","import { styled } from \"@mui/material\"\r\ninterface ImgIconProps {\r\n  size?: number;\r\n}\r\nconst ImgIcon = styled(\"img\", {\r\n  name: 'ImgIcon',\r\n  slot: 'Root',\r\n})<ImgIconProps>(({ size = 1 }) => ({\r\n  display: \"inline-block\",\r\n  width: \"auto\",\r\n  height: `${size * 1.2}em`,\r\n  verticalAlign: \"text-bottom\"\r\n}))\r\n\r\nexport default ImgIcon","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\r\nimport { Suspense } from \"react\"\r\nimport CardLight from \"./Card/CardLight\"\r\n\r\nconst ScrollModal = styled(Modal)(({ theme }) => ({\r\n  overflow: \"scroll\",\r\n  paddingTop: theme.spacing(2),\r\n  paddingBottom: theme.spacing(2),\r\n\r\n}))\r\nconst ModalContainer = styled(Container)(({ theme }) => ({\r\n  padding: 0,\r\n  minHeight: \"100%\",\r\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\r\n  pointerEvents: \"none\",\r\n  \"& > *\": {\r\n    pointerEvents: \"auto\"\r\n  }\r\n}))\r\n\r\ntype ModalWrapperProps = ModalProps & {\r\n  containerProps?: ContainerProps\r\n}\r\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\r\n  return <ScrollModal {...props}>\r\n    <ModalContainer {...containerProps}>\r\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\r\n        {children}\r\n      </Suspense>\r\n    </ModalContainer>\r\n  </ScrollModal>\r\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\r\n\r\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\r\ntype SolidToggleButtonGroupPropsPartial = {\r\n  baseColor?: ButtonProps[\"color\"];\r\n  selectedColor?: ButtonProps[\"color\"];\r\n}\r\n\r\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\r\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\r\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"primary\", selectedColor = \"success\" }) => ({\r\n  '& .MuiToggleButtonGroup-grouped': {\r\n    '&': {\r\n      backgroundColor: theme.palette[baseColor].main,\r\n      color: theme.palette[baseColor].contrastText,\r\n    },\r\n    '&:hover': {\r\n      backgroundColor: theme.palette[baseColor].dark,\r\n    },\r\n    '&.Mui-selected': {\r\n      backgroundColor: theme.palette[selectedColor].main,\r\n      color: theme.palette[selectedColor].contrastText,\r\n    },\r\n    '&.Mui-selected:hover': {\r\n      backgroundColor: theme.palette[selectedColor].dark,\r\n    },\r\n    '&.Mui-disabled': {\r\n      backgroundColor: theme.palette[baseColor].dark,\r\n    },\r\n    '&.Mui-selected.Mui-disabled': {\r\n      backgroundColor: theme.palette[selectedColor].dark,\r\n    },\r\n  },\r\n}));\r\n\r\nexport default SolidToggleButtonGroup","import { styled } from \"@mui/material\";\r\n\r\nconst SqBadge = styled(\"span\", {\r\n  name: 'SqBadge',\r\n  slot: 'Root',\r\n})(({ theme, color = \"primary\" }) => ({\r\n  display: \"inline-block\",\r\n  padding: \".25em .4em\",\r\n  fontSize: \"75%\",\r\n  fontWeight: 700,\r\n  lineHeight: 1,\r\n  textAlign: \"center\",\r\n  whiteSpace: \"nowrap\",\r\n  verticalAlign: \"baseline\",\r\n  borderRadius: \".25em\",\r\n  backgroundColor: theme.palette[color]?.main,\r\n  color: theme.palette[color]?.contrastText\r\n}))\r\nexport default SqBadge","import { faStar } from '@fortawesome/free-solid-svg-icons'\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\r\nimport { Typography } from '@mui/material'\r\nimport { Rarity } from '../Types/consts'\r\n\r\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\r\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\r\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\r\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\r\n  </Typography>\r\n\r\nexport {\r\n  StarIcon,\r\n  Stars\r\n}\r\n","import { faDiceD20 } from '@fortawesome/free-solid-svg-icons'\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\r\nimport { faAnemo, faAtk, faCdReductionPrimary, faCdReductionSecondary, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRechargePrimary, faEnergyRechargeSecondary, faGeo, faHealingBonus, faHpPrimary, faHpSecondary, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\r\nimport { objectKeyMap } from '../Util/Util'\r\nimport ColorText from './ColoredText'\r\n\r\nexport function HPIcon() {\r\n  return <span className=\"fa-layers \">\r\n    <FontAwesomeIcon icon={faHpPrimary as any} />\r\n    <FontAwesomeIcon icon={faHpSecondary as any} style={{ color: \"grey\" }} />\r\n  </span>\r\n}\r\n\r\nexport function CdRedIcon() {\r\n  return <span className=\"fa-layers \">\r\n    <FontAwesomeIcon icon={faCdReductionPrimary as any} />\r\n    <FontAwesomeIcon icon={faCdReductionSecondary as any} style={{ color: \"grey\" }} />\r\n  </span>\r\n}\r\n\r\nexport function EnerRechIcon() {\r\n  return <span className=\"fa-layers \">\r\n    <FontAwesomeIcon icon={faEnergyRechargePrimary as any} />\r\n    <FontAwesomeIcon icon={faEnergyRechargeSecondary as any} style={{ color: \"grey\" }} />\r\n  </span>\r\n}\r\nexport const uncoloredEleIcons = {\r\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\r\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\r\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\r\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\r\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\r\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\r\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\r\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\r\n} as const\r\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} >{uncoloredEleIcons[key]}</ColorText>)\r\n\r\nconst StatIcon = {\r\n  characterHP: <HPIcon />,\r\n  finalHP: <HPIcon />,\r\n  hp_: <HPIcon />,\r\n  hp: <HPIcon />,\r\n\r\n  baseATK: <FontAwesomeIcon icon={faAtk as any} />,\r\n  characterATK: <FontAwesomeIcon icon={faAtk as any} />,\r\n  finalATK: <FontAwesomeIcon icon={faAtk as any} />,\r\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\r\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\r\n\r\n  characterDEF: <FontAwesomeIcon icon={faDef as any} />,\r\n  finalDEF: <FontAwesomeIcon icon={faDef as any} />,\r\n  def_: <FontAwesomeIcon icon={faDef as any} />,\r\n  def: <FontAwesomeIcon icon={faDef as any} />,\r\n\r\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\r\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\r\n  critDMG_: <FontAwesomeIcon icon={faDiceD20 as any} />,\r\n  enerRech_: <EnerRechIcon />,\r\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\r\n\r\n  cdRed_: <CdRedIcon />,\r\n\r\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\r\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\r\n\r\n  ...coloredEleIcon,\r\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [[`${ele}_dmg_`, coloredEleIcon[ele]], [`${ele}_res_`, coloredEleIcon[ele]]]))\r\n}\r\n\r\nexport default StatIcon\r\n","import ImgIcon from \"../../Components/Image/ImgIcon\";\r\nimport { ascensionMaxLevel } from \"../LevelData\";\r\nimport { Data } from \"../../Formula/type\";\r\nimport { TalentSheet, TalentSheetElement, TalentSheetElementKey } from \"../../Types/character_WR\";\r\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\r\nimport SqBadge from \"../../Components/SqBadge\";\r\nimport Assets from \"../../Assets/Assets\";\r\nimport IConditional from \"../../Types/IConditional_WR\";\r\nimport { IFieldDisplay } from \"../../Types/IFieldDisplay_WR\";\r\n\r\nconst characterSheets = import('.').then(imp => imp.default)\r\n\r\ninterface ICharacterSheetBase {\r\n  name: Displayable\r\n  cardImg: string\r\n  thumbImg: string\r\n  thumbImgSide: string\r\n  barImg?: string\r\n  bannerImg?: string\r\n  rarity: Rarity\r\n  weaponTypeKey: WeaponTypeKey\r\n  gender: string\r\n  constellationName: Displayable\r\n  title: Displayable\r\n}\r\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\r\n  elementKey: ElementKey\r\n  talent: TalentSheet\r\n}\r\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\r\n  talents: Dict<ElementKey, TalentSheet>\r\n}\r\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\r\n\r\nexport default class CharacterSheet {\r\n  sheet: ICharacterSheet;\r\n  data: Data;\r\n  constructor(charSheet: ICharacterSheet, data: Data) {\r\n    this.sheet = charSheet\r\n    this.data = data\r\n  }\r\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\r\n  static get getAll() { return characterSheets }\r\n  get name() { return this.sheet.name }\r\n  get nameWIthIcon() { return <span><ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> {this.name}</span> }\r\n  get cardImg() { return this.sheet.cardImg }\r\n  get thumbImg() { return this.sheet.thumbImg }\r\n  get thumbImgSide() { return this.sheet.thumbImgSide }\r\n  get bannerImg() { return this.sheet.bannerImg }\r\n  get rarity() { return this.sheet.rarity }\r\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\r\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\r\n  get constellationName() { return this.sheet.constellationName }\r\n\r\n  isMelee = () => {\r\n    const weaponTypeKey = this.sheet.weaponTypeKey\r\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\r\n  }\r\n  get isTraveler() {\r\n    return \"talents\" in this.sheet\r\n  }\r\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\r\n    if (\"talent\" in this.sheet) return this.sheet.talent\r\n    else return this.sheet.talents[eleKey]\r\n  }\r\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\r\n\r\n  static getLevelString = (level: number, ascension: number): string =>\r\n    `${level}/${ascensionMaxLevel[ascension]}`\r\n}\r\n\r\nexport const talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, fields?: IFieldDisplay[], conditional?: IConditional): TalentSheetElement => ({\r\n  name: tr(`${talentKey}.name`),\r\n  img,\r\n  sections: [{\r\n    text: tr(`${talentKey}.description`),\r\n    fields,\r\n    conditional,\r\n  }],\r\n})\r\n\r\nconst talentStrMap: Record<TalentSheetElementKey, string> = {\r\n  auto: \"Auto\",\r\n  skill: \"Skill\",\r\n  burst: \"Burst\",\r\n  passive: \"Passive\",\r\n  passive1: \"Ascension 1\",\r\n  passive2: \"Ascension 4\",\r\n  passive3: \"Passive\",\r\n  sprint: \"Sprint\",\r\n  constellation1: \"C1\",\r\n  constellation2: \"C2\",\r\n  constellation3: \"C3\",\r\n  constellation4: \"C4\",\r\n  constellation5: \"C5\",\r\n  constellation6: \"C6\"\r\n}\r\nexport const conditionalHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IConditional[\"header\"] => {\r\n  return {\r\n    title: tr(`${talentKey}.name`),\r\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\r\n    action: <SqBadge color=\"success\">{talentStrMap[talentKey]}</SqBadge>,\r\n  }\r\n}\r\n\r\nexport const normalSrc = (weaponKey: WeaponTypeKey) => Assets.weaponTypes[weaponKey]\r\n","import { input } from \"../../Formula\";\r\nimport { inferInfoMut, mergeData } from \"../../Formula/api\";\r\nimport { reactions } from \"../../Formula/reaction\";\r\nimport { Data, DisplaySub, NumNode } from \"../../Formula/type\";\r\nimport { constant, data, equalStr, infoMut, prod, stringPrio, subscript, sum, unit } from \"../../Formula/utils\";\r\nimport { allMainStatKeys, allSubstats, MainStatKey } from \"../../Types/artifact\";\r\nimport { CharacterKey, ElementKey, Region } from \"../../Types/consts\";\r\nimport { layeredAssignment, objectKeyMap, objectMap } from \"../../Util/Util\";\r\nimport _charCurves from \"./expCurve_gen.json\";\r\n\r\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\r\n\r\n// TODO: Remove this conversion after changing the file format\r\nconst charCurves = objectMap(_charCurves, value => [0, ...Object.values(value)])\r\n\r\nconst commonBasic = objectKeyMap([...allSubstats, \"heal_\"], key => input.total[key])\r\ncommonBasic.critRate_ = input.total.cappedCritRate\r\n\r\nconst inferredHitEle = stringPrio(\r\n  // Inferred Element\r\n  equalStr(input.weaponType, \"catalyst\", input.charEle),\r\n  equalStr(input.hit.move, \"skill\", input.charEle),\r\n  equalStr(input.hit.move, \"burst\", input.charEle),\r\n  input.infusion,\r\n  input.team.infusion,\r\n  \"physical\",\r\n)\r\n\r\nfunction getTalentType(move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\") {\r\n  switch (move) {\r\n    case \"normal\": case \"charged\": case \"plunging\": return \"auto\";\r\n    case \"skill\": return \"skill\";\r\n    case \"burst\": return \"burst\";\r\n  }\r\n}\r\n\r\n/** Note: `additional` applies only to this formula */\r\nexport function customDmgNode(base: NumNode, move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\" | \"elemental\", additional: Data = {}): NumNode {\r\n  return data(input.hit.dmg, mergeData([{\r\n    hit: { base, move: constant(move), ele: additional?.hit?.ele ? undefined : inferredHitEle },\r\n  }, additional]))\r\n}\r\n/** Note: `additional` applies only to this formula */\r\nexport function customShieldNode(base: NumNode, additional?: Data): NumNode {\r\n  const shieldNode = prod(base, sum(unit, input.total.shield_))\r\n  return additional ? data(shieldNode, additional) : shieldNode\r\n}\r\n/** Note: `additional` applies only to this formula */\r\nexport function dmgNode(base: MainStatKey, lvlMultiplier: number[], move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\", additional: Data = {}): NumNode {\r\n  const talentType = getTalentType(move)\r\n  return customDmgNode(prod(subscript(input.total[`${talentType}Index`], lvlMultiplier, { key: '_' }), input.total[base]), move, additional)\r\n}\r\n/** Note: `additional` applies only to this formula */\r\nexport function shieldNode(base: MainStatKey, percent: NumNode | number, flat: NumNode | number, additional?: Data): NumNode {\r\n  return customShieldNode(sum(prod(percent, input.total[base]), flat), additional)\r\n}\r\n/** Note: `additional` applies only to this formula */\r\nexport function shieldNodeTalent(base: MainStatKey, baseMultiplier: number[], flat: number[], move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\", additional?: Data): NumNode {\r\n  const talentType = getTalentType(move)\r\n  const talentIndex = input.total[`${talentType}Index`]\r\n  return customShieldNode(sum(\r\n    prod(subscript(talentIndex, baseMultiplier, { key: '_' }), input.total[base]),\r\n    subscript(talentIndex, flat)\r\n  ), additional)\r\n}\r\nexport function dataObjForCharacterSheet(\r\n  key: CharacterKey,\r\n  element: ElementKey | undefined,\r\n  region: Region | undefined,\r\n  gen: {\r\n    weaponTypeKey: string,\r\n    base: { hp: number, atk: number, def: number },\r\n    curves: { [key in string]?: string },\r\n    ascensions: { props: { [key in string]?: number } }[]\r\n  },\r\n  display: { [key: string]: DisplaySub },\r\n  additional: Data = {},\r\n): Data {\r\n  function curve(base: number, lvlCurve: string): NumNode {\r\n    return prod(base, subscript(input.lvl, charCurves[lvlCurve]))\r\n  }\r\n  display.basic = { ...commonBasic }\r\n  const data: Data = {\r\n    charKey: constant(key),\r\n    base: {},\r\n    weaponType: constant(gen.weaponTypeKey),\r\n    premod: {},\r\n    display,\r\n  }\r\n  if (element) {\r\n    data.charEle = constant(element)\r\n    data.teamBuff = { tally: { [element]: constant(1) } }\r\n    data.display!.basic[`${element}_dmg_`] = input.total[`${element}_dmg_`]\r\n    data.display!.reaction = reactions[element]\r\n  }\r\n  if (region)\r\n    layeredAssignment(data, [\"teamBuff\", \"tally\", region], constant(1))\r\n  if (gen.weaponTypeKey !== \"catalyst\") {\r\n    if (!data.display!.basic) data.display!.basic = {}\r\n    data.display!.basic!.physical_dmg_ = input.total.physical_dmg_\r\n  }\r\n\r\n  let foundSpecial: boolean | undefined\r\n  for (const stat of [...allMainStatKeys, \"def\" as const]) {\r\n    const list: NumNode[] = []\r\n    if (gen.curves[stat])\r\n      list.push(curve(gen.base[stat], gen.curves[stat]!))\r\n    const asc = gen.ascensions.some(x => x.props[stat])\r\n    if (asc)\r\n      list.push(subscript(input.asc, gen.ascensions.map(x => x.props[stat] ?? NaN)))\r\n\r\n    if (!list.length) continue\r\n\r\n    const result = infoMut(list.length === 1 ? list[0] : sum(...list), { key: stat, prefix: \"char\", asConst: true })\r\n    if (stat.endsWith(\"_dmg_\")) result.info!.variant = stat.slice(0, -5) as any\r\n    if (stat === \"atk\" || stat === \"def\" || stat === \"hp\")\r\n      data.base![stat] = result\r\n    else {\r\n      if (foundSpecial) throw new Error(\"Duplicated Char Special\")\r\n      foundSpecial = true\r\n      data.special = result\r\n      data.premod![stat] = input.special\r\n    }\r\n  }\r\n\r\n  return mergeData([data, inferInfoMut(additional)])\r\n}\r\n","import Artifact from \"../Data/Artifacts/Artifact\";\r\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\r\nimport { ICachedCharacter } from \"../Types/character_WR\";\r\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\r\nimport { ICachedWeapon } from \"../Types/weapon\";\r\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\r\nimport { input } from \"./index\";\r\nimport { reactions } from \"./reaction\";\r\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\r\nimport { NodeDisplay, UIData, valueString } from \"./uiData\";\r\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\r\n\r\nconst asConst = true as const, pivot = true as const\r\n\r\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\r\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\r\n    if (path[0] === \"teamBuff\") path = path.slice(1)\r\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\r\n    if (reference)\r\n      x.info = { ...reference.info, prefix: undefined, source }\r\n    else if (path[0] !== \"tally\")\r\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\r\n  })\r\n\r\n  return data\r\n}\r\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\r\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\r\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\r\n  stats.push([art.mainStatKey, mainStatVal])\r\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\r\n  return {\r\n    art: {\r\n      ...Object.fromEntries(stats.map(([key, value]) =>\r\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\r\n      [art.slotKey]: {\r\n        id: constant(art.id), set: constant(art.setKey)\r\n      },\r\n    },\r\n    artSet: {\r\n      [art.setKey]: constant(1)\r\n    }\r\n  }\r\n}\r\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\r\n  const result: Data = {\r\n    lvl: constant(char.level),\r\n    constellation: constant(char.constellation),\r\n    asc: constant(char.ascension),\r\n\r\n    premod: {\r\n      auto: constant(char.talent.auto),\r\n      skill: constant(char.talent.skill),\r\n      burst: constant(char.talent.burst),\r\n    },\r\n    enemy: {\r\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\r\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\r\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\r\n    },\r\n    hit: {\r\n      hitMode: constant(char.hitMode)\r\n    },\r\n    customBonus: {},\r\n  }\r\n\r\n  for (const [key, value] of Object.entries(char.bonusStats))\r\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\r\n\r\n  if (char.enemyOverride.enemyDefRed_)\r\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_)\r\n  if (char.enemyOverride.enemyDefIgn_)\r\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_)\r\n  if (char.elementKey) {\r\n    result.charEle = constant(char.elementKey)\r\n    result.display = {\r\n      basic: { [`${char.elementKey}_dmg_`]: input.total[`${char.elementKey}_dmg_`] },\r\n      reaction: reactions[char.elementKey]\r\n    }\r\n    layeredAssignment(result, [\"teamBuff\", \"tally\", char.elementKey], constant(1))\r\n  }\r\n\r\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\r\n    layeredAssignment(result, keys, constant(x)))\r\n  return result\r\n}\r\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\r\n  return {\r\n    weapon: {\r\n      lvl: constant(weapon.level),\r\n      asc: constant(weapon.ascension),\r\n      refinement: constant(weapon.refinement),\r\n      refineIndex: constant(weapon.refinement - 1)\r\n    },\r\n  }\r\n}\r\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\r\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\r\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\r\n  // May the goddess of wisdom bless any and all souls courageous\r\n  // enough to attempt for the understanding of this abomination.\r\n\r\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\r\n  const result = Object.fromEntries(mergedData.map(([key]) =>\r\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\r\n\r\n  const customReadNodes = {}\r\n  function getReadNode(path: readonly string[]): ReadNode<number> {\r\n    const base = (path[0] === \"teamBuff\")\r\n      ? objPathValue(teamBuff, path.slice(1))\r\n      : objPathValue(input, path)\r\n    if (base) return base\r\n    const custom = objPathValue(customReadNodes, path)\r\n    if (custom) return custom\r\n    const newNode = customRead(path)\r\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\r\n    layeredAssignment(customReadNodes, path, newNode)\r\n    return newNode\r\n  }\r\n\r\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\r\n    mergedData.forEach(([sourceKey, source]) => {\r\n      const sourceBuff = source.teamBuff\r\n      // Create new copy of `calc` as we're mutating it later\r\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\r\n      buffs.push(buff)\r\n      calcs[sourceKey] = calc\r\n\r\n      // This construction creates a `Data` representing buff\r\n      // from `source` applying to `target`. It has 3 data:\r\n      // - `target` contains the reference for the final\r\n      //   data. It is not populated at this stage,\r\n      // - `calc` contains the calculation of the buffs,\r\n      // - `buff` contains read nodes that point to the\r\n      //   calculation in `calc`.\r\n\r\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\r\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\r\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\r\n\r\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\r\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\r\n\r\n          let readNode: ReadNode<number | string> | undefined, data: Data\r\n          if (x.path[0] === \"target\") { // Link the node to target data\r\n            readNode = getReadNode(x.path.slice(1))\r\n            data = targetRef\r\n          } else { // Link the node to source data\r\n            readNode = x\r\n            data = result[sourceKey].targetRef\r\n          }\r\n          layeredAssignment(calc, x.path, resetData(readNode, data))\r\n        })\r\n      })\r\n    })\r\n  )\r\n  mergedData.forEach(([targetKey, data]) => {\r\n    delete data.teamBuff\r\n    const { targetRef, buffs } = result[targetKey]\r\n    const buff = mergeData(buffs)\r\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\r\n      // CAUTION\r\n      // This is safe only because `buff` is created using only `resetData`\r\n      // and `mergeData`. So every node here is created from either of the\r\n      // two functions, so the mutation wont't affect existing nodes.\r\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\r\n    })\r\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\r\n    targetRef[\"target\"] = targetRef\r\n  })\r\n  const origin = new UIData(undefined as any, undefined)\r\n  const uiDataResult = Object.fromEntries(Object.entries(result).map(([key, value]) =>\r\n    [key, {\r\n      target: new UIData(value.targetRef, origin),\r\n      buff: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\r\n        [key, new UIData(value, origin)]))\r\n    }]))\r\n  return uiDataResult\r\n}\r\nfunction mergeData(data: Data[]): Data {\r\n  function internal(data: any[], path: string[]): any {\r\n    if (data.length <= 1) return data[0]\r\n    if (data[0].operation) {\r\n      if (path[0] === \"teamBuff\") path = path.slice(1)\r\n      const accu = path[0] === \"tally\"\r\n        ? \"add\" : (objPathValue(input, path) as ReadNode<number> | undefined)?.accu\r\n      if (accu === undefined) {\r\n        if (data.length !== 1)\r\n          throw new Error(`Multiple entries when merging \\`unique\\` for key ${path}`)\r\n        return data[0]\r\n      }\r\n      const result: NumNode = { operation: accu, operands: data }\r\n      return result\r\n    } else {\r\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\r\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\r\n    }\r\n  }\r\n  return data.length ? internal(data, []) : {}\r\n}\r\n\r\nfunction computeUIData(data: Data[]): UIData {\r\n  return new UIData(mergeData(data), undefined)\r\n}\r\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\r\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\r\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\r\n}\r\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\r\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\r\n}\r\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\r\n  if (data1?.operation || data2?.operation) {\r\n    const d1 = data1 as NodeDisplay | undefined\r\n    const d2 = data2 as NodeDisplay | undefined\r\n\r\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\r\n      throw new Error(\"Unmatched structure when comparing UIData\")\r\n\r\n    const result: ComparedNodeDisplay = {\r\n      operation: true,\r\n      value: 0,\r\n      isEmpty: true,\r\n      unit: d2?.unit!,\r\n      formulas: [],\r\n      ...d1,\r\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\r\n    }\r\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\r\n      // In case `string` got involved, just use the other value\r\n      result.value = d1?.value ?? \"\" as any\r\n      result.diff = d2?.value ?? \"\" as any\r\n    }\r\n    return result\r\n  }\r\n\r\n  if (data1 || data2) {\r\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\r\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\r\n  }\r\n}\r\n\r\nexport type { NodeDisplay, UIData };\r\nexport {\r\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\r\n  mergeData, computeUIData, valueString, inferInfoMut,\r\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\r\n};\r\n","import { allEleEnemyResKeys } from \"../KeyMap\"\r\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\r\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\r\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\r\nimport { constant, equalStr, frac, infoMut, lookup, max, min, naught, percent, prod, read, res, setReadNodeKeys, stringRead, sum, unit } from \"./utils\"\r\n\r\nconst asConst = true as const, pivot = true as const\r\n\r\nconst allElements = allElementsWithPhy\r\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\r\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\", \"elemental\"] as const\r\nconst allArtModStats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\"] as const\r\nconst allArtNonModStats = [\"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"heal_\"] as const\r\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\r\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\r\nconst allMisc = [\r\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\r\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\", \"dmgRed_\"\r\n] as const\r\n\r\nconst allModStats = [\r\n  ...allArtModStats,\r\n  ...([\"all\", \"burning\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\r\n]\r\nconst allNonModStats = [\r\n  ...allArtNonModStats,\r\n  ...([\"all\", ...allMoves] as const).map(x => `${x}_dmgInc` as const),\r\n  ...([...allElements] as const).map(x => `${x}_critDMG_` as const),\r\n  ...allElements.map(x => `${x}_res_` as const),\r\n  ...allMoves.map(x => `${x}_critRate_` as const),\r\n  ...allEleEnemyResKeys,\r\n  \"enemyDefRed_\" as const,\r\n  ...allMisc,\r\n]\r\n\r\nconst talent = objectKeyMap(allTalents, _ => read())\r\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\r\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\r\n\r\nfor (const ele of allElements) {\r\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\r\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\r\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\r\n  allNonModStatNodes[`${ele}_dmg_`].info!.variant = ele\r\n}\r\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\r\n  allModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\r\n}\r\n\r\nfunction withDefaultInfo<T>(info: Info, value: T): T {\r\n  value = deepClone(value)\r\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\r\n  return value\r\n}\r\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\r\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\r\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\r\n  })\r\n}\r\n\r\n/** All read nodes */\r\nconst input = setReadNodeKeys(deepClone({\r\n  activeCharKey: stringRead(),\r\n  charKey: stringRead(), charEle: stringRead(), infusion: stringRead(), weaponType: stringRead(),\r\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\r\n\r\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\r\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\r\n    ...allModStatNodes, ...allNonModStatNodes,\r\n  }),\r\n  bonus: { ...talent },\r\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\r\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\r\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\r\n    ...allModStatNodes, ...allNonModStatNodes,\r\n    /** Total Crit Rate capped to [0%, 100%] */\r\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\r\n  }),\r\n\r\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\r\n    ...objectKeyMap(allArtModStats, key => allModStatNodes[key]),\r\n    ...objectKeyMap(allArtNonModStats, key => allNonModStatNodes[key]),\r\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\r\n  }),\r\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\r\n\r\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\r\n    key: stringRead(), type: stringRead(),\r\n\r\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\r\n    main: read(), sub: read(), sub2: read(),\r\n  }),\r\n\r\n  team: { infusion: stringRead() },\r\n\r\n  enemy: {\r\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\r\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\r\n\r\n    level: read(undefined, { key: \"enemyLevel\" }),\r\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\r\n    defRed: read(undefined),\r\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\r\n  },\r\n\r\n  hit: {\r\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\r\n    base: read(\"add\", { key: \"base\" }),\r\n\r\n    dmgBonus: read(undefined, { key: \"dmg_\", pivot }),\r\n    dmgInc: read(undefined, { key: \"dmgInc\", pivot }),\r\n    dmg: read(),\r\n  },\r\n}))\r\n\r\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\r\n\r\n// Adjust `info` for printing\r\nmarkAccu('add', {\r\n  bonus, customBonus, premod, art,\r\n  total: objectKeyMap(allModStats, stat => total[stat]),\r\n})\r\nbonus.auto.info = { key: \"autoBoost\" }\r\nbonus.skill.info = { key: \"skillBoost\" }\r\nbonus.burst.info = { key: \"burstBoost\" }\r\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\r\ndelete total.critRate_.info!.pivot\r\ntotal.critRate_.info!.prefix = \"uncapped\"\r\n\r\n// Nodes that are not used anywhere else but `common` below\r\n\r\n/** Base Amplifying Bonus */\r\nconst baseAmpBonus = sum(unit, prod(25 / 9, frac(total.eleMas, 1400)))\r\n/** Effective reaction, taking into account the hit's element */\r\nexport const effectiveReaction = lookup(hit.ele, {\r\n  pyro: lookup(hit.reaction, { vaporize: constant(\"vaporize\"), melt: constant(\"melt\") }, undefined),\r\n  hydro: equalStr(hit.reaction, \"vaporize\", \"vaporize\"),\r\n  cryo: equalStr(hit.reaction, \"melt\", \"melt\"),\r\n}, undefined)\r\n\r\nconst common: Data = {\r\n  premod: {\r\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\r\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\r\n    ...objectKeyMap([...allModStats, ...allArtNonModStats] as const, key => {\r\n      const operands: NumNode[] = []\r\n      switch (key) {\r\n        case \"atk\": case \"def\": case \"hp\":\r\n          operands.push(prod(base[key], sum(unit, premod[`${key}_`])))\r\n          break\r\n        case \"critRate_\":\r\n          operands.push(percent(0.05, { key, prefix: \"default\" }),\r\n            lookup(hit.move, objectKeyMap(allMoves, move => customBonus[`${move}_critRate_`]), 0))\r\n          break\r\n        case \"critDMG_\":\r\n          operands.push(percent(0.5, { key, prefix: \"default\" }),\r\n            lookup(hit.ele, objectKeyMap(allElements, ele => customBonus[`${ele}_critDMG_`]), 0))\r\n          break\r\n        case \"enerRech_\":\r\n          operands.push(percent(1, { key, prefix: \"default\" }))\r\n          break\r\n      }\r\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\r\n    }),\r\n  },\r\n  total: {\r\n    ...objectKeyMap(allTalents, talent => premod[talent]),\r\n    ...objectKeyMap(allModStats, key => premod[key]),\r\n    ...objectKeyMap(allNonModStats, key => premod[key]),\r\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\r\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\r\n\r\n    cappedCritRate: max(min(total.critRate_, unit), naught),\r\n  },\r\n\r\n  hit: {\r\n    dmgBonus: sum(\r\n      total.all_dmg_,\r\n      lookup(effectiveReaction, objectKeyMap(allAmplifying, reaction => total[`${reaction}_dmg_`]), naught),\r\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\r\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\r\n    ),\r\n    dmgInc: sum(\r\n      total.all_dmgInc,\r\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\r\n    ),\r\n    dmg: prod(\r\n      sum(hit.base, hit.dmgInc),\r\n      sum(unit, hit.dmgBonus),\r\n      lookup(hit.hitMode, {\r\n        hit: unit,\r\n        critHit: sum(unit, total.critDMG_),\r\n        avgHit: sum(unit, prod(total.cappedCritRate, total.critDMG_)),\r\n      }, NaN),\r\n      enemy.def,\r\n      lookup(hit.ele,\r\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\r\n      lookup(effectiveReaction, {\r\n        melt: lookup(hit.ele, {\r\n          pyro: prod(2, baseAmpBonus),\r\n          cryo: prod(1.5, baseAmpBonus),\r\n        }, 1, { key: \"melt_dmg_\" }),\r\n        vaporize: lookup(hit.ele, {\r\n          hydro: prod(2, baseAmpBonus),\r\n          pyro: prod(1.5, baseAmpBonus),\r\n        }, 1, { key: \"vaporize_dmg_\" }),\r\n      }, 1),\r\n    ),\r\n  },\r\n\r\n  enemy: {\r\n    // TODO: shred cap of 90%\r\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(unit, prod(-1, enemy.defRed)), sum(unit, prod(-1, enemy.defIgn)))),\r\n    defRed: total.enemyDefRed_,\r\n    ...objectKeyValueMap(allElements, ele =>\r\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\r\n  },\r\n}\r\n\r\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\r\nconst tally = setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"])\r\n\r\n/**\r\n * List of `input` nodes, rearranged to conform to the needs of the\r\n * UI code. This is a separate list so that the evolution of the UIs\r\n * does not rely on the structure of `input`. So the UI code can rearrange\r\n * nodes as it sees fit without requiring updates to data sheets, which\r\n * pertains ~90% of all `input`-related code, and so are very sensitive\r\n * to any changes to `input`. For zero overhead, use the nodes directly\r\n * from `input` instead of a copy.\r\n */\r\nconst uiInput = input\r\n\r\nexport {\r\n  input, uiInput, common, customBonus,\r\n\r\n  target, tally,\r\n}\r\n","import { AnyNode, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\r\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\r\n\r\n  function traverse(formula: (NumNode | StrNode)) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\r\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\r\n  const visiting = new Set<(NumNode | StrNode)>()\r\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n\r\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\r\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\r\n  const visiting = new Set<AnyNode>()\r\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n\r\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\r\n    let topDownMapping = topDownByContext.get(parentContextId)\r\n    if (!topDownMapping) {\r\n      topDownMapping = new Map()\r\n      topDownByContext.set(parentContextId, topDownMapping)\r\n    }\r\n\r\n    let topDown = topDownMapping.get(formula)\r\n    if (topDown) return topDown\r\n    let topDownContextId: number\r\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n\r\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\r\n    if (!bottomUpMapping) {\r\n      bottomUpMapping = new Map()\r\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\r\n    }\r\n\r\n    let bottomUp = bottomUpMapping.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    visiting.add(topDown)\r\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\r\n    visiting.delete(topDown)\r\n\r\n    bottomUpMapping.set(topDown, bottomUp)\r\n    topDownMapping.set(formula, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\r\n    const operands = formula.operands.map(f => check(f, contextId))\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(f => check(f, baseContextId))\r\n  return arrayEqual(formulas, result) ? formulas : result\r\n}\r\n\r\ntype ContextID = number\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { constant } from \"./utils\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode } from \"./type\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\r\n  // TODO: Use min-cut to minimize the size of interim array\r\n  type Reference = string | number | { ins: Reference[] }\r\n\r\n  const uniqueReadStrings = new Set<string>()\r\n  const uniqueNumbers = new Set<number>()\r\n  const mapping = new Map<NumNode, Reference>()\r\n\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation } = f\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\r\n          throw new Error(`Unsupported ${operation} node in precompute`)\r\n        const name = binding(f)\r\n        uniqueReadStrings.add(name)\r\n        mapping.set(f, name)\r\n        break\r\n      case \"add\": case \"min\": case \"max\": case \"mul\":\r\n      case \"threshold\": case \"res\": case \"sum_frac\":\r\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\r\n        break\r\n      case \"const\":\r\n        if (typeof f.value !== \"number\")\r\n          throw new Error(\"Found string constant while precomputing\")\r\n        const value = f.value\r\n        uniqueNumbers.add(value)\r\n        mapping.set(f as ConstantNode<number>, value)\r\n        break\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  /**\r\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\r\n   *\r\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\r\n   * in the same order as formulas even when they are duplicated. Inputs\r\n   * are arranged in the same order as the read strings, even when they\r\n   * overlap with outputs. If an output is a constant or a compute node,\r\n   * only put the data in the output region.\r\n   */\r\n  const locations = new Map<NumNode | number | string, number>()\r\n\r\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\r\n  const constValues = [...uniqueNumbers]\r\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\r\n\r\n  formulas.forEach((f, i) => {\r\n    locations.set(f, i)\r\n    if (f.operation === \"const\") locations.set(f.value, i)\r\n  })\r\n  // After this line, if some outputs are also read node, `locations`\r\n  // will point to the one in the read node portion instead.\r\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\r\n  let offset = formulas.length + readStrings.length\r\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\r\n\r\n  // `locations` is stable from this point on. We now only append new values.\r\n  // There is no change to existing values.\r\n  //\r\n  // DO NOT read from `location` prior to this line.\r\n  mapping.forEach((ref, node) => {\r\n    if (typeof ref !== \"object\") {\r\n      locations.set(node, locations.get(ref)!)\r\n      return\r\n    }\r\n    if (!locations.has(node)) locations.set(node, offset++)\r\n    computations.push({\r\n      out: locations.get(node)!,\r\n      ins: node.operands.map(op => locations.get(op)!),\r\n      op: allOperations[node.operation],\r\n      buff: Array(node.operands.length).fill(0),\r\n    })\r\n  })\r\n\r\n  const buffer = Array(offset).fill(0)\r\n  buffer.forEach((_, i, array) => array[i] = NaN)\r\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\r\n\r\n  // Copy target for when some outputs are duplicated\r\n  const copyList = formulas.map((node, i) => {\r\n    const src = locations.get(node)!\r\n    return src !== i ? [src, i] : undefined!\r\n  }).filter(x => x)\r\n  const copyFormula = copyList.length ? () => {\r\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\r\n  } : undefined\r\n\r\n  return values => {\r\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\r\n    computations.forEach(({ out, ins, op, buff }) => {\r\n      ins.forEach((i, j) => buff[j] = buffer[i])\r\n      buffer[out] = op(buff)\r\n    })\r\n    copyFormula?.()\r\n    return buffer\r\n  }\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        if (!first)\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = fold(first, context)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\r\n        if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined)\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined)\r\n          result = fold(operands[0], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","import { absorbableEle } from \"../Data/Characters/dataUtil\";\r\nimport { crystallizeLevelMultipliers, transformativeReactionLevelMultipliers, transformativeReactions } from \"../StatConstants\";\r\nimport { objectKeyMap } from \"../Util/Util\";\r\nimport { input } from \"./index\";\r\nimport { frac, infoMut, percent, prod, subscript, sum, unit } from \"./utils\";\r\n\r\nconst asConst = true as const\r\n\r\nconst crystallizeMulti1 = subscript(input.lvl, crystallizeLevelMultipliers)\r\nconst crystallizeElemas = prod(4000 / 9, frac(input.total.eleMas, 1400))\r\nconst crystallizeHit = infoMut(prod(sum(unit, /** + Crystallize bonus */ crystallizeElemas), crystallizeMulti1), { key: \"crystallize\", variant: \"geo\" })\r\n\r\nconst transMulti1 = subscript(input.lvl, transformativeReactionLevelMultipliers)\r\nconst transMulti2 = prod(16, frac(input.total.eleMas, 2000))\r\nconst trans = {\r\n  ...objectKeyMap([\"overloaded\", \"electrocharged\", \"superconduct\", \"shattered\"] as const, reaction => {\r\n    const { multi, variants: [ele] } = transformativeReactions[reaction]\r\n    return infoMut(prod(\r\n      infoMut(prod(multi, transMulti1), { asConst }),\r\n      sum(unit, transMulti2, input.total[`${reaction}_dmg_`]),\r\n      input.enemy[`${ele}_resMulti`]),\r\n      { key: `${reaction}_hit`, variant: reaction })\r\n  }),\r\n  swirl: objectKeyMap(transformativeReactions.swirl.variants, ele => infoMut(\r\n    prod(\r\n      infoMut(prod(transformativeReactions.swirl.multi, transMulti1), { asConst }),\r\n      sum(unit, transMulti2, input.total.swirl_dmg_),\r\n      input.enemy[`${ele}_resMulti`]),\r\n    { key: `${ele}_swirl_hit`, variant: ele }))\r\n}\r\nexport const reactions = {\r\n  anemo: {\r\n    electroSwirl: trans.swirl.electro,\r\n    pyroSwirl: trans.swirl.pyro,\r\n    cryoSwirl: trans.swirl.cryo,\r\n    hydroSwirl: trans.swirl.hydro,\r\n    shattered: trans.shattered,\r\n  },\r\n  geo: {\r\n    crystallize: crystallizeHit,\r\n    ...Object.fromEntries(absorbableEle.map(e => [`${e}Crystallize`,\r\n    infoMut(prod(percent(2.5), crystallizeHit), { key: `${e}_crystallize`, variant: e })])),\r\n    shattered: trans.shattered,\r\n  },\r\n  electro: {\r\n    overloaded: trans.overloaded,\r\n    electrocharged: trans.electrocharged,\r\n    superconduct: trans.superconduct,\r\n    shattered: trans.shattered,\r\n  },\r\n  hydro: {\r\n    electrocharged: trans.electrocharged,\r\n    shattered: trans.shattered,\r\n  },\r\n  pyro: {\r\n    overloaded: trans.overloaded,\r\n    shattered: trans.shattered,\r\n  },\r\n  cryo: {\r\n    superconduct: trans.superconduct,\r\n    shattered: trans.shattered,\r\n  },\r\n}\r\n","import { uiInput } from \".\"\r\nimport ColorText from \"../Components/ColoredText\"\r\nimport KeyMap, { KeyMapPrefix, Unit } from \"../KeyMap\"\r\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\r\nimport { allOperations } from \"./optimization\"\r\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\r\n\r\nconst shouldWrap = true\r\n\r\nexport function valueString(value: number, unit: Unit, fixed = -1): string {\r\n  if (!isFinite(value)) {\r\n    if (value > 0) return `\\u221E`\r\n    if (value < 0) return `-\\u221E`\r\n    return 'NaN'\r\n  }\r\n  if (unit === \"%\") value *= 100\r\n  else unit = '' as any\r\n  if (Number.isInteger(value)) fixed = 0\r\n  else if (fixed === -1) {\r\n    if (unit === \"%\") fixed = 1\r\n    else fixed = Math.abs(value) < 10 ? 3 : Math.abs(value) < 1000 ? 2 : Math.abs(value) < 10000 ? 1 : 0\r\n  }\r\n  return `${value.toFixed(fixed)}${unit}`\r\n}\r\nexport interface NodeDisplay<V = number> {\r\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\r\n  operation: true\r\n  prefix?: KeyMapPrefix\r\n  key?: string\r\n  value: V\r\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\r\n  isEmpty: boolean\r\n  unit: Unit\r\n  variant?: Variant\r\n  formula?: Displayable\r\n  formulas: Displayable[]\r\n}\r\n\r\nexport class UIData {\r\n  origin: UIData\r\n  children = new Map<Data, UIData>()\r\n\r\n  data: Data[]\r\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\r\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\r\n\r\n  display: any = undefined\r\n  teamBuff: any = undefined\r\n\r\n  constructor(data: Data, parent: UIData | undefined) {\r\n    if (data === undefined) {\r\n      // Secret *origin* initializer\r\n      this.data = []\r\n      this.origin = this\r\n    } else {\r\n      if (!parent)\r\n        parent = new UIData(undefined as any, undefined)\r\n\r\n      this.data = [data, ...parent.data]\r\n      this.origin = parent.origin\r\n    }\r\n  }\r\n\r\n  getDisplay(): {\r\n    [key: string]: DisplaySub<NodeDisplay>\r\n  } {\r\n    if (!this.display) this.display = this.getAll([\"display\"])\r\n    return this.display\r\n  }\r\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\r\n    if (!this.teamBuff) {\r\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\r\n      // Convert `input` to `uiInput`\r\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\r\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\r\n        if (node) layeredAssignment(result, path, node)\r\n      })\r\n      this.teamBuff = result\r\n    }\r\n    return this.teamBuff\r\n  }\r\n  getAll(prefix: string[]): any {\r\n    const result = {}\r\n    for (const data of this.data) {\r\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\r\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\r\n    }\r\n    return result\r\n  }\r\n  get(node: NumNode): NodeDisplay\r\n  get(node: StrNode): NodeDisplay<string | undefined>\r\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\r\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\r\n    if (node === undefined) {\r\n      console.trace(\"Please report this bug with this trace\")\r\n      return { operation: true, value: undefined, isEmpty: true, unit: \"flat\", formulas: [] }\r\n    }\r\n    const old = this.processed.get(node)\r\n    if (old) return old\r\n\r\n    const result = computeNodeDisplay(this.computeNode(node))\r\n    this.processed.set(node, result)\r\n    return result\r\n  }\r\n  private computeNode(node: NumNode): ContextNodeDisplay\r\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\r\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\r\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\r\n    const old = this.nodes.get(node)\r\n    if (old) return old\r\n\r\n    const { operation, info } = node\r\n    let result: ContextNodeDisplay<number | string | undefined>\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n      case \"res\": case \"sum_frac\":\r\n        result = this._compute(node); break\r\n      case \"threshold\": result = this._threshold(node); break\r\n      case \"const\": result = this._constant(node.value); break\r\n      case \"subscript\": result = this._subscript(node); break\r\n      case \"read\": result = this._read(node); break\r\n      case \"data\": result = this._data(node); break\r\n      case \"match\": result = this._match(node); break\r\n      case \"lookup\": result = this._lookup(node); break\r\n      case \"prio\": {\r\n        const first = node.operands.find(x => this.computeNode(x).value !== undefined)\r\n        if (first) result = this.computeNode(first)\r\n        else result = illformed\r\n        break\r\n      }\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    if (info) {\r\n      const { key, prefix, source, variant, asConst } = info\r\n      let { pivot } = info\r\n      result = { ...result }\r\n\r\n      // Pivot all keyed nodes for debugging\r\n      // if (key) pivot = true\r\n\r\n      if (key) result.key = key\r\n      if (prefix) result.prefix = prefix\r\n      if (source) result.source = source\r\n      if (variant) result.variant = variant\r\n      if (pivot) result.pivot = pivot\r\n\r\n      if (asConst) {\r\n        delete result.formula\r\n        delete result.assignment\r\n        result.dependencies = new Set()\r\n      }\r\n      if (result.pivot || !result.formula)\r\n        result.mayNeedWrapping = false\r\n    }\r\n    createDisplay(result)\r\n\r\n    this.nodes.set(node, result)\r\n    return result\r\n  }\r\n\r\n  private readAll(path: readonly string[]): ContextNodeDisplay<number | string | undefined>[] {\r\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x).map(x => this.computeNode(x))\r\n  }\r\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\r\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\r\n    return data && this.computeNode(data)\r\n  }\r\n\r\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\r\n    const { path } = node\r\n    const result = (node.accu === undefined)\r\n      ? this.readFirst(path) ?? (node.type === \"string\" ? this._constant(undefined) : illformed)\r\n      : this._accumulate(node.accu, this.readAll(path) as ContextNodeDisplay[])\r\n    return result\r\n  }\r\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const key = this.computeNode(node.operands[0]).value\r\n    const selected = node.table[key!] ?? node.operands[1]\r\n    if (!selected)\r\n      throw new Error(`Lookup Fail with key ${key}`)\r\n    return this.computeNode(selected)\r\n  }\r\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\r\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\r\n    const matching = v1.value === v2.value\r\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\r\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\r\n      ? makeEmpty(result.value) : result\r\n  }\r\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const [valueNode, thresholdNode, pass, fail] = node.operands\r\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\r\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\r\n    return (value.value >= threshold.value)\r\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\r\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\r\n  }\r\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    let child = this.children.get(node.data)\r\n    if (!child) {\r\n      child = new UIData(node.data, node.reset ? this.origin : this)\r\n      this.children.set(node.data, child)\r\n    }\r\n    return child.computeNode(node.operands[0])\r\n  }\r\n  private _compute(node: ComputeNode): ContextNodeDisplay {\r\n    const { operation, operands } = node\r\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\r\n  }\r\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\r\n    const operand = this.computeNode(node.operands[0])\r\n    const value = node.list[operand.value] ?? NaN\r\n    return this._constant(value)\r\n  }\r\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\r\n    return {\r\n      value, pivot: false,\r\n      empty: false,\r\n      mayNeedWrapping: false,\r\n      dependencies: new Set(),\r\n    }\r\n  }\r\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\r\n    let variant: Variant | undefined\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n      case \"res\": case \"sum_frac\":\r\n        variant = mergeVariants(operands); break\r\n      default: assertUnreachable(operation)\r\n    }\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n        const identity = allOperations[operation]([])\r\n        if (process.env.NODE_ENV !== \"development\")\r\n          operands = operands.filter(operand => operand.value !== identity)\r\n        if (!operands.length)\r\n          return variant ? { ...this._constant(identity), variant } : this._constant(identity)\r\n    }\r\n\r\n    let formula: { display: Displayable, dependencies: Displayable[] }\r\n    let mayNeedWrapping = false\r\n    switch (operation) {\r\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\r\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\r\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\r\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap }}`; break\r\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\r\n      case \"res\": {\r\n        const base = operands[0].value\r\n        if (base < 0) {\r\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\r\n          mayNeedWrapping = true\r\n        }\r\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\r\n        else {\r\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\r\n          mayNeedWrapping = true\r\n        }\r\n        break\r\n      }\r\n      default: assertUnreachable(operation)\r\n    }\r\n    switch (operation) {\r\n      case \"add\": case \"mul\":\r\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\r\n        else if (operation === \"add\") mayNeedWrapping = true\r\n    }\r\n\r\n    const value = allOperations[operation](operands.map(x => x.value))\r\n    const dependencies = new Set([...operands.flatMap(x =>\r\n      x.pivot && x.assignment\r\n        ? [x.assignment, ...x.dependencies]\r\n        : [...x.dependencies])])\r\n    const result: ContextNodeDisplay = {\r\n      formula: formula.display,\r\n      empty: operands.every(x => x.empty),\r\n      value, mayNeedWrapping,\r\n      pivot: false, dependencies,\r\n    }\r\n    if (variant) result.variant = variant\r\n    return result\r\n  }\r\n}\r\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\r\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\r\n  const dependencies = new Set<Displayable>()\r\n  const predisplay: Displayable[] = []\r\n\r\n  strings.forEach((string, i) => {\r\n    predisplay.push(string)\r\n\r\n    const key = list[i]\r\n    if (key) {\r\n      const { operands, shouldWrap, separator = \", \" } = key\r\n      operands.forEach((item, i, array) => {\r\n        let itemFormula: Displayable\r\n        if (!item.pivot && item.formula) itemFormula = item.formula\r\n        else itemFormula = createFormulaComponent(item)\r\n\r\n        if (shouldWrap && item.mayNeedWrapping) {\r\n          predisplay.push(\"( \")\r\n          predisplay.push(itemFormula)\r\n          predisplay.push(\" )\")\r\n        } else {\r\n          predisplay.push(itemFormula)\r\n        }\r\n        if (i + 1 < array.length) predisplay.push(separator)\r\n        item.dependencies.forEach(x => dependencies.add(x))\r\n      })\r\n    }\r\n  })\r\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\r\n}\r\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): ContextNodeDisplay<V>[\"variant\"] {\r\n  const unique = new Set(operands.map(x => x.variant))\r\n  if (unique.size > 1) unique.delete(undefined)\r\n  if (unique.size > 1) unique.delete(\"physical\")\r\n  return unique.values().next().value\r\n}\r\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\r\n  const { key, prefix, dependencies, value, variant, formula, assignment, empty } = node\r\n  return {\r\n    operation: true,\r\n    key, value, variant, prefix,\r\n    isEmpty: empty,\r\n    unit: (key && KeyMap.unit(key)) || \"flat\",\r\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\r\n  }\r\n}\r\n\r\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\r\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\r\n  const { key, value, formula, prefix, source, variant } = node\r\n  if (typeof value !== \"number\") return\r\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, key ? KeyMap.unit(key) : \"flat\")}</ColorText>\r\n  if (key && key !== '_') {\r\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\r\n    // TODO: Convert `source` key to actual name\r\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\r\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.getNoUnit(key!)}</ColorText>{sourceDisplay}</>\r\n\r\n    if (formula)\r\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\r\n  }\r\n}\r\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\r\n  const { name, valueDisplay } = node\r\n  //TODO: change formula size in the formula display element instead\r\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\r\n}\r\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\r\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\r\n}\r\n/*/\r\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\r\n  const { key, value, formula, prefix, source, variant } = node\r\n  if (typeof value !== \"number\") return\r\n  node.valueDisplay = valueString(value, key ? KeyMap.unit(key) : \"flat\")\r\n  if (key && key !== '_') {\r\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\r\n    // TODO: Convert `source` key to actual name\r\n    const sourceDisplay = source ? ` ${source}` : \"\"\r\n    node.name = `${prefixDisplay}${KeyMap.getNoUnit(key!)}${sourceDisplay}`\r\n\r\n    if (formula)\r\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\r\n  }\r\n}\r\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\r\n  const { name, valueDisplay } = node\r\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\r\n}\r\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\r\n  return (components as string[]).join(\"\")\r\n}\r\n//*/\r\n\r\ninterface ContextNodeDisplay<V = number> {\r\n  key?: Info[\"key\"]\r\n  prefix?: Info[\"prefix\"]\r\n  source?: Info[\"source\"]\r\n  variant?: Info[\"variant\"]\r\n\r\n  pivot: boolean\r\n  empty: boolean\r\n\r\n  value: V\r\n\r\n  dependencies: Set<Displayable>\r\n\r\n  mayNeedWrapping: boolean\r\n\r\n  // Don't set these manually outside of `UIData.computeNode`\r\n  name?: Displayable\r\n  valueDisplay?: Displayable\r\n  formula?: Displayable\r\n  assignment?: Displayable\r\n}\r\n\r\nconst illformed: ContextNodeDisplay = {\r\n  value: NaN, pivot: true,\r\n  empty: false,\r\n  dependencies: new Set(),\r\n  mayNeedWrapping: false\r\n}\r\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\r\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\r\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\r\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\r\n  return {\r\n    value: emptyValue, pivot: false, empty: true, dependencies: new Set(), mayNeedWrapping: false\r\n  }\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\r\n\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype Any = Num | Str\r\n\r\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\r\nexport const unit = percent(1), naught = percent(0)\r\n\r\nexport function constant(value: number, info?: Info): NumNode\r\nexport function constant(value: string | undefined, info?: Info): StrNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\r\n  return { operation: \"const\", operands: [], value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): NumNode {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { key: \"_\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\r\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\r\n  return { operation: \"lookup\", operands, table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Num[]): NumNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Num[]): NumNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Num[]): NumNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Num[]): NumNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Num, c: Num): NumNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Num): NumNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\r\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\r\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\nexport function stringRead(): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: Any[]): AnyNode[]\r\nfunction intoOps(values: Any[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: Num | Str): NumNode | StrNode\r\nfunction intoV(value: Any): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\n\r\ntype _NodeList = {\r\n  [key: string]: NodeList\r\n} & {\r\n  operation?: never\r\n}\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n\r\n/*\r\n * Deprecated\r\n */\r\n\r\n/**\r\n * value >= threshold ? value : emptyValue\r\n * @deprecated Use `greaterEq`, `lessEq`, or `greaterEqStr` instead\r\n */\r\nexport function threshold(value: Num, threshold: Num, pass: Str, fail: Str, info?: Info): StrNode\r\nexport function threshold(value: Num, threshold: Num, pass: Num, fail: Num, info?: Info): NumNode\r\nexport function threshold(value: Num, threshold: Num, pass: Num | Str, fail: Num | Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(value), intoV(threshold), intoV(pass), intoV(fail)] as any\r\n  return { operation: \"threshold\", operands, info }\r\n}\r\n/**\r\n * value >= threshold ? addition : 0\r\n * @deprecated Use `greaterEq` or `lessEq` instead\r\n */\r\nexport function threshold_add(value: Num, thres: Num, addition: Num, info?: Info): NumNode {\r\n  return threshold(value, thres, addition, 0, info)\r\n}\r\n\r\n/**\r\n * `v1` === `v2` ? `match` : 0\r\n * @deprecated Use `equal` instead\r\n */\r\nexport function match(v1: Str, v2: Str, match: Num, info?: Info): NumNode {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/**\r\n * `v1` === `v2` ? 0 : `unmatch`\r\n * @deprecated Use `unequal` instead\r\n */\r\nexport function unmatch(v1: Str, v2: Str, unmatch: Num, info?: Info): NumNode {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(unmatch)], info, emptyOn: \"match\" }\r\n}\r\n/**\r\n * `v1` === `v2` ? `match` : `unmatch`\r\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\r\n */\r\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\r\n}\r\n","import { useCallback, useState } from \"react\"\r\n\r\nexport default function useForceUpdate(): [object, () => void] {\r\n  const [stateDirty, update] = useState({})\r\n  const forceUpdateHook = useCallback(() => update({}), [])\r\n  return [stateDirty, forceUpdateHook]\r\n}","import { useEffect, useState } from \"react\";\r\n\r\nexport default function usePromise<T>(promise: Promise<T> | undefined, dependencies: any[]): T | undefined {\r\n  const [res, setRes] = useState<T | undefined>(undefined);\r\n  useEffect(() => {\r\n    let pending = true\r\n    promise?.then(res => pending && setRes(() => res), console.error) ?? setRes(undefined)\r\n    return () => {\r\n      pending = false\r\n      setRes(undefined)\r\n    }\r\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\r\n  return res\r\n}"],"names":["Assets","weaponTypes","bow","catalyst","claymore","polearm","sword","resin","fragile","condensed","exp_books","advice","wit","experience","CardDark","styled","Card","backgroundColor","theme","palette","contentDark","main","CardLight","contentLight","CloseButton","large","props","t","useTranslation","color","startIcon","sx","p","minWidth","DropdownButton","title","children","id","useState","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","Suspense","fallback","endIcon","width","undefined","onClick","onClose","MenuListProps","height","ImgIcon","name","slot","size","display","verticalAlign","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","padding","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","variant","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","contrastText","dark","SqBadge","fontSize","fontWeight","lineHeight","textAlign","whiteSpace","borderRadius","StarIcon","icon","faStar","Stars","stars","colored","component","Array","keys","map","_","i","HPIcon","className","faHpPrimary","faHpSecondary","style","CdRedIcon","faCdReductionPrimary","faCdReductionSecondary","EnerRechIcon","faEnergyRechargePrimary","faEnergyRechargeSecondary","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","hydro","faHydro","pyro","faPyro","cryo","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","objectKeyMap","Object","key","StatIcon","characterHP","finalHP","hp_","hp","baseATK","faAtk","characterATK","finalATK","atk_","atk","characterDEF","faDef","finalDEF","def_","def","eleMas","faElementalMastery","critRate_","faCritRate","critDMG_","faDiceD20","enerRech_","heal_","faHealingBonus","cdRed_","shield_","faShieldStrength","stamina","faMaxStamina","fromEntries","flatMap","ele","characterSheets","then","imp","default","CharacterSheet","charSheet","data","sheet","isMelee","weaponTypeKey","getTalent","eleKey","talent","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","charKey","c","getLevelString","level","ascension","ascensionMaxLevel","talentTemplate","tr","img","fields","conditional","sections","text","talentStrMap","auto","skill","burst","passive","passive1","passive2","passive3","sprint","constellation1","constellation2","constellation3","constellation4","constellation5","constellation6","conditionalHeader","m","action","normalSrc","weaponKey","absorbableEle","charCurves","objectMap","_charCurves","value","values","commonBasic","allSubstats","input","inferredHitEle","stringPrio","equalStr","getTalentType","move","customDmgNode","base","additional","mergeData","hit","constant","customShieldNode","shieldNode","prod","sum","unit","dmgNode","lvlMultiplier","talentType","subscript","shieldNodeTalent","baseMultiplier","flat","talentIndex","dataObjForCharacterSheet","element","region","gen","curve","lvlCurve","basic","foundSpecial","weaponType","premod","charEle","teamBuff","tally","reaction","reactions","layeredAssignment","physical_dmg_","stat","list","curves","push","ascensions","some","x","NaN","length","result","infoMut","prefix","asConst","endsWith","info","slice","Error","special","allMainStatKeys","inferInfoMut","source","crawlObject","operation","path","reference","objPathValue","console","error","dataObjForArtifact","art","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatKey","Math","max","min","stats","substats","forEach","accurateValue","percent","slotKey","set","setKey","artSet","dataObjForCharacter","char","lvl","constellation","asc","enemy","allElementsWithPhy","enemyOverride","enemyLevel","hitMode","customBonus","entries","bonusStats","enemyDefRed_","enemyDefIgn_","defIgn","dataObjForWeapon","weapon","refinement","refineIndex","setReadNodeKeys","deepClone","uiDataForTeam","teamData","activeCharKey","mergedData","targetRef","buffs","calcs","customReadNodes","getReadNode","custom","newNode","customRead","accu","sourceKey","sourceBuff","buff","calc","resetData","readNode","targetKey","pivot","assign","origin","UIData","target","internal","operands","Set","filter","computeUIData","allElements","allTalents","allMoves","allArtModStats","allArtNonModStats","allTransformative","allAmplifying","allModStats","allNonModStats","allEleEnemyResKeys","read","allModStatNodes","allNonModStatNodes","withDefaultInfo","stringRead","infusion","bonus","total","objectKeyValueMap","cappedCritRate","allSlotKeys","allArtifactSets","type","sub","sub2","team","defRed","dmgBonus","dmgInc","dmg","baseAmpBonus","frac","effectiveReaction","lookup","vaporize","melt","common","naught","all_dmg_","all_dmgInc","critHit","avgHit","res","allRegions","uiInput","forEachNodes","formulas","topDown","bottomUp","visiting","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","arrayEqual","a","b","every","allCommutativeMonoidOperations","reduce","mul","allOperations","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","f","flattened","dep","elementCounts","array","wrap","counts","next","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","v1","v2","match","unmatch","reset","nextContext","assertUnreachable","crystallizeMulti1","crystallizeLevelMultipliers","crystallizeElemas","crystallizeHit","transMulti1","transformativeReactionLevelMultipliers","transMulti2","trans","transformativeReactions","multi","variants","swirl","electroSwirl","pyroSwirl","cryoSwirl","hydroSwirl","shattered","crystallize","e","overloaded","electrocharged","superconduct","shouldWrap","valueString","fixed","Number","isInteger","abs","toFixed","parent","nodes","getAll","calculated","node","trace","isEmpty","dependencies","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","illformed","mayNeedWrapping","valueDisplay","prefixDisplay","sourceDisplay","createDisplay","readFirst","_accumulate","readAll","v1Node","v2Node","matchNode","unmatchNode","matching","emptyOn","makeEmpty","valueNode","thresholdNode","child","operand","unique","mergeVariants","identity","fStr","separator","strings","predisplay","string","item","itemFormula","createFormulaComponent","mergeFormulaComponents","components","emptyValue","MAX_VALUE","Infinity","defaultV","intoV","intoOps","equal","unequal","greaterEq","greaterEqStr","lessThan","nodeList","customStringRead","matchFull","useForceUpdate","stateDirty","update","usePromise","promise","setRes","useEffect","pending"],"sourceRoot":""}