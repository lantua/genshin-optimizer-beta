{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","PageBuild/background.ts","Types/consts.ts","PageBuild/common.ts","PageBuild/BackgroundWorker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","runtime","undefined","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","obj","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","from","test","_slicedToArray","isArray","_arr","_n","_d","_e","_s","_i","_toConsumableArray","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread2","target","arguments","source","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","allowArrayLike","it","F","e","f","normalCompletion","didErr","step","_e2","objPathValue","console","reduce","a","k","objectKeyMap","map","fromEntries","objectMap","entries","v","assertUnreachable","constant","NaN","percent","operation","operands","Number","MAX_VALUE","Infinity","min","intoOps","max","customRead","path","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","arrayEqual","set","b","every","allCommutativeMonoidOperations","x","Math","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","common","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","v1","v2","match","unmatch","list","accu","nextContext","id","builds","buildValues","plotData","allSlotKeys","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","_","nonConst","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","base","slot","offsets","baseValue","pruneOrder","numTop","keepArtifacts","progress","newList","art","other","greaterEqual","greater","some","pruneArtRange","minimum","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","pruneNodeRange","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","range","reads","_f","computeMinMax","sum","minMaxes","countBuilds","_count","shared","request","newThreshold","filters","preArts","kind","ids","sets","filterArts","totalCount","optimize","forced","should","deps","newArts","newNodes","pruneAll","maxBuilds","compute","binding","uniqueReadStrings","uniqueNumbers","mapping","ins","locations","readStrings","readOffset","constValues","computations","str","offset","ref","out","buff","buffer","number","copyList","src","copyFormula","dst","precompute","sort","build","failed","skipped","permute","stats","plot","artifactIds","newStats","interimReport","command","refresh","callback","buildCount","failedCount","skippedCount","force","plots","scale","round","size","mergePlot","onmessage","msg","postMessage","interim","optimizationTarget","plotBase"],"mappings":"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","file":"static/js/BackgroundWorker.357ffa2d.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/genshin-optimizer-beta/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj, keys, validate, cb) {\n  if (validate(obj)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map(t => map(t))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const unit = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\nexport function stringRead(): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/*\n * Deprecated\n */\n\n/**\n * value >= threshold ? value : emptyValue\n * @deprecated Use `greaterEq`, `lessEq`, or `greaterEqStr` instead\n */\nexport function threshold(value: Num, threshold: Num, pass: Str, fail: Str, info?: Info): StrNode\nexport function threshold(value: Num, threshold: Num, pass: Num, fail: Num, info?: Info): NumNode\nexport function threshold(value: Num, threshold: Num, pass: Num | Str, fail: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(value), intoV(threshold), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n/**\n * value >= threshold ? addition : 0\n * @deprecated Use `greaterEq` or `lessEq` instead\n */\nexport function threshold_add(value: Num, thres: Num, addition: Num, info?: Info): NumNode {\n  return threshold(value, thres, addition, 0, info)\n}\n\n/**\n * `v1` === `v2` ? `match` : 0\n * @deprecated Use `equal` instead\n */\nexport function match(v1: Str, v2: Str, match: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/**\n * `v1` === `v2` ? 0 : `unmatch`\n * @deprecated Use `unequal` instead\n */\nexport function unmatch(v1: Str, v2: Str, unmatch: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(unmatch)], info, emptyOn: \"match\" }\n}\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        if (!first)\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = fold(first, context)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined)\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined)\n          result = fold(operands[0], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { optimize, precompute } from '../Formula/optimization';\nimport type { NumNode } from '../Formula/type';\nimport type { MainStatKey, SubstatKey } from '../Types/artifact';\nimport { ArtifactSetKey, SlotKey } from '../Types/consts';\nimport { countBuilds, filterArts, mergePlot, pruneAll } from './common';\n\nlet id: string\nlet builds: Build[]\nlet buildValues: number[] | undefined\nlet plotData: PlotData | undefined\nlet threshold: number\n\ntype WorkerStat = {\n  arts: ArtifactsBySlot\n  nodes: NumNode[]\n\n  maxBuilds: number\n  min: number[]\n\n  callback: (interim: InterimResult) => void\n}\nlet shared: WorkerStat = undefined as any\n\nexport function setup(msg: Setup, callback: WorkerStat[\"callback\"]): RequestResult {\n  shared = { ...msg } as any\n  shared.nodes = msg.filters.map(x => x.value)\n  shared.min = msg.filters.map(x => x.min)\n  shared.callback = callback\n  shared.nodes.push(msg.optimizationTarget)\n  if (msg.plotBase) {\n    plotData = {}\n    shared.nodes.push(msg.plotBase)\n  }\n  id = msg.id\n  builds = []\n  buildValues = undefined\n  threshold = -Infinity\n\n  return { command: \"request\", id }\n}\n\nexport function request({ threshold: newThreshold, filter: filters }: Request): RequestResult & { total: number } {\n  if (threshold > newThreshold) threshold = newThreshold\n  let preArts = filterArts(shared.arts, filters)\n  const totalCount = countBuilds(preArts)\n\n  let nodes = optimize(shared.nodes, {}, _ => false);\n  ({ nodes, arts: preArts } = pruneAll(nodes, shared.min, preArts, shared.maxBuilds, new Set(), {\n    pruneArtRange: true, pruneNodeRange: true,\n  }))\n  const compute = precompute(nodes, f => f.path[1])\n  const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\n\n  const ids: string[] = Array(arts.length).fill(\"\")\n  let count = { build: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\n\n  function permute(i: number, stats: Stats) {\n    if (i < 0) {\n      const result = compute(stats)\n      if (shared.min.every((m, i) => (m <= result[i]))) {\n        const value = result[shared.min.length]\n        if (value >= threshold)\n          builds.push({ value, plot: result[shared.min.length + 1], artifactIds: [...ids] })\n        if (plotData) {\n          const x = result[shared.min.length + 1]\n          if (!plotData[x] || plotData[x]!.value < value)\n            plotData[x] = { value, artifactIds: [...ids] }\n        }\n      }\n      else count.failed += 1\n      return\n    }\n    arts[i].forEach(art => {\n      ids[i] = art.id\n\n      const newStats = { ...stats }\n      Object.entries(art.values).forEach(([key, value]) =>\n        newStats[key] = (newStats[key] ?? 0) + value)\n\n      permute(i - 1, newStats)\n    })\n    if (i === 0) {\n      count.build += arts[0].length\n      if (count.build > 8192)\n        interimReport(count)\n    }\n  }\n\n  permute(arts.length - 1, shared.arts.base)\n  interimReport(count)\n  return { command: \"request\", id, total: totalCount }\n}\nexport function finalize(): FinalizeResult {\n  refresh(true)\n  return { command: \"finalize\", id, builds, plotData }\n}\n\nexport let interimReport = (count: { build: number, failed: number, skipped: number }): void => {\n  refresh(false)\n  shared.callback({\n    command: \"interim\", id, buildValues,\n    buildCount: count.build, failedCount: count.failed, skippedCount: count.skipped\n  })\n  buildValues = undefined\n  count.build = 0\n  count.failed = 0\n  count.skipped = 0\n}\nfunction refresh(force: boolean): void {\n  if (plotData && Object.keys(plotData).length >= 100000)\n    plotData = mergePlot([plotData])\n\n  if (builds.length >= 100000 || force) {\n    builds = builds\n      .sort((a, b) => b.value - a.value)\n      .slice(0, shared.maxBuilds)\n    buildValues = builds.map(x => x.value)\n    threshold = Math.max(threshold, buildValues[shared.maxBuilds - 1] ?? -Infinity)\n  }\n}\n\ntype Stats = { [key in MainStatKey | SubstatKey]?: number }\nexport type ArtifactBuildData = {\n  id: string\n  set: ArtifactSetKey\n  values: DynStat\n}\n\nexport type Command = Setup | Request | Finalize\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\nexport type DynStat = { [key in string]: number }\nexport interface Setup {\n  command: \"setup\"\n\n  id: string\n  arts: ArtifactsBySlot\n\n  optimizationTarget: NumNode\n  filters: { value: NumNode, min: number }[]\n  plotBase: NumNode | undefined,\n  maxBuilds: number\n}\nexport interface Request {\n  command: \"request\"\n  threshold: number\n  filter: RequestFilter\n}\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport type PlotData = Dict<number, Build>\nexport interface Finalize {\n  command: \"finalize\"\n}\n\nexport type WorkerResult = InterimResult | RequestResult | FinalizeResult | DebugMsg\nexport interface InterimResult {\n  command: \"interim\"\n  id: string\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  buildCount: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failedCount: number\n  skippedCount: number\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  id: string\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface RequestResult {\n  command: \"request\"\n  id: string\n}\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\nexport interface DebugMsg {\n  command: \"debug\"\n  id: string\n  value: any\n}\n","// DO NOT REMOVE ITEMS FROM THESE LISTS\n//        ONLY APPEND NEW ENTRIES\n// The index of items in this list is used to\n// compress the exported data. Removing an item\n// from this list will shift subsequent entries.\nexport const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allReactionModes = [\"hydro_vaporize\", \"pyro_vaporize\", \"pyro_melt\", \"cryo_melt\",] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  // \"DefendersWill\",\n  \"Gambler\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  // \"Instructor\",\n  // \"Lavawalker\",\n  \"LuckyDog\",\n  // \"MaidenBeloved\",\n  // \"MartialArtist\",\n  \"NoblesseOblige\",\n  // \"PrayersForDestiny\",\n  // \"PrayersForIllumination\",\n  // \"PrayersForWisdom\",\n  // \"PrayersToSpringtime\",\n  // \"ResolutionOfSojourner\",\n  // \"RetracingBolide\",\n  // \"Scholar\",\n  // \"TheExile\",\n  // \"ThunderingFury\",\n  // \"Thundersoother\",\n  // \"TinyMiracle\",\n  // \"TravelingDoctor\",\n  \"ViridescentVenerer\",\n  // \"WanderersTroupe\",\n  // \"TenacityOfTheMillelith\",\n  // \"PaleFlame\",\n  \"EmblemOfSeveredFate\",\n  // \"ShimenawasReminiscence\",\n  \"HuskOfOpulentDreams\",\n  \"OceanHuedClam\"\n] as const\nexport const allCharacterKeys = [\n  // \"Albedo\",\n  // \"Amber\",\n  // \"Barbara\",\n  // \"Beidou\",\n  // \"Bennett\",\n  // \"Chongyun\",\n  // \"Diluc\",\n  // \"Diona\",\n  // \"Fischl\",\n  // \"Ganyu\",\n  // \"HuTao\",\n  // \"Jean\",\n  // \"Kaeya\",\n  // \"Keqing\",\n  // \"Klee\",\n  // \"Lisa\",\n  // \"Mona\",\n  // \"Ningguang\",\n  // \"Noelle\",\n  // \"Qiqi\",\n  // \"Razor\",\n  \"Sucrose\",\n  // \"Tartaglia\",\n  // \"Traveler\",\n  \"RaidenShogun\",\n  // \"Venti\",\n  // \"Xiao\",\n  // \"Xiangling\",\n  // \"Xingqiu\",\n  // \"Xinyan\",\n  // \"Zhongli\",\n  // \"Rosaria\",\n  // \"Yanfei\",\n  // \"Eula\",\n  \"KaedeharaKazuha\",\n  \"KamisatoAyaka\",\n  // \"Sayu\",\n  \"Shenhe\",\n  // \"Yoimiya\",\n  // \"KujouSara\",\n  // \"Aloy\",\n  // \"SangonomiyaKokomi\",\n  // \"Thoma\",\n  // \"Gorou\",\n  // \"AratakiItto\"\n  \"YaeMiko\"\n] as const\nexport const allWeaponKeys = [\n  \"CalamityQueller\",\n  \"DullBlade\",\n  // \"SilverSword\",\n  // \"CoolSteel\",\n  // \"DarkIronSword\",\n  // \"FilletBlade\",\n  // \"HarbingerOfDawn\",\n  // \"SkyriderSword\",\n  // \"TravelersHandySword\",\n  // \"BlackcliffLongsword\",\n  // \"FavoniusSword\",\n  // \"IronSting\",\n  // \"LionsRoar\",\n  // \"PrimordialJadeCutter\",\n  // \"PrototypeRancour\",\n  // \"RoyalLongsword\",\n  // \"SacrificialSword\",\n  // \"TheAlleyFlash\",\n  // \"TheBlackSword\",\n  // \"TheFlute\",\n  // \"SwordOfDescension\",\n  // \"FesteringDesire\",\n  // \"AquilaFavonia\",\n  // \"SkywardBlade\",\n  // \"SummitShaper\",\n  // \"WasterGreatsword\",\n  // \"OldMercsPal\",\n  // \"BloodtaintedGreatsword\",\n  // \"DebateClub\",\n  // \"FerrousShadow\",\n  // \"Akuoumaru\",\n  // \"SkyriderGreatsword\",\n  // \"WhiteIronGreatsword\",\n  // \"BlackcliffSlasher\",\n  // \"FavoniusGreatsword\",\n  // \"LithicBlade\",\n  // \"PrototypeArchaic\",\n  // \"Rainslasher\",\n  // \"RoyalGreatsword\",\n  // \"SerpentSpine\",\n  // \"TheBell\",\n  // \"Whiteblind\",\n  // \"SacrificialGreatsword\",\n  // \"SnowTombedStarsilver\",\n  // \"SkywardPride\",\n  // \"WolfsGravestone\",\n  // \"TheUnforged\",\n  \"BeginnersProtector\",\n  // \"IronPoint\",\n  \"BlackTassel\",\n  // \"Halberd\",\n  // \"WhiteTassel\",\n  \"BlackcliffPole\",\n  \"CrescentPike\",\n  // \"Deathmatch\",\n  // \"DragonsBane\",\n  // \"LithicSpear\",\n  // \"PrototypeStarglitter\",\n  // \"FavoniusLance\",\n  // \"RoyalSpear\",\n  // \"DragonspineSpear\",\n  // \"VortexVanquisher\",\n  // \"PrimordialJadeWingedSpear\",\n  // \"StaffOfHoma\",\n  // \"SkywardSpine\",\n  // \"HuntersBow\",\n  // \"SeasonedHuntersBow\",\n  // \"PolarStar\",\n  // \"Messenger\",\n  // \"RavenBow\",\n  // \"RecurveBow\",\n  // \"SharpshootersOath\",\n  // \"Slingshot\",\n  // \"TheStringless\",\n  // \"AlleyHunter\",\n  // \"BlackcliffWarbow\",\n  // \"CompoundBow\",\n  // \"FavoniusWarbow\",\n  // \"PrototypeCrescent\",\n  // \"RoyalBow\",\n  // \"Rust\",\n  // \"SacrificialBow\",\n  // \"TheViridescentHunt\",\n  // \"SkywardHarp\",\n  // \"AmosBow\",\n  // \"ElegyForTheEnd\",\n  // \"WindblumeOde\",\n  // \"ApprenticesNotes\",\n  // \"PocketGrimoire\",\n  \"EngulfingLightning\",\n  // \"EmeraldOrb\",\n  // \"MagicGuide\",\n  // \"OtherworldlyStory\",\n  // \"ThrillingTalesOfDragonSlayers\",\n  // \"TwinNephrite\",\n  // \"BlackcliffAgate\",\n  // \"FavoniusCodex\",\n  // \"MappaMare\",\n  // \"PrototypeAmber\",\n  // \"RoyalGrimoire\",\n  // \"SacrificialFragments\",\n  // \"SolarPearl\",\n  // \"TheWidsith\",\n  // \"WineAndSong\",\n  // \"EyeOfPerception\",\n  // \"Frostbearer\",\n  // \"LostPrayerToTheSacredWinds\",\n  // \"SkywardAtlas\",\n  // \"MemoryOfDust\",\n  // \"SongOfBrokenPines\",\n  // \"DodocoTales\",\n  // \"MitternachtsWaltz\",\n  \"FreedomSworn\",\n  // \"AmenomaKageuchi\",\n  // \"MistsplitterReforged\",\n  // \"KatsuragikiriNagamasa\",\n  // \"KitainCrossSpear\",\n  // \"ThunderingPulse\",\n  // \"Hamayumi\",\n  // \"HakushinRing\",\n  // \"TheCatch\",\n  \"EverlastingMoonglow\",\n  // \"LuxuriousSeaLord\",\n  // \"Predator\",\n  // \"MouunsMoon\",\n  // \"WavebreakersFin\",\n  // \"CinnabarSpindle\",\n  // \"RedhornStonethresher\",\n  \"KagurasVerity\"\n] as const\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type ReactionModeKey = typeof allReactionModes[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type WeaponKey = typeof allWeaponKeys[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\n","import { forEachNodes, mapFormulas } from \"../Formula/internal\";\nimport { allOperations, constantFold } from \"../Formula/optimization\";\nimport { ConstantNode, NumNode } from \"../Formula/type\";\nimport { constant, customRead, max, min } from \"../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey } from \"../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap } from \"../Util/Util\";\nimport type { ArtifactBuildData, ArtifactsBySlot, Build, DynStat, PlotData, RequestFilter } from \"./background\";\n\ntype DynMinMax = { [key in string]: MinMax }\ntype MinMax = { min: number, max: number }\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, keepArtifacts: Set<ArtifactSetKey>, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, keepArtifacts)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\n\n  function visit(node: NumNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(_op => {\n      const op = _op as NumNode\n      affineNodes.has(op) && topLevelAffine.add(op)\n    })\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const operation = f.operation\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\":\n        if (typeof f.value === \"string\" || f.value === undefined)\n          throw new Error(`Found constant ${f.value} while compacting`)\n        visit(f as NumNode, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\":\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\"))\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, keepArtifacts: Set<ArtifactSetKey>): ArtifactsBySlot {\n  let progress = false\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          (!keepArtifacts.has(art.set) || keepArtifacts.has(other.set)))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return constant(0)\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  arts.forEach(({ values }) => {\n    Object.entries(values).forEach(([key, value]) => {\n      if (result[key]) {\n        if (result[key].max < value) result[key].max = value\n        if (result[key].min > value) result[key].min = value\n      } else result[key] = { min: value, max: value }\n    })\n  })\n\n  return result\n}\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\n  const range = new Map<NumNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, _f => {\n    const f = _f as NumNode\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"subscript\": current = computeMinMax(f.list); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = computeMinMax([0])\n        else current = computeMinMax([0], [operands[2]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      case \"data\": case \"lookup\": case \"match\":\n        throw new Error(`Unsupported ${operation} node`)\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set))\n      }\n    })\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.value / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.value / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n","import { Command, setup, request, finalize } from \"./background\"\nimport { assertUnreachable } from '../Util/Util';\n\nonmessage = ({ data }: { data: Command }) => {\n  const command = data.command\n  switch (command) {\n    case \"setup\": postMessage(setup(data, interim => postMessage(interim, undefined))); break\n    case \"request\": postMessage(request(data)); break\n    case \"finalize\": postMessage(finalize()); break\n    default: assertUnreachable(command)\n  }\n}\n"],"sourceRoot":""}