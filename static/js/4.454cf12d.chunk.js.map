{"version":3,"sources":["Formula/index.ts","Components/Card/CardLight.tsx","Formula/utils.ts","ReactHooks/usePromise.tsx","Components/Card/CardDark.tsx","Components/Image/ImgIcon.tsx","Components/SqBadge.tsx","Components/DropdownMenu/DropdownButton.tsx","Data/Characters/CharacterSheet.tsx","Assets/icon_bow.png","Assets/Assets.ts","Assets/icon_catalyst.png","Assets/icon_claymore.png","Assets/icon_polearm.png","Assets/icon_sword.png","Assets/Item_Fragile_Resin.png","Assets/Item_Condensed_Resin.png","Assets/Item_Wanderer's_Advice.png","Assets/Item_Hero's_Wit.png","Assets/Item_Adventurer's_Experience.png","Data/Weapons/WeaponSheet.tsx","Components/StarDisplay.tsx","Formula/api.tsx","Components/StatIcon.tsx","Components/CloseButton.tsx","Formula/uiData.tsx","Components/ModalWrapper.tsx","Components/SolidToggleButtonGroup.tsx","ReactHooks/useForceUpdate.tsx","Components/ConditionalWrapper.tsx","Formula/reaction.ts","Formula/optimization.ts","Formula/internal.ts"],"names":["pivot","allElements","allElementsWithPhy","allTalents","allMoves","allArtModStats","allArtNonModStats","allTransformative","allAmplifying","allModStats","map","x","allNonModStats","allEleEnemyResKeys","talent","objectKeyMap","_","read","allModStatNodes","key","undefined","allNonModStatNodes","ele","info","variant","reaction","withDefaultInfo","value","deepClone","crawlObject","operation","accu","input","setReadNodeKeys","activeCharKey","stringRead","charKey","charEle","infusion","weaponType","lvl","prefix","constellation","asc","special","base","customBonus","bonus","premod","total","objectKeyValueMap","cappedCritRate","art","asConst","allSlotKeys","id","set","artSet","allArtifactSets","weapon","type","refinement","refineIndex","main","sub","sub2","team","enemy","def","level","defRed","defIgn","hit","move","hitMode","dmgBonus","dmgInc","dmg","stat","auto","skill","burst","atk","critRate_","baseAmpBonus","sum","unit","prod","frac","eleMas","effectiveReaction","lookup","pyro","vaporize","constant","melt","hydro","equalStr","cryo","common","operands","push","percent","filter","stamina","max","min","naught","all_dmg_","all_dmgInc","NaN","critHit","critDMG_","avgHit","enemyDefRed_","res","infoMut","target","tally","allRegions","uiInput","CardLight","styled","Card","backgroundColor","theme","palette","contentLight","Number","MAX_VALUE","Infinity","node","index","table","defaultV","intoV","values","intoOps","c","equal","v1","v2","pass","emptyOn","unequal","greaterEq","greaterEqStr","lessThan","nodeList","Error","path","Object","keys","data","resetData","reset","customRead","customStringRead","stringPrio","subscript","list","matchFull","match","unmatch","usePromise","promise","dependencies","useState","setRes","useEffect","pending","then","console","error","CardDark","contentDark","ImgIcon","name","slot","size","display","width","height","verticalAlign","SqBadge","color","padding","fontSize","fontWeight","lineHeight","textAlign","whiteSpace","borderRadius","contrastText","DropdownButton","title","children","props","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","fallback","endIcon","onClick","onClose","MenuListProps","characterSheets","imp","default","CharacterSheet","charSheet","sheet","isMelee","weaponTypeKey","getTalent","eleKey","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","sx","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","getLevelString","ascension","ascensionMaxLevel","talentTemplate","tr","img","fields","conditional","sections","text","talentStrMap","passive","passive1","passive2","passive3","sprint","constellation1","constellation2","constellation3","constellation4","constellation5","constellation6","conditionalHeader","icon","m","action","normalSrc","weaponKey","Assets","weaponTypes","bow","catalyst","claymore","polearm","sword","resin","fragile","condensed","exp_books","advice","wit","experience","weaponSheets","WeaponSheet","weaponSheet","weaponData","strKey","ns","key18","passiveDescription","iconAwaken","document","w","getWeaponsOfType","fromEntries","entries","imgAwaken","conditionaldesc","StarIcon","faStar","Stars","stars","colored","component","Array","i","inferInfoMut","source","slice","reference","objPathValue","dataObjForArtifact","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatValue","mainStatKey","Math","stats","substats","forEach","accurateValue","endsWith","slotKey","setKey","dataObjForCharacter","char","result","enemyOverride","enemyLevel","bonusStats","enemyDefIgn_","basic","reactions","layeredAssignment","dataObjForWeapon","teamBuff","uiDataForTeam","teamData","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","custom","newNode","sourceKey","sourceBuff","buff","calc","readNode","targetKey","assign","origin","UIData","length","internal","Set","flatMap","computeUIData","HPIcon","className","faHpPrimary","faHpSecondary","style","CdRedIcon","faCdReductionPrimary","faCdReductionSecondary","EnerRechIcon","faEnergyRechargePrimary","faEnergyRechargeSecondary","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","faHydro","faPyro","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","StatIcon","characterHP","finalHP","hp_","hp","baseATK","faAtk","characterATK","finalATK","atk_","characterDEF","faDef","finalDEF","def_","faElementalMastery","faCritRate","faDiceD20","enerRech_","heal_","faHealingBonus","cdRed_","shield_","faShieldStrength","faMaxStamina","CloseButton","large","t","useTranslation","startIcon","p","minWidth","shouldWrap","valueString","fixed","isFinite","isInteger","abs","toFixed","parent","Map","nodes","processed","getAll","calculated","trace","isEmpty","formulas","old","formula","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","first","find","illformed","assertUnreachable","mayNeedWrapping","valueDisplay","prefixDisplay","getPrefixStr","sourceDisplay","getNoUnit","createDisplay","readFirst","_accumulate","readAll","selected","v1Node","v2Node","matchNode","unmatchNode","matching","makeEmpty","valueNode","thresholdNode","fail","threshold","child","operand","unique","delete","next","mergeVariants","identity","allOperations","fStr","separator","every","strings","predisplay","string","item","array","itemFormula","createFormulaComponent","add","mergeFormulaComponents","components","emptyValue","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","dark","useForceUpdate","stateDirty","update","ConditionalWrapper","condition","wrapper","falseWrapper","crystalizeMulti1","crystalizeLevelMultipliers","crystalizeElemas","crystalizeHit","transMulti1","transformativeReactionLevelMultipliers","transMulti2","trans","transformativeReactions","multi","variants","swirl","swirl_dmg_","electroSwirl","pyroSwirl","cryoSwirl","hydroSwirl","shattered","overloaded","electrocharged","superconduct","allCommutativeMonoidOperations","reduce","a","b","mul","sum_frac","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","mapFormulas","f","has","flattened","dep","elementCounts","wrap","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","nextContextMap","fold","context","numericOperands","formulaOperands","folded","numericValue","op","nextContext","forEachNodes","topDown","bottomUp","visiting","visited","traverse","topDownMap","bottomUpMap","topDownMapped","bottomUpMapped","check","arrayEqual"],"mappings":"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","file":"static/js/4.454cf12d.chunk.js","sourcesContent":["import { allEleEnemyResKeys } from \"../KeyMap\"\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\nimport { constant, equalStr, frac, infoMut, lookup, max, min, naught, percent, prod, read, res, setReadNodeKeys, stringRead, sum, unit } from \"./utils\"\n\nconst asConst = true as const, pivot = true as const\n\nconst allElements = allElementsWithPhy\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\", \"elemental\"] as const\nconst allArtModStats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\"] as const\nconst allArtNonModStats = [\"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"heal_\"] as const\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\nconst allMisc = [\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\"\n] as const\n\nconst allModStats = [\n  ...allArtModStats,\n  ...([\"all\", \"burning\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\n]\nconst allNonModStats = [\n  ...allArtNonModStats,\n  ...([\"all\", ...allMoves] as const).map(x => `${x}_dmgInc` as const),\n  ...([...allElements] as const).map(x => `${x}_critDMG_` as const),\n  ...allElements.map(x => `${x}_res_` as const),\n  ...allMoves.map(x => `${x}_critRate_` as const),\n  ...allEleEnemyResKeys,\n  \"enemyDefRed_\" as const,\n  ...allMisc,\n]\n\nconst talent = objectKeyMap(allTalents, _ => read())\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\n\nfor (const ele of allElements) {\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_dmg_`].info!.variant = ele\n}\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\n  allModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\n}\n\nfunction withDefaultInfo<T>(info: Info, value: T): T {\n  value = deepClone(value)\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\n  return value\n}\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\n  })\n}\n\n/** All read nodes */\nconst input = setReadNodeKeys(deepClone({\n  activeCharKey: stringRead(),\n  charKey: stringRead(), charEle: stringRead(), infusion: stringRead(), weaponType: stringRead(),\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\n\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\n    ...allModStatNodes, ...allNonModStatNodes,\n  }),\n  bonus: { ...talent },\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\n    ...allModStatNodes, ...allNonModStatNodes,\n    /** Total Crit Rate capped to [0%, 100%] */\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\n  }),\n\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\n    ...objectKeyMap(allArtModStats, key => allModStatNodes[key]),\n    ...objectKeyMap(allArtNonModStats, key => allNonModStatNodes[key]),\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\n  }),\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\n\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\n    key: stringRead(), type: stringRead(),\n\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\n    main: read(), sub: read(), sub2: read(),\n  }),\n\n  team: { infusion: stringRead() },\n\n  enemy: {\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\n\n    level: read(undefined, { key: \"enemyLevel\" }),\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\n    defRed: read(undefined),\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\n  },\n\n  hit: {\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\n    base: read(\"add\", { key: \"base\" }),\n\n    dmgBonus: read(undefined, { key: \"dmg_\", pivot }),\n    dmgInc: read(undefined, { key: \"dmgInc\", pivot }),\n    dmg: read(),\n  },\n}))\n\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\n\n// Adjust `info` for printing\nmarkAccu('add', {\n  bonus, customBonus, premod, art,\n  total: objectKeyMap(allModStats, stat => total[stat]),\n})\nbonus.auto.info = { key: \"autoBoost\" }\nbonus.skill.info = { key: \"skillBoost\" }\nbonus.burst.info = { key: \"burstBoost\" }\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\ndelete total.critRate_.info!.pivot\ntotal.critRate_.info!.prefix = \"uncapped\"\n\n// Nodes that are not used anywhere else but `common` below\n\n/** Base Amplifying Bonus */\nconst baseAmpBonus = sum(unit, prod(25 / 9, frac(total.eleMas, 1400)))\n/** Effective reaction, taking into account the hit's element */\nexport const effectiveReaction = lookup(hit.ele, {\n  pyro: lookup(hit.reaction, { vaporize: constant(\"vaporize\"), melt: constant(\"melt\") }, undefined),\n  hydro: equalStr(hit.reaction, \"vaporize\", \"vaporize\"),\n  cryo: equalStr(hit.reaction, \"melt\", \"melt\"),\n}, undefined)\n\nconst common: Data = {\n  premod: {\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\n    ...objectKeyMap([...allModStats, ...allArtNonModStats] as const, key => {\n      const operands: NumNode[] = []\n      switch (key) {\n        case \"atk\": case \"def\": case \"hp\":\n          operands.push(prod(base[key], sum(unit, premod[`${key}_`])))\n          break\n        case \"critRate_\":\n          operands.push(percent(0.05, { key, prefix: \"default\" }),\n            lookup(hit.move, objectKeyMap(allMoves, move => customBonus[`${move}_critRate_`]), 0))\n          break\n        case \"critDMG_\":\n          operands.push(percent(0.5, { key, prefix: \"default\" }),\n            lookup(hit.ele, objectKeyMap(allElements, ele => customBonus[`${ele}_critDMG_`]), 0))\n          break\n        case \"enerRech_\":\n          operands.push(percent(1, { key, prefix: \"default\" }))\n          break\n      }\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\n    }),\n  },\n  total: {\n    ...objectKeyMap(allTalents, talent => premod[talent]),\n    ...objectKeyMap(allModStats, key => premod[key]),\n    ...objectKeyMap(allNonModStats, key => premod[key]),\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\n\n    cappedCritRate: max(min(total.critRate_, unit), naught),\n  },\n\n  hit: {\n    dmgBonus: sum(\n      total.all_dmg_,\n      lookup(effectiveReaction, objectKeyMap(allAmplifying, reaction => total[`${reaction}_dmg_`]), naught),\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\n    ),\n    dmgInc: sum(\n      total.all_dmgInc,\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\n    ),\n    dmg: prod(\n      sum(hit.base, hit.dmgInc),\n      sum(unit, hit.dmgBonus),\n      lookup(hit.hitMode, {\n        hit: unit,\n        critHit: sum(unit, total.critDMG_),\n        avgHit: sum(unit, prod(total.cappedCritRate, total.critDMG_)),\n      }, NaN),\n      enemy.def,\n      lookup(hit.ele,\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\n      lookup(effectiveReaction, {\n        melt: lookup(hit.ele, {\n          pyro: prod(2, baseAmpBonus),\n          cryo: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"melt_dmg_\" }),\n        vaporize: lookup(hit.ele, {\n          hydro: prod(2, baseAmpBonus),\n          pyro: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"vaporize_dmg_\" }),\n      }, 1),\n    ),\n  },\n\n  enemy: {\n    // TODO: shred cap of 90%\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(unit, prod(-1, enemy.defRed)), sum(unit, prod(-1, enemy.defIgn)))),\n    defRed: total.enemyDefRed_,\n    ...objectKeyValueMap(allElements, ele =>\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\n  },\n}\n\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\nconst tally = setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"])\n\n/**\n * List of `input` nodes, rearranged to conform to the needs of the\n * UI code. This is a separate list so that the evolution of the UIs\n * does not rely on the structure of `input`. So the UI code can rearrange\n * nodes as it sees fit without requiring updates to data sheets, which\n * pertains ~90% of all `input`-related code, and so are very sensitive\n * to any changes to `input`. For zero overhead, use the nodes directly\n * from `input` instead of a copy.\n */\nconst uiInput = input\n\nexport {\n  input, uiInput, common, customBonus,\n\n  target, tally,\n}\n","import { Card, styled } from \"@mui/material\";\n\nconst CardLight = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentLight.main\n}));\n\nexport default CardLight","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const unit = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\nexport function stringRead(): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/*\n * Deprecated\n */\n\n/**\n * value >= threshold ? value : emptyValue\n * @deprecated Use `greaterEq`, `lessEq`, or `greaterEqStr` instead\n */\nexport function threshold(value: Num, threshold: Num, pass: Str, fail: Str, info?: Info): StrNode\nexport function threshold(value: Num, threshold: Num, pass: Num, fail: Num, info?: Info): NumNode\nexport function threshold(value: Num, threshold: Num, pass: Num | Str, fail: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(value), intoV(threshold), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n/**\n * value >= threshold ? addition : 0\n * @deprecated Use `greaterEq` or `lessEq` instead\n */\nexport function threshold_add(value: Num, thres: Num, addition: Num, info?: Info): NumNode {\n  return threshold(value, thres, addition, 0, info)\n}\n\n/**\n * `v1` === `v2` ? `match` : 0\n * @deprecated Use `equal` instead\n */\nexport function match(v1: Str, v2: Str, match: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/**\n * `v1` === `v2` ? 0 : `unmatch`\n * @deprecated Use `unequal` instead\n */\nexport function unmatch(v1: Str, v2: Str, unmatch: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(unmatch)], info, emptyOn: \"match\" }\n}\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n","import { useEffect, useState } from \"react\";\n\nexport default function usePromise<T>(promise: Promise<T> | undefined, dependencies: any[]): T | undefined {\n  const [res, setRes] = useState<T | undefined>(undefined);\n  useEffect(() => {\n    let pending = true\n    promise?.then(res => pending && setRes(() => res), console.error) ?? setRes(undefined)\n    return () => {\n      pending = false\n      setRes(undefined)\n    }\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\n  return res\n}","import { Card, styled } from \"@mui/material\";\n\nconst CardDark = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentDark.main\n}));\n\nexport default CardDark","import { styled } from \"@mui/material\"\ninterface ImgIconProps {\n  size?: number;\n}\nconst ImgIcon = styled(\"img\", {\n  name: 'ImgIcon',\n  slot: 'Root',\n})<ImgIconProps>(({ size = 1 }) => ({\n  display: \"inline-block\",\n  width: \"auto\",\n  height: `${size * 1.2}em`,\n  verticalAlign: \"text-bottom\"\n}))\n\nexport default ImgIcon","import { styled } from \"@mui/material\";\n\nconst SqBadge = styled(\"span\", {\n  name: 'SqBadge',\n  slot: 'Root',\n})(({ theme, color = \"primary\" }) => ({\n  display: \"inline-block\",\n  padding: \".25em .4em\",\n  fontSize: \"75%\",\n  fontWeight: 700,\n  lineHeight: 1,\n  textAlign: \"center\",\n  whiteSpace: \"nowrap\",\n  verticalAlign: \"baseline\",\n  borderRadius: \".25em\",\n  backgroundColor: theme.palette[color]?.main,\n  color: theme.palette[color]?.contrastText\n}))\nexport default SqBadge","import { KeyboardArrowDown } from \"@mui/icons-material\";\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\nimport { Suspense, useCallback, useState } from \"react\";\n\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\n  title: React.ReactNode,\n  id?: string,\n  children: React.ReactNode\n}\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n  const open = Boolean(anchorEl);\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\n    [setAnchorEl],\n  )\n  const handleClose = useCallback(\n    () => setAnchorEl(null),\n    [setAnchorEl],\n  )\n\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\n    <Button\n      {...props}\n      id={id}\n      aria-controls=\"basic-menu\"\n      aria-haspopup=\"true\"\n      aria-expanded={open ? 'true' : undefined}\n      onClick={handleClick}\n      endIcon={<KeyboardArrowDown />}\n    >\n      {title}\n    </Button>\n    <Menu\n      id=\"basic-menu\"\n      anchorEl={anchorEl}\n      open={open}\n      onClose={handleClose}\n      MenuListProps={{\n        'aria-labelledby': id,\n      }}\n      onClick={handleClose}\n    >\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\n        {children}\n      </Suspense>\n    </Menu>\n  </Suspense>\n}","import ImgIcon from \"../../Components/Image/ImgIcon\";\nimport { ascensionMaxLevel } from \"../LevelData\";\nimport { Data } from \"../../Formula/type\";\nimport { TalentSheet, TalentSheetElement, TalentSheetElementKey } from \"../../Types/character_WR\";\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\nimport SqBadge from \"../../Components/SqBadge\";\nimport Assets from \"../../Assets/Assets\";\nimport IConditional from \"../../Types/IConditional_WR\";\nimport { IFieldDisplay } from \"../../Types/IFieldDisplay_WR\";\n\nconst characterSheets = import('.').then(imp => imp.default)\n\ninterface ICharacterSheetBase {\n  name: Displayable\n  cardImg: string\n  thumbImg: string\n  thumbImgSide: string\n  barImg?: string\n  bannerImg?: string\n  rarity: Rarity\n  weaponTypeKey: WeaponTypeKey\n  gender: string\n  constellationName: Displayable\n  title: Displayable\n}\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\n  elementKey: ElementKey\n  talent: TalentSheet\n}\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\n  talents: Dict<ElementKey, TalentSheet>\n}\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\n\nexport default class CharacterSheet {\n  sheet: ICharacterSheet;\n  data: Data;\n  constructor(charSheet: ICharacterSheet, data: Data) {\n    this.sheet = charSheet\n    this.data = data\n  }\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\n  static get getAll() { return characterSheets }\n  get name() { return this.sheet.name }\n  get nameWIthIcon() { return <span><ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> {this.name}</span> }\n  get cardImg() { return this.sheet.cardImg }\n  get thumbImg() { return this.sheet.thumbImg }\n  get thumbImgSide() { return this.sheet.thumbImgSide }\n  get bannerImg() { return this.sheet.bannerImg }\n  get rarity() { return this.sheet.rarity }\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\n  get constellationName() { return this.sheet.constellationName }\n\n  isMelee = () => {\n    const weaponTypeKey = this.sheet.weaponTypeKey\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\n  }\n  get isTraveler() {\n    return \"talents\" in this.sheet\n  }\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\n    if (\"talent\" in this.sheet) return this.sheet.talent\n    else return this.sheet.talents[eleKey]\n  }\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\n\n  static getLevelString = (level: number, ascension: number): string =>\n    `${level}/${ascensionMaxLevel[ascension]}`\n}\n\nexport const talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, fields?: IFieldDisplay[], conditional?: IConditional): TalentSheetElement => ({\n  name: tr(`${talentKey}.name`),\n  img,\n  sections: [{\n    text: tr(`${talentKey}.description`),\n    fields,\n    conditional,\n  }],\n})\n\nconst talentStrMap: Record<TalentSheetElementKey, string> = {\n  auto: \"Auto\",\n  skill: \"Skill\",\n  burst: \"Burst\",\n  passive: \"Passive\",\n  passive1: \"Ascension 1\",\n  passive2: \"Ascension 4\",\n  passive3: \"Passive\",\n  sprint: \"Sprint\",\n  constellation1: \"C1\",\n  constellation2: \"C2\",\n  constellation3: \"C3\",\n  constellation4: \"C4\",\n  constellation5: \"C5\",\n  constellation6: \"C6\"\n}\nexport const conditionalHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IConditional[\"header\"] => {\n  return {\n    title: tr(`${talentKey}.name`),\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\n    action: <SqBadge color=\"success\">{talentStrMap[talentKey]}</SqBadge>,\n  }\n}\n\nexport const normalSrc = (weaponKey: WeaponTypeKey) => Assets.weaponTypes[weaponKey]\n","export default __webpack_public_path__ + \"static/media/icon_bow.7ceaa8e2.png\";","import bow from './icon_bow.png'\nimport catalyst from './icon_catalyst.png'\nimport claymore from './icon_claymore.png'\nimport polearm from './icon_polearm.png'\nimport sword from './icon_sword.png'\n\nimport fragile from './Item_Fragile_Resin.png'\nimport condensed from './Item_Condensed_Resin.png'\n\n//EXP BOOKS\nimport advice from './Item_Wanderer\\'s_Advice.png'\nimport wit from './Item_Hero\\'s_Wit.png'\nimport experience from './Item_Adventurer\\'s_Experience.png'\n\nconst Assets = {\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\n  resin: {\n    fragile,\n    condensed\n  },\n  exp_books: {\n    advice,\n    wit,\n    experience,\n  }\n};\nexport default Assets;","export default __webpack_public_path__ + \"static/media/icon_catalyst.db078b7b.png\";","export default __webpack_public_path__ + \"static/media/icon_claymore.63b1abb8.png\";","export default __webpack_public_path__ + \"static/media/icon_polearm.e5f4a2a1.png\";","export default __webpack_public_path__ + \"static/media/icon_sword.619c9c2d.png\";","export default __webpack_public_path__ + \"static/media/Item_Fragile_Resin.f9ec8223.png\";","export default __webpack_public_path__ + \"static/media/Item_Condensed_Resin.1cecf64a.png\";","export default __webpack_public_path__ + \"static/media/Item_Wanderer's_Advice.58c62cf7.png\";","export default __webpack_public_path__ + \"static/media/Item_Hero's_Wit.a79e36d0.png\";","export default __webpack_public_path__ + \"static/media/Item_Adventurer's_Experience.92b5d195.png\";","import { Translate } from '../../Components/Translate';\nimport { Data } from '../../Formula/type';\nimport { Rarity, WeaponKey, WeaponTypeKey } from '../../Types/consts';\nimport { DocumentSection } from '../../Types/sheet';\nimport { ICachedWeapon } from '../../Types/weapon_WR';\nimport { ascensionMaxLevel } from '../LevelData';\nimport type { WeaponData } from 'pipeline';\nimport IConditional from '../../Types/IConditional_WR';\nimport ImgIcon from '../../Components/Image/ImgIcon';\nimport { input } from '../../Formula';\nconst weaponSheets = import('.').then(imp => imp.default)\n\nexport interface IWeaponSheet {\n  icon: string,\n  iconAwaken: string,\n  document: DocumentSection[],\n}\n\nexport default class WeaponSheet {\n  readonly key: WeaponKey;\n  readonly sheet: IWeaponSheet;\n  readonly data: Data;\n  readonly rarity: Rarity;\n  readonly weaponType: WeaponTypeKey;\n  constructor(key: WeaponKey, weaponSheet: IWeaponSheet, weaponData: WeaponData, data: Data) {\n    this.rarity = weaponData.rarity\n    this.weaponType = weaponData.weaponType\n    this.key = key\n    this.sheet = weaponSheet\n    this.data = data\n  }\n  static get = (weaponKey: WeaponKey | \"\"): Promise<WeaponSheet> | undefined => weaponKey ? weaponSheets.then(w => w[weaponKey]) : undefined\n  static get getAll() { return weaponSheets }\n  static getWeaponsOfType = (sheets: StrictDict<WeaponKey, WeaponSheet>, weaponType: string): Dict<WeaponKey, WeaponSheet> => Object.fromEntries(Object.entries(sheets).filter(([key, sheet]) => (sheet as WeaponSheet).weaponType === weaponType))\n  static getLevelString = (weapon: ICachedWeapon): string => `${weapon.level}/${ascensionMaxLevel[weapon.ascension]}`\n  tr = (strKey: string) => <Translate ns={`weapon_${this.key}_gen`} key18={strKey} />\n  get name() { return this.tr(\"name\") }\n  //when there is no substat, assume there is no passive.\n  get passiveName() { return this.rarity > 2 ? this.tr(\"passiveName\") : \"\" }\n  get description() { return this.tr(\"description\") }\n  passiveDescription = (refineIndex: number) => this.rarity > 2 ? this.tr(`passiveDescription.${refineIndex}`) : \"\"\n  get img() { return this.sheet.icon }\n  get imgAwaken() { return this.sheet.iconAwaken }\n  get document() { return this.sheet.document }\n}\nexport const conditionalHeader = (tr: (string) => Displayable, img: string, imgAwaken: string): IConditional[\"header\"] => ({\n  title: tr(`passiveName`),\n  icon: data => <ImgIcon size={2} sx={{ m: -1 }} src={data.get(input.weapon.asc).value < 2 ? img : imgAwaken} />,\n})\n\nexport const conditionaldesc = (tr: (string) => Displayable) =>\n  data => tr(`passiveDescription.${data.get(input.weapon.refineIndex).value}`)\n","import { faStar } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Typography } from '@mui/material'\nimport { Rarity } from '../Types/consts'\n\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\n  </Typography>\n\nexport {\n  StarIcon,\n  Stars\n}\n","import Artifact from \"../Data/Artifacts/Artifact\";\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\nimport { ICachedCharacter } from \"../Types/character_WR\";\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\nimport { ICachedWeapon } from \"../Types/weapon\";\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { reactions } from \"./reaction\";\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\nimport { NodeDisplay, UIData, valueString } from \"./uiData\";\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\n\nconst asConst = true as const, pivot = true as const\n\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\n    if (path[0] === \"teamBuff\") path = path.slice(1)\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\n    if (reference)\n      x.info = { ...reference.info, prefix: undefined, source }\n    else if (path[0] !== \"tally\")\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\n  })\n\n  return data\n}\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\n  stats.push([art.mainStatKey, mainStatVal])\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\n  return {\n    art: {\n      ...Object.fromEntries(stats.map(([key, value]) =>\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\n      [art.slotKey]: {\n        id: constant(art.id), set: constant(art.setKey)\n      },\n    },\n    artSet: {\n      [art.setKey]: constant(1)\n    }\n  }\n}\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\n  const result: Data = {\n    lvl: constant(char.level),\n    constellation: constant(char.constellation),\n    asc: constant(char.ascension),\n\n    premod: {\n      auto: constant(char.talent.auto),\n      skill: constant(char.talent.skill),\n      burst: constant(char.talent.burst),\n    },\n    enemy: {\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\n    },\n    hit: {\n      hitMode: constant(char.hitMode)\n    },\n    customBonus: {},\n  }\n\n  for (const [key, value] of Object.entries(char.bonusStats))\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\n\n  if (char.enemyOverride.enemyDefRed_)\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_)\n  if (char.enemyOverride.enemyDefIgn_)\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_)\n  if (char.elementKey) {\n    result.charEle = constant(char.elementKey)\n    result.display = {\n      basic: { [`${char.elementKey}_dmg_`]: input.total[`${char.elementKey}_dmg_`] },\n      reaction: reactions[char.elementKey]\n    }\n    layeredAssignment(result, [\"teamBuff\", \"tally\", char.elementKey], constant(1))\n  }\n\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\n    layeredAssignment(result, keys, constant(x)))\n  return result\n}\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\n  return {\n    weapon: {\n      lvl: constant(weapon.level),\n      asc: constant(weapon.ascension),\n      refinement: constant(weapon.refinement),\n      refineIndex: constant(weapon.refinement - 1)\n    },\n  }\n}\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\n  // May the goddess of wisdom bless any and all souls courageous\n  // enough to attempt for the understanding of this abomination.\n\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\n  const result = Object.fromEntries(mergedData.map(([key]) =>\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\n\n  const customReadNodes = {}\n  function getReadNode(path: readonly string[]): ReadNode<number> {\n    const base = (path[0] === \"teamBuff\")\n      ? objPathValue(teamBuff, path.slice(1))\n      : objPathValue(input, path)\n    if (base) return base\n    const custom = objPathValue(customReadNodes, path)\n    if (custom) return custom\n    const newNode = customRead(path)\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\n    layeredAssignment(customReadNodes, path, newNode)\n    return newNode\n  }\n\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\n    mergedData.forEach(([sourceKey, source]) => {\n      const sourceBuff = source.teamBuff\n      // Create new copy of `calc` as we're mutating it later\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\n      buffs.push(buff)\n      calcs[sourceKey] = calc\n\n      // This construction creates a `Data` representing buff\n      // from `source` applying to `target`. It has 3 data:\n      // - `target` contains the reference for the final\n      //   data. It is not populated at this stage,\n      // - `calc` contains the calculation of the buffs,\n      // - `buff` contains read nodes that point to the\n      //   calculation in `calc`.\n\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\n\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\n\n          let readNode: ReadNode<number | string> | undefined, data: Data\n          if (x.path[0] === \"target\") { // Link the node to target data\n            readNode = getReadNode(x.path.slice(1))\n            data = targetRef\n          } else { // Link the node to source data\n            readNode = x\n            data = result[sourceKey].targetRef\n          }\n          layeredAssignment(calc, x.path, resetData(readNode, data))\n        })\n      })\n    })\n  )\n  mergedData.forEach(([targetKey, data]) => {\n    delete data.teamBuff\n    const { targetRef, buffs } = result[targetKey]\n    const buff = mergeData(buffs)\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\n      // CAUTION\n      // This is safe only because `buff` is created using only `resetData`\n      // and `mergeData`. So every node here is created from either of the\n      // two functions, so the mutation wont't affect existing nodes.\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\n    })\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\n    targetRef[\"target\"] = targetRef\n  })\n  const origin = new UIData(undefined as any, undefined)\n  const uiDataResult = Object.fromEntries(Object.entries(result).map(([key, value]) =>\n    [key, {\n      target: new UIData(value.targetRef, origin),\n      buff: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\n        [key, new UIData(value, origin)]))\n    }]))\n  return uiDataResult\n}\nfunction mergeData(data: Data[]): Data {\n  function internal(data: any[], path: string[]): any {\n    if (data.length <= 1) return data[0]\n    if (data[0].operation) {\n      if (path[0] === \"teamBuff\") path = path.slice(1)\n      const accu = path[0] === \"tally\"\n        ? \"add\" : (objPathValue(input, path) as ReadNode<number> | undefined)?.accu\n      if (accu === undefined) {\n        if (data.length !== 1)\n          throw new Error(`Multiple entries when merging \\`unique\\` for key ${path}`)\n        return data[0]\n      }\n      const result: NumNode = { operation: accu, operands: data }\n      return result\n    } else {\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\n    }\n  }\n  return data.length ? internal(data, []) : {}\n}\n\nfunction computeUIData(data: Data[]): UIData {\n  return new UIData(mergeData(data), undefined)\n}\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\n}\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\n}\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\n  if (data1?.operation || data2?.operation) {\n    const d1 = data1 as NodeDisplay | undefined\n    const d2 = data2 as NodeDisplay | undefined\n\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\n      throw new Error(\"Unmatched structure when comparing UIData\")\n\n    const result: ComparedNodeDisplay = {\n      operation: true,\n      value: 0,\n      isEmpty: true,\n      unit: d2?.unit!,\n      formulas: [],\n      ...d1,\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\n    }\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\n      // In case `string` got involved, just use the other value\n      result.value = d1?.value ?? \"\" as any\n      result.diff = d2?.value ?? \"\" as any\n    }\n    return result\n  }\n\n  if (data1 || data2) {\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\n  }\n}\n\nexport type { NodeDisplay, UIData };\nexport {\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\n  mergeData, computeUIData, valueString, inferInfoMut,\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\n};\n","import { faDiceD20 } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faAnemo, faAtk, faCdReductionPrimary, faCdReductionSecondary, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRechargePrimary, faEnergyRechargeSecondary, faGeo, faHealingBonus, faHpPrimary, faHpSecondary, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\nimport { objectKeyMap } from '../Util/Util'\nimport ColorText from './ColoredText'\n\nexport function HPIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faHpPrimary as any} />\n    <FontAwesomeIcon icon={faHpSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function CdRedIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faCdReductionPrimary as any} />\n    <FontAwesomeIcon icon={faCdReductionSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function EnerRechIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faEnergyRechargePrimary as any} />\n    <FontAwesomeIcon icon={faEnergyRechargeSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\nexport const uncoloredEleIcons = {\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\n} as const\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} >{uncoloredEleIcons[key]}</ColorText>)\n\nconst StatIcon = {\n  characterHP: <HPIcon />,\n  finalHP: <HPIcon />,\n  hp_: <HPIcon />,\n  hp: <HPIcon />,\n\n  baseATK: <FontAwesomeIcon icon={faAtk as any} />,\n  characterATK: <FontAwesomeIcon icon={faAtk as any} />,\n  finalATK: <FontAwesomeIcon icon={faAtk as any} />,\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\n\n  characterDEF: <FontAwesomeIcon icon={faDef as any} />,\n  finalDEF: <FontAwesomeIcon icon={faDef as any} />,\n  def_: <FontAwesomeIcon icon={faDef as any} />,\n  def: <FontAwesomeIcon icon={faDef as any} />,\n\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\n  critDMG_: <FontAwesomeIcon icon={faDiceD20 as any} />,\n  enerRech_: <EnerRechIcon />,\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\n\n  cdRed_: <CdRedIcon />,\n\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\n\n  ...coloredEleIcon,\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [[`${ele}_dmg_`, coloredEleIcon[ele]], [`${ele}_res_`, coloredEleIcon[ele]]]))\n}\n\nexport default StatIcon\n","import { Close } from \"@mui/icons-material\";\nimport { Button, ButtonProps } from \"@mui/material\";\nimport { useTranslation } from \"react-i18next\";\ntype CloseButtonProps = ButtonProps & {\n  large?: boolean\n}\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\n  const { t } = useTranslation(\"ui\")\n  if (large)\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\n    <Close />\n  </Button>\n}","import { uiInput } from \".\"\nimport ColorText from \"../Components/ColoredText\"\nimport KeyMap, { KeyMapPrefix, Unit } from \"../KeyMap\"\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\nimport { allOperations } from \"./optimization\"\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\n\nconst shouldWrap = true\n\nexport function valueString(value: number, unit: Unit, fixed = -1): string {\n  if (!isFinite(value)) {\n    if (value > 0) return `\\u221E`\n    if (value < 0) return `-\\u221E`\n    return 'NaN'\n  }\n  if (unit === \"%\") value *= 100\n  else unit = '' as any\n  if (Number.isInteger(value)) fixed = 0\n  else if (fixed === -1) {\n    if (unit === \"%\") fixed = 1\n    else fixed = Math.abs(value) < 10 ? 3 : Math.abs(value) < 1000 ? 2 : Math.abs(value) < 10000 ? 1 : 0\n  }\n  return `${value.toFixed(fixed)}${unit}`\n}\nexport interface NodeDisplay<V = number> {\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\n  operation: true\n  prefix?: KeyMapPrefix\n  key?: string\n  value: V\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\n  isEmpty: boolean\n  unit: Unit\n  variant?: Variant\n  formula?: Displayable\n  formulas: Displayable[]\n}\n\nexport class UIData {\n  origin: UIData\n  children = new Map<Data, UIData>()\n\n  data: Data[]\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\n\n  display: any = undefined\n  teamBuff: any = undefined\n\n  constructor(data: Data, parent: UIData | undefined) {\n    if (data === undefined) {\n      // Secret *origin* initializer\n      this.data = []\n      this.origin = this\n    } else {\n      if (!parent)\n        parent = new UIData(undefined as any, undefined)\n\n      this.data = [data, ...parent.data]\n      this.origin = parent.origin\n    }\n  }\n\n  getDisplay(): {\n    [key: string]: DisplaySub<NodeDisplay>\n  } {\n    if (!this.display) this.display = this.getAll([\"display\"])\n    return this.display\n  }\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\n    if (!this.teamBuff) {\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\n      // Convert `input` to `uiInput`\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\n        if (node) layeredAssignment(result, path, node)\n      })\n      this.teamBuff = result\n    }\n    return this.teamBuff\n  }\n  getAll(prefix: string[]): any {\n    const result = {}\n    for (const data of this.data) {\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\n    }\n    return result\n  }\n  get(node: NumNode): NodeDisplay\n  get(node: StrNode): NodeDisplay<string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\n    if (node === undefined) {\n      console.trace(\"Please report this bug with this trace\")\n      return { operation: true, value: undefined, isEmpty: true, unit: \"flat\", formulas: [] }\n    }\n    const old = this.processed.get(node)\n    if (old) return old\n\n    const result = computeNodeDisplay(this.computeNode(node))\n    this.processed.set(node, result)\n    return result\n  }\n  private computeNode(node: NumNode): ContextNodeDisplay\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\n    const old = this.nodes.get(node)\n    if (old) return old\n\n    const { operation, info } = node\n    let result: ContextNodeDisplay<number | string | undefined>\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        result = this._compute(node); break\n      case \"threshold\": result = this._threshold(node); break\n      case \"const\": result = this._constant(node.value); break\n      case \"subscript\": result = this._subscript(node); break\n      case \"read\": result = this._read(node); break\n      case \"data\": result = this._data(node); break\n      case \"match\": result = this._match(node); break\n      case \"lookup\": result = this._lookup(node); break\n      case \"prio\": {\n        const first = node.operands.find(x => this.computeNode(x).value !== undefined)\n        if (first) result = this.computeNode(first)\n        else result = illformed\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n\n    if (info) {\n      const { key, prefix, source, variant, asConst } = info\n      let { pivot } = info\n      result = { ...result }\n\n      // Pivot all keyed nodes for debugging\n      // if (key) pivot = true\n\n      if (key) result.key = key\n      if (prefix) result.prefix = prefix\n      if (source) result.source = source\n      if (variant) result.variant = variant\n      if (pivot) result.pivot = pivot\n\n      if (asConst) {\n        delete result.formula\n        delete result.assignment\n        result.dependencies = new Set()\n      }\n      if (result.pivot || !result.formula)\n        result.mayNeedWrapping = false\n    }\n    createDisplay(result)\n\n    this.nodes.set(node, result)\n    return result\n  }\n\n  private readAll(path: readonly string[]): ContextNodeDisplay<number | string | undefined>[] {\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x).map(x => this.computeNode(x))\n  }\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\n    return data && this.computeNode(data)\n  }\n\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\n    const { path } = node\n    const result = (node.accu === undefined)\n      ? this.readFirst(path) ?? (node.type === \"string\" ? this._constant(undefined) : illformed)\n      : this._accumulate(node.accu, this.readAll(path) as ContextNodeDisplay[])\n    return result\n  }\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const key = this.computeNode(node.operands[0]).value\n    const selected = node.table[key!] ?? node.operands[1]\n    if (!selected)\n      throw new Error(`Lookup Fail with key ${key}`)\n    return this.computeNode(selected)\n  }\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\n    const matching = v1.value === v2.value\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\n      ? makeEmpty(result.value) : result\n  }\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const [valueNode, thresholdNode, pass, fail] = node.operands\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\n    return (value.value >= threshold.value)\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\n  }\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    let child = this.children.get(node.data)\n    if (!child) {\n      child = new UIData(node.data, node.reset ? this.origin : this)\n      this.children.set(node.data, child)\n    }\n    return child.computeNode(node.operands[0])\n  }\n  private _compute(node: ComputeNode): ContextNodeDisplay {\n    const { operation, operands } = node\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\n  }\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\n    const operand = this.computeNode(node.operands[0])\n    const value = node.list[operand.value] ?? NaN\n    return this._constant(value)\n  }\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\n    return {\n      value, pivot: false,\n      empty: false,\n      mayNeedWrapping: false,\n      dependencies: new Set(),\n    }\n  }\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\n    let variant: Variant | undefined\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        variant = mergeVariants(operands); break\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n        const identity = allOperations[operation]([])\n        if (process.env.NODE_ENV !== \"development\")\n          operands = operands.filter(operand => operand.value !== identity)\n        if (!operands.length)\n          return variant ? { ...this._constant(identity), variant } : this._constant(identity)\n    }\n\n    let formula: { display: Displayable, dependencies: Displayable[] }\n    let mayNeedWrapping = false\n    switch (operation) {\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap }}`; break\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\n      case \"res\": {\n        const base = operands[0].value\n        if (base < 0) {\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\n          mayNeedWrapping = true\n        }\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\n        else {\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\n          mayNeedWrapping = true\n        }\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\":\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\n        else if (operation === \"add\") mayNeedWrapping = true\n    }\n\n    const value = allOperations[operation](operands.map(x => x.value))\n    const dependencies = new Set([...operands.flatMap(x =>\n      x.pivot && x.assignment\n        ? [x.assignment, ...x.dependencies]\n        : [...x.dependencies])])\n    const result: ContextNodeDisplay = {\n      formula: formula.display,\n      empty: operands.every(x => x.empty),\n      value, mayNeedWrapping,\n      pivot: false, dependencies,\n    }\n    if (variant) result.variant = variant\n    return result\n  }\n}\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\n  const dependencies = new Set<Displayable>()\n  const predisplay: Displayable[] = []\n\n  strings.forEach((string, i) => {\n    predisplay.push(string)\n\n    const key = list[i]\n    if (key) {\n      const { operands, shouldWrap, separator = \", \" } = key\n      operands.forEach((item, i, array) => {\n        let itemFormula: Displayable\n        if (!item.pivot && item.formula) itemFormula = item.formula\n        else itemFormula = createFormulaComponent(item)\n\n        if (shouldWrap && item.mayNeedWrapping) {\n          predisplay.push(\"( \")\n          predisplay.push(itemFormula)\n          predisplay.push(\" )\")\n        } else {\n          predisplay.push(itemFormula)\n        }\n        if (i + 1 < array.length) predisplay.push(separator)\n        item.dependencies.forEach(x => dependencies.add(x))\n      })\n    }\n  })\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\n}\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): ContextNodeDisplay<V>[\"variant\"] {\n  const unique = new Set(operands.map(x => x.variant))\n  if (unique.size > 1) unique.delete(undefined)\n  if (unique.size > 1) unique.delete(\"physical\")\n  return unique.values().next().value\n}\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\n  const { key, prefix, dependencies, value, variant, formula, assignment, empty } = node\n  return {\n    operation: true,\n    key, value, variant, prefix,\n    isEmpty: empty,\n    unit: (key && KeyMap.unit(key)) || \"flat\",\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\n  }\n}\n\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, key ? KeyMap.unit(key) : \"flat\")}</ColorText>\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.getNoUnit(key!)}</ColorText>{sourceDisplay}</>\n\n    if (formula)\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  //TODO: change formula size in the formula display element instead\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\n}\n/*/\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = valueString(value, key ? KeyMap.unit(key) : \"flat\")\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? ` ${source}` : \"\"\n    node.name = `${prefixDisplay}${KeyMap.getNoUnit(key!)}${sourceDisplay}`\n\n    if (formula)\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return (components as string[]).join(\"\")\n}\n//*/\n\ninterface ContextNodeDisplay<V = number> {\n  key?: Info[\"key\"]\n  prefix?: Info[\"prefix\"]\n  source?: Info[\"source\"]\n  variant?: Info[\"variant\"]\n\n  pivot: boolean\n  empty: boolean\n\n  value: V\n\n  dependencies: Set<Displayable>\n\n  mayNeedWrapping: boolean\n\n  // Don't set these manually outside of `UIData.computeNode`\n  name?: Displayable\n  valueDisplay?: Displayable\n  formula?: Displayable\n  assignment?: Displayable\n}\n\nconst illformed: ContextNodeDisplay = {\n  value: NaN, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\n  return {\n    value: emptyValue, pivot: false, empty: true, dependencies: new Set(), mayNeedWrapping: false\n  }\n}\n","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\nimport { Suspense } from \"react\"\nimport CardLight from \"./Card/CardLight\"\n\nconst ScrollModal = styled(Modal)(({ theme }) => ({\n  overflow: \"scroll\",\n  paddingTop: theme.spacing(2),\n  paddingBottom: theme.spacing(2),\n\n}))\nconst ModalContainer = styled(Container)(({ theme }) => ({\n  padding: 0,\n  minHeight: \"100%\",\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"auto\"\n  }\n}))\n\ntype ModalWrapperProps = ModalProps & {\n  containerProps?: ContainerProps\n}\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\n  return <ScrollModal {...props}>\n    <ModalContainer {...containerProps}>\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\n        {children}\n      </Suspense>\n    </ModalContainer>\n  </ScrollModal>\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\n\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\ntype SolidToggleButtonGroupPropsPartial = {\n  baseColor?: ButtonProps[\"color\"];\n  selectedColor?: ButtonProps[\"color\"];\n}\n\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"primary\", selectedColor = \"success\" }) => ({\n  '& .MuiToggleButtonGroup-grouped': {\n    '&': {\n      backgroundColor: theme.palette[baseColor].main,\n      color: theme.palette[baseColor].contrastText,\n    },\n    '&:hover': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected': {\n      backgroundColor: theme.palette[selectedColor].main,\n      color: theme.palette[selectedColor].contrastText,\n    },\n    '&.Mui-selected:hover': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n    '&.Mui-disabled': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected.Mui-disabled': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n  },\n}));\n\nexport default SolidToggleButtonGroup","import { useCallback, useState } from \"react\"\n\nexport default function useForceUpdate(): [object, () => void] {\n  const [stateDirty, update] = useState({})\n  const forceUpdateHook = useCallback(() => update({}), [])\n  return [stateDirty, forceUpdateHook]\n}","import { ReactNode } from \"react\";\n\ntype Prop = {\n  condition: boolean,\n  wrapper: (children: ReactNode) => ReactNode\n  falseWrapper?: (children: ReactNode) => ReactNode\n  children: ReactNode\n}\n// Wrap children with element provided by wrapper func when condition is true.\nexport default function ConditionalWrapper({ condition, wrapper, falseWrapper, children }: Prop) {\n  return (condition ? wrapper(children) : (falseWrapper ? falseWrapper(children) : children)) as JSX.Element;\n}","import { crystalizeLevelMultipliers, transformativeReactionLevelMultipliers, transformativeReactions } from \"../StatConstants\";\nimport { objectKeyMap } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { frac, infoMut, prod, subscript, sum, unit } from \"./utils\";\n\nconst asConst = true as const\n\nconst crystalizeMulti1 = subscript(input.lvl, crystalizeLevelMultipliers)\nconst crystalizeElemas = prod(4000 / 9, frac(input.total.eleMas, 1400))\nconst crystalizeHit = infoMut(prod(sum(unit, /** + Crystalize bonus */ crystalizeElemas), crystalizeMulti1), { /** Crystalize Shield HP */ })\n\nconst transMulti1 = subscript(input.lvl, transformativeReactionLevelMultipliers)\nconst transMulti2 = prod(16, frac(input.total.eleMas, 2000))\nconst trans = {\n  ...objectKeyMap([\"overloaded\", \"electrocharged\", \"superconduct\", \"shattered\"] as const, reaction => {\n    const { multi, variants: [ele] } = transformativeReactions[reaction]\n    return infoMut(prod(\n      infoMut(prod(multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total[`${reaction}_dmg_`]),\n      input.enemy[`${ele}_resMulti`]),\n      { key: `${reaction}_hit`, variant: reaction })\n  }),\n  swirl: objectKeyMap(transformativeReactions.swirl.variants, ele => infoMut(\n    prod(\n      infoMut(prod(transformativeReactions.swirl.multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total.swirl_dmg_),\n      input.enemy[`${ele}_resMulti`]),\n    { key: `${ele}_swirl_hit`, variant: ele }))\n}\nexport const reactions = {\n  anemo: {\n    electroSwirl: trans.swirl.electro,\n    pyroSwirl: trans.swirl.pyro,\n    cryoSwirl: trans.swirl.cryo,\n    hydroSwirl: trans.swirl.hydro,\n    shattered: trans.shattered,\n  },\n  geo: {\n    ...objectKeyMap([\"pyro\", \"electro\", \"cryo\", \"hydro\"] as const, _ =>\n      prod(2.5, crystalizeHit)),\n    shattered: trans.shattered,\n  },\n  electro: {\n    overloaded: trans.overloaded,\n    electrocharged: trans.electrocharged,\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n  hydro: {\n    electrocharged: trans.electrocharged,\n    shattered: trans.shattered,\n  },\n  pyro: {\n    overloaded: trans.overloaded,\n    shattered: trans.shattered,\n  },\n  cryo: {\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        if (!first)\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = fold(first, context)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined)\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined)\n          result = fold(operands[0], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n"],"sourceRoot":""}