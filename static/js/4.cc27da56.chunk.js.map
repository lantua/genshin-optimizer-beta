{"version":3,"sources":["Components/Card/CardLight.tsx","Formula/index.ts","ReactHooks/usePromise.tsx","Components/Card/CardDark.tsx","Components/Image/ImgIcon.tsx","Components/SqBadge.tsx","Formula/utils.ts","Components/DropdownMenu/DropdownButton.tsx","Data/Characters/CharacterSheet.tsx","Assets/icon_bow.png","Assets/Assets.ts","Assets/icon_catalyst.png","Assets/icon_claymore.png","Assets/icon_polearm.png","Assets/icon_sword.png","Assets/Item_Fragile_Resin.png","Assets/Item_Condensed_Resin.png","Assets/Item_Wanderer's_Advice.png","Assets/Item_Hero's_Wit.png","Assets/Item_Adventurer's_Experience.png","Formula/api.tsx","Components/StarDisplay.tsx","Components/StatIcon.tsx","Data/Weapons/WeaponSheet.tsx","Components/CloseButton.tsx","Formula/uiData.tsx","Components/ModalWrapper.tsx","ReactHooks/useForceUpdate.tsx","Components/SolidToggleButtonGroup.tsx","Components/ConditionalWrapper.tsx","Formula/reaction.ts","Formula/optimization.ts","Types/artifact_WR.ts","Formula/internal.ts"],"names":["CardLight","styled","Card","backgroundColor","theme","palette","contentLight","main","pivot","allElements","allElementsWithPhy","allTalents","allMoves","allMainSubStats","Set","allMainStatKeys","allSubstats","allTransformative","allAmplifying","allModStats","allNonModStats","map","x","allEleEnemyResKeys","talent","objectKeyMap","_","read","allModStatNodes","key","undefined","allNonModStatNodes","ele","info","variant","reaction","withDefaultInfo","value","deepClone","crawlObject","operation","input","setReadNodeKeys","activeCharKey","stringRead","charKey","charEle","infusion","weaponType","lvl","prefix","constellation","asc","special","base","customBonus","bonus","premod","total","objectKeyValueMap","cappedCritRate","art","asConst","allSlotKeys","id","set","artSet","allArtifactSets","weapon","type","refinement","refineIndex","sub","sub2","team","enemy","def","level","defRed","defIgn","hit","move","hitMode","dmgBonus","dmgInc","dmg","accu","markAccu","stat","endsWith","Object","entries","atk","critRate_","baseAmpBonus","sum","unit","prod","frac","eleMas","effectiveReaction","lookup","pyro","vaporize","constant","melt","hydro","matchFull","cryo","common","operands","push","percent","filter","stamina","max","min","naught","all_dmg_","all_dmgInc","NaN","stringPrio","critHit","critDMG_","avgHit","res","infoMut","target","uiInput","allRegions","usePromise","promise","dependencies","useState","setRes","useEffect","pending","then","console","error","CardDark","contentDark","ImgIcon","name","slot","size","display","width","height","verticalAlign","SqBadge","color","padding","fontSize","fontWeight","lineHeight","textAlign","whiteSpace","borderRadius","contrastText","Number","MAX_VALUE","Infinity","node","match","v1","v2","intoV","emptyOn","unmatch","index","table","defaultV","values","intoOps","c","threshold_add","thres","addition","threshold","pass","fail","nodeList","Error","path","keys","data","resetData","reset","customRead","customStringRead","subscript","list","DropdownButton","title","children","props","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","fallback","endIcon","onClick","onClose","MenuListProps","characterSheets","imp","default","CharacterSheet","charSheet","sheet","isMelee","weaponTypeKey","getTalent","eleKey","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","sx","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","getLevelString","ascension","ascensionMaxLevel","talentTemplate","tr","img","sections","text","talentStrMap","auto","skill","burst","passive","passive1","passive2","passive3","sprint","constellation1","constellation2","constellation3","constellation4","constellation5","constellation6","conditionalHeader","icon","m","action","normalSrc","weaponKey","Assets","weaponTypes","bow","catalyst","claymore","polearm","sword","resin","fragile","condensed","exp_books","advice","wit","experience","inferInfoMut","source","slice","reference","objPathValue","log","dataObjForArtifact","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatValue","mainStatKey","Math","stats","substats","forEach","fromEntries","slotKey","setKey","dataObjForCharacter","char","result","enemyOverride","enemyLevel","bonusStats","enemyDefRed_","enemyDefIgn_","basic","reactions","layeredAssignment","conditional","dataObjForWeapon","teamBuff","uiDataForTeam","teamData","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","custom","newNode","sourceKey","sourceBuff","buff","calc","readNode","targetKey","assign","origin","UIData","length","internal","flatMap","computeUIData","StarIcon","faStar","Stars","stars","colored","component","Array","i","HPIcon","className","faHpPrimary","faHpSecondary","style","CdRedIcon","faCdReductionPrimary","faCdReductionSecondary","EnerRechIcon","faEnergyRechargePrimary","faEnergyRechargeSecondary","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","faHydro","faPyro","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","StatIcon","characterHP","finalHP","hp_","hp","baseATK","faAtk","characterATK","finalATK","atk_","characterDEF","faDef","finalDEF","def_","faElementalMastery","faCritRate","faDiceD20","enerRech_","heal_","faHealingBonus","cdRed_","shield_","faShieldStrength","faMaxStamina","weaponSheets","WeaponSheet","weaponSheet","weaponData","strKey","ns","key18","passiveDescription","iconAwaken","document","w","getWeaponsOfType","CloseButton","large","t","useTranslation","startIcon","p","minWidth","shouldWrap","valueString","fixed","isFinite","isInteger","abs","toFixed","parent","Map","nodes","processed","getAll","calculated","trace","isEmpty","formulas","old","formula","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","first","find","illformed","assertUnreachable","mayNeedWrapping","valueDisplay","prefixDisplay","getPrefixStr","sourceDisplay","getNoUnit","createDisplay","readFirst","_accumulate","readAll","selected","v1Node","v2Node","matchNode","unmatchNode","matching","makeEmpty","valueNode","thresholdNode","child","operand","unique","delete","next","mergeVariants","identity","allOperations","fStr","separator","every","strings","predisplay","string","item","array","itemFormula","createFormulaComponent","add","mergeFormulaComponents","components","emptyValue","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","useForceUpdate","stateDirty","update","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","dark","ConditionalWrapper","condition","wrapper","falseWrapper","crystalizeMulti1","crystalizeLevelMultipliers","crystalizeElemas","crystalizeHit","transMulti1","transformativeReactionLevelMultipliers","transMulti2","trans","transformativeReactions","multi","variants","swirl","swirl_dmg_","electroSwirl","pyroSwirl","cryoSwirl","hydroSwirl","shattered","overloaded","electrocharged","superconduct","allCommutativeMonoidOperations","reduce","a","b","mul","sum_frac","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","mapFormulas","f","has","flattened","dep","elementCounts","wrap","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","nextContextMap","fold","context","numericOperands","formulaOperands","folded","numericValue","op","nextContext","forEachNodes","topDown","bottomUp","visiting","visited","traverse","topDownMap","bottomUpMap","topDownMapped","bottomUpMapped","check","arrayEqual"],"mappings":"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","file":"static/js/4.cc27da56.chunk.js","sourcesContent":["import { Card, styled } from \"@mui/material\";\n\nconst CardLight = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentLight.main\n}));\n\nexport default CardLight","import { allEleEnemyResKeys } from \"../KeyMap\"\nimport { allMainStatKeys, allSubstats } from \"../Types/artifact_WR\"\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\nimport { constant, frac, infoMut, lookup, matchFull, max, min, naught, percent, prod, read, res, setReadNodeKeys, stringPrio, stringRead, sum, unit } from \"./utils\"\n\nconst asConst = true as const, pivot = true as const\n\nconst allElements = allElementsWithPhy\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\"] as const\nconst allMainSubStats = [...new Set([...allMainStatKeys, ...allSubstats] as const)]\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\nconst allMisc = [\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\"\n] as const\n\nconst allModStats = [\n  ...allMainSubStats,\n]\nconst allNonModStats = [\n  ...([\"all\", ...allMoves] as const).map(x => `${x}_dmgInc` as const),\n  ...([\"all\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\n  ...([...allElements] as const).map(x => `${x}_critDMG_` as const),\n  ...allElements.map(x => `${x}_res_` as const),\n  ...allMoves.map(x => `${x}_critRate_` as const),\n  ...allEleEnemyResKeys,\n  ...allMisc,\n]\n\nconst talent = objectKeyMap(allTalents, _ => read())\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\n\nfor (const ele of allElements) {\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\n  allModStatNodes[`${ele}_dmg_`].info!.variant = ele\n}\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\n  allNonModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\n}\n\nfunction withDefaultInfo<T>(info: Info, value: T): T {\n  value = deepClone(value)\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\n  return value\n}\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\n  })\n}\n\n/** All read nodes */\nconst input = setReadNodeKeys(deepClone({\n  activeCharKey: stringRead(),\n  charKey: stringRead(), charEle: stringRead(), infusion: stringRead(), weaponType: stringRead(),\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\n\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\n    ...allModStatNodes, ...allNonModStatNodes,\n  }),\n  bonus: { ...talent },\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\n    ...allModStatNodes, ...allNonModStatNodes,\n    /** Total Crit Rate capped to [0%, 100%] */\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\n  }),\n\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\n    ...allModStatNodes,\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\n  }),\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\n\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\n    key: stringRead(), type: stringRead(),\n\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\n    main: read(), sub: read(), sub2: read(),\n  }),\n\n  team: { infusion: stringRead() },\n\n  enemy: {\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\n\n    level: read(undefined, { key: \"enemyLevel\" }),\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\n    defRed: read(\"add\", { key: \"enemyDefRed_\", pivot }),\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\n  },\n\n  hit: {\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\n    base: read(\"add\", { key: \"base\" }),\n\n    dmgBonus: read(undefined, { key: \"dmg_\", pivot }),\n    dmgInc: read(undefined, { key: \"dmgInc\", pivot }),\n    dmg: read(),\n  },\n}))\n\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\n\n// Adjust `info` for printing\nmarkAccu('add', {\n  bonus, customBonus, premod, art,\n  total: objectKeyMap(allMainSubStats, stat => stat.endsWith(\"_dmg_\") ? {} : total[stat])\n})\nfor (const [key, value] of Object.entries(total)) {\n  if (key.endsWith(\"_dmg_\"))\n    delete (value as ReadNode<number>).accu\n}\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\ndelete total.critRate_.info!.pivot\ntotal.critRate_.info!.prefix = \"uncapped\"\n\n// Nodes that are not used anywhere else but `common` below\n\n/** Base Amplifying Bonus */\nconst baseAmpBonus = sum(unit, prod(25 / 9, frac(total.eleMas, 1400)))\n/** Effective reaction, taking into account the hit's element */\nexport const effectiveReaction = lookup(hit.ele, {\n  pyro: lookup(hit.reaction, { vaporize: constant(\"vaporize\"), melt: constant(\"melt\") }, undefined),\n  hydro: matchFull(hit.reaction, \"vaporize\", \"vaporize\", undefined),\n  cryo: matchFull(hit.reaction, \"melt\", \"melt\", undefined),\n}, undefined)\n\nconst common: Data = {\n  premod: {\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\n    ...objectKeyMap(allModStats, key => {\n      const operands: NumNode[] = []\n      switch (key) {\n        case \"atk\": case \"def\": case \"hp\":\n          operands.push(prod(base[key], sum(unit, premod[`${key}_`])))\n          break\n        case \"critRate_\":\n          operands.push(percent(0.05, { key: \"critRate_\", prefix: \"default\" }),\n            lookup(hit.move, objectKeyMap(allMoves, move => customBonus[`${move}_critRate_`]), 0))\n          break\n        case \"critDMG_\":\n          operands.push(percent(0.5, { key: \"critDMG_\", prefix: \"default\" }),\n            lookup(hit.ele, objectKeyMap(allElements, ele => customBonus[`${ele}_critDMG_`]), 0))\n      }\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\n    }),\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\n  },\n  total: {\n    ...objectKeyMap(allTalents, talent => premod[talent]),\n    ...objectKeyMap(allModStats, key => premod[key]),\n    ...objectKeyMap(allNonModStats, key => premod[key]),\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\n\n    cappedCritRate: max(min(total.critRate_, unit), naught),\n  },\n\n  hit: {\n    dmgBonus: sum(\n      total.all_dmg_,\n      lookup(effectiveReaction, objectKeyMap(allAmplifying, reaction => total[`${reaction}_dmg_`]), naught),\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\n    ),\n    dmgInc: sum(\n      total.all_dmgInc,\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\n    ),\n    ele: stringPrio(\n      input.infusion,\n      input.team.infusion,\n      // Inferred Element\n      matchFull(input.weaponType, \"catalyst\", input.charEle, undefined),\n      matchFull(hit.move, \"skill\", input.charEle, undefined),\n      \"physical\",\n    ),\n    dmg: prod(\n      sum(hit.base, hit.dmgInc),\n      sum(unit, hit.dmgBonus),\n      lookup(hit.hitMode, {\n        hit: unit,\n        critHit: sum(unit, total.critDMG_),\n        avgHit: sum(unit, prod(total.cappedCritRate, total.critDMG_)),\n      }, NaN),\n      enemy.def,\n      lookup(hit.ele,\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\n      lookup(effectiveReaction, {\n        melt: lookup(hit.ele, {\n          pyro: prod(2, baseAmpBonus),\n          cryo: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"melt_dmg_\" }),\n        vaporize: lookup(hit.ele, {\n          hydro: prod(2, baseAmpBonus),\n          pyro: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"vaporize_dmg_\" }),\n      }, 1),\n    ),\n  },\n\n  enemy: {\n    // TODO: shred cap of 90%\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(1, prod(-1, enemy.defRed)), sum(1, prod(-1, enemy.defIgn)))),\n    ...objectKeyValueMap(allElements, ele =>\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\n  },\n}\n\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\nconst tally = setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"])\n\n/**\n * List of `input` nodes, rearranged to conform to the needs of the\n * UI code. This is a separate list so that the evolution of the UIs\n * does not rely on the structure of `input`. So the UI code can rearrange\n * nodes as it sees fit without requiring updates to data sheets, which\n * pertains ~90% of all `input`-related code, and so are very sensitive\n * to any changes to `input`. For zero overhead, use the nodes directly\n * from `input` instead of a copy.\n */\nconst uiInput = input\n\nexport {\n  input, uiInput, common, customBonus,\n\n  target, tally,\n}\n","import { useEffect, useState } from \"react\";\n\nexport default function usePromise<T>(promise: Promise<T> | undefined, dependencies: any[]): T | undefined {\n  const [res, setRes] = useState<T | undefined>(undefined);\n  useEffect(() => {\n    let pending = true\n    promise?.then(res => pending && setRes(() => res), console.error) ?? setRes(undefined)\n    return () => {\n      pending = false\n      setRes(undefined)\n    }\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\n  return res\n}","import { Card, styled } from \"@mui/material\";\n\nconst CardDark = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentDark.main\n}));\n\nexport default CardDark","import { styled } from \"@mui/material\"\ninterface ImgIconProps {\n  size?: number;\n}\nconst ImgIcon = styled(\"img\", {\n  name: 'ImgIcon',\n  slot: 'Root',\n})<ImgIconProps>(({ size = 1 }) => ({\n  display: \"inline-block\",\n  width: \"auto\",\n  height: `${size * 1.2}em`,\n  verticalAlign: \"text-bottom\"\n}))\n\nexport default ImgIcon","import { styled } from \"@mui/material\";\n\nconst SqBadge = styled(\"span\", {\n  name: 'SqBadge',\n  slot: 'Root',\n})(({ theme, color = \"primary\" }) => ({\n  display: \"inline-block\",\n  padding: \".25em .4em\",\n  fontSize: \"75%\",\n  fontWeight: 700,\n  lineHeight: 1,\n  textAlign: \"center\",\n  whiteSpace: \"nowrap\",\n  verticalAlign: \"baseline\",\n  borderRadius: \".25em\",\n  backgroundColor: theme.palette[color]?.main,\n  color: theme.palette[color]?.contrastText\n}))\nexport default SqBadge","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const unit = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n/** `v1` === `v2` ? `match` : 0 */\nexport function match(v1: Str, v2: Str, match: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** `v1` === `v2` ? 0 : `unmatch` */\nexport function unmatch(v1: Str, v2: Str, unmatch: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(unmatch)], info, emptyOn: \"match\" }\n}\n/** `v1` === `v2` ? `match` : `unmatch` */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\n/** value >= threshold ? addition : 0 */\nexport function threshold_add(value: Num, thres: Num, addition: Num, info?: Info): NumNode {\n  return threshold(value, thres, addition, 0, info)\n}\n/** value >= threshold ? value : emptyValue */\nexport function threshold(value: Num, threshold: Num, pass: Str, fail: Str, info?: Info): StrNode\nexport function threshold(value: Num, threshold: Num, pass: Num, fail: Num, info?: Info): NumNode\nexport function threshold(value: Num, threshold: Num, pass: Num | Str, fail: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(value), intoV(threshold), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\nexport function stringRead(): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n","import { KeyboardArrowDown } from \"@mui/icons-material\";\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\nimport { Suspense, useCallback, useState } from \"react\";\n\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\n  title: React.ReactNode,\n  id?: string,\n  children: React.ReactNode\n}\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n  const open = Boolean(anchorEl);\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\n    [setAnchorEl],\n  )\n  const handleClose = useCallback(\n    () => setAnchorEl(null),\n    [setAnchorEl],\n  )\n\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\n    <Button\n      {...props}\n      id={id}\n      aria-controls=\"basic-menu\"\n      aria-haspopup=\"true\"\n      aria-expanded={open ? 'true' : undefined}\n      onClick={handleClick}\n      endIcon={<KeyboardArrowDown />}\n    >\n      {title}\n    </Button>\n    <Menu\n      id=\"basic-menu\"\n      anchorEl={anchorEl}\n      open={open}\n      onClose={handleClose}\n      MenuListProps={{\n        'aria-labelledby': id,\n      }}\n      onClick={handleClose}\n    >\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\n        {children}\n      </Suspense>\n    </Menu>\n  </Suspense>\n}","import ImgIcon from \"../../Components/Image/ImgIcon\";\nimport { ascensionMaxLevel } from \"../LevelData\";\nimport { Data } from \"../../Formula/type\";\nimport { TalentSheet, TalentSheetElement, TalentSheetElementKey } from \"../../Types/character_WR\";\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\nimport SqBadge from \"../../Components/SqBadge\";\nimport Assets from \"../../Assets/Assets\";\nimport IConditional from \"../../Types/IConditional_WR\";\n\nconst characterSheets = import('.').then(imp => imp.default)\n\ninterface ICharacterSheetBase {\n  name: Displayable\n  cardImg: string\n  thumbImg: string\n  thumbImgSide: string\n  barImg?: string\n  bannerImg?: string\n  rarity: Rarity\n  weaponTypeKey: WeaponTypeKey\n  gender: string\n  constellationName: Displayable\n  title: Displayable\n}\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\n  elementKey: ElementKey\n  talent: TalentSheet\n}\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\n  talents: Dict<ElementKey, TalentSheet>\n}\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\n\nexport default class CharacterSheet {\n  sheet: ICharacterSheet;\n  data: Data;\n  constructor(charSheet: ICharacterSheet, data: Data) {\n    this.sheet = charSheet\n    this.data = data\n  }\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\n  static get getAll() { return characterSheets }\n  get name() { return this.sheet.name }\n  get nameWIthIcon() { return <span><ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> {this.name}</span> }\n  get cardImg() { return this.sheet.cardImg }\n  get thumbImg() { return this.sheet.thumbImg }\n  get thumbImgSide() { return this.sheet.thumbImgSide }\n  get bannerImg() { return this.sheet.bannerImg }\n  get rarity() { return this.sheet.rarity }\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\n  get constellationName() { return this.sheet.constellationName }\n\n  isMelee = () => {\n    const weaponTypeKey = this.sheet.weaponTypeKey\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\n  }\n  get isTraveler() {\n    return \"talents\" in this.sheet\n  }\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\n    if (\"talent\" in this.sheet) return this.sheet.talent\n    else return this.sheet.talents[eleKey]\n  }\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\n\n  static getLevelString = (level: number, ascension: number): string =>\n    `${level}/${ascensionMaxLevel[ascension]}`\n}\n\nexport const talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): TalentSheetElement => ({\n  name: tr(`${talentKey}.name`),\n  img,\n  sections: [{\n    text: tr(`${talentKey}.description`),\n  }],\n})\n\nconst talentStrMap: Record<TalentSheetElementKey, string> = {\n  auto: \"Auto\",\n  skill: \"Skill\",\n  burst: \"Burst\",\n  passive: \"Passive\",\n  passive1: \"Ascension 1\",\n  passive2: \"Ascension 4\",\n  passive3: \"Passive\",\n  sprint: \"Sprint\",\n  constellation1: \"C1\",\n  constellation2: \"C2\",\n  constellation3: \"C3\",\n  constellation4: \"C4\",\n  constellation5: \"C5\",\n  constellation6: \"C6\"\n}\nexport const conditionalHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IConditional[\"header\"] => {\n  return {\n    title: tr(`${talentKey}.name`),\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\n    action: <SqBadge color=\"success\">{talentStrMap[talentKey]}</SqBadge>,\n  }\n}\n\nexport const normalSrc = (weaponKey: WeaponTypeKey) => Assets.weaponTypes[weaponKey]\n","export default __webpack_public_path__ + \"static/media/icon_bow.7ceaa8e2.png\";","import bow from './icon_bow.png'\nimport catalyst from './icon_catalyst.png'\nimport claymore from './icon_claymore.png'\nimport polearm from './icon_polearm.png'\nimport sword from './icon_sword.png'\n\nimport fragile from './Item_Fragile_Resin.png'\nimport condensed from './Item_Condensed_Resin.png'\n\n//EXP BOOKS\nimport advice from './Item_Wanderer\\'s_Advice.png'\nimport wit from './Item_Hero\\'s_Wit.png'\nimport experience from './Item_Adventurer\\'s_Experience.png'\n\nconst Assets = {\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\n  resin: {\n    fragile,\n    condensed\n  },\n  exp_books: {\n    advice,\n    wit,\n    experience,\n  }\n};\nexport default Assets;","export default __webpack_public_path__ + \"static/media/icon_catalyst.db078b7b.png\";","export default __webpack_public_path__ + \"static/media/icon_claymore.63b1abb8.png\";","export default __webpack_public_path__ + \"static/media/icon_polearm.e5f4a2a1.png\";","export default __webpack_public_path__ + \"static/media/icon_sword.619c9c2d.png\";","export default __webpack_public_path__ + \"static/media/Item_Fragile_Resin.f9ec8223.png\";","export default __webpack_public_path__ + \"static/media/Item_Condensed_Resin.1cecf64a.png\";","export default __webpack_public_path__ + \"static/media/Item_Wanderer's_Advice.58c62cf7.png\";","export default __webpack_public_path__ + \"static/media/Item_Hero's_Wit.a79e36d0.png\";","export default __webpack_public_path__ + \"static/media/Item_Adventurer's_Experience.92b5d195.png\";","import Artifact from \"../Data/Artifacts/Artifact\";\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\nimport { ICachedCharacter } from \"../Types/character_WR\";\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\nimport { ICachedWeapon } from \"../Types/weapon\";\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { reactions } from \"./reaction\";\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\nimport { NodeDisplay, UIData, valueString } from \"./uiData\";\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\n\nconst asConst = true as const, pivot = true as const\n\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\n    if (path[0] === \"teamBuff\") path = path.slice(1)\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\n    if (reference)\n      x.info = { ...reference.info, prefix: undefined, source }\n    else if (path[0] !== \"tally\")\n      console.log(`Detect ${source} buff into non-existant key path ${path}`)\n  })\n\n  return data\n}\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\n  stats.push([art.mainStatKey, mainStatVal])\n  art.substats.forEach(({ key, value }) => key && stats.push([key, value]))\n  return {\n    art: {\n      ...Object.fromEntries(stats.map(([key, value]) =>\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\n      [art.slotKey]: {\n        id: constant(art.id), set: constant(art.setKey)\n      },\n    },\n    artSet: {\n      [art.setKey]: constant(1)\n    }\n  }\n}\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\n  const result: Data = {\n    lvl: constant(char.level),\n    constellation: constant(char.constellation),\n    asc: constant(char.ascension),\n\n    premod: {\n      auto: constant(char.talent.auto),\n      skill: constant(char.talent.skill),\n      burst: constant(char.talent.burst),\n    },\n    enemy: {\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\n    },\n    hit: {\n      hitMode: constant(char.hitMode)\n    },\n    customBonus: {},\n  }\n\n  for (const [key, value] of Object.entries(char.bonusStats))\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\n\n  if (char.enemyOverride.enemyDefRed_)\n    result.enemy!.defRed = percent(char.enemyOverride.enemyDefRed_)\n  if (char.enemyOverride.enemyDefIgn_)\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_)\n  if (char.elementKey) {\n    result.charEle = constant(char.elementKey)\n    result.display = {\n      basic: { [`${char.elementKey}_dmg_`]: input.total[`${char.elementKey}_dmg_`] },\n      reaction: reactions[char.elementKey]\n    }\n    layeredAssignment(result, [\"teamBuff\", \"tally\", char.elementKey], constant(1))\n  }\n\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\n    layeredAssignment(result, keys, constant(x)))\n  return result\n}\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\n  return {\n    weapon: {\n      lvl: constant(weapon.level),\n      asc: constant(weapon.ascension),\n      refinement: constant(weapon.refinement),\n      refineIndex: constant(weapon.refinement - 1)\n    },\n  }\n}\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\n  // May the goddess of wisdom bless any and all souls courageous\n  // enough to attempt for the understanding of this abomination.\n\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\n  const result = Object.fromEntries(mergedData.map(([key]) =>\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\n\n  const customReadNodes = {}\n  function getReadNode(path: readonly string[]): ReadNode<number> {\n    const base = (path[0] === \"teamBuff\")\n      ? objPathValue(teamBuff, path.slice(1))\n      : objPathValue(input, path)\n    if (base) return base\n    const custom = objPathValue(customReadNodes, path)\n    if (custom) return custom\n    const newNode = customRead(path)\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\n    layeredAssignment(customReadNodes, path, newNode)\n    return newNode\n  }\n\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\n    mergedData.forEach(([sourceKey, source]) => {\n      const sourceBuff = source.teamBuff\n      // Create new copy of `calc` as we're mutating it later\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\n      buffs.push(buff)\n      calcs[sourceKey] = calc\n\n      // This construction creates a `Data` representing buff\n      // from `source` applying to `target`. It has 3 data:\n      // - `target` contains the reference for the final\n      //   data. It is not populated at this stage,\n      // - `calc` contains the calculation of the buffs,\n      // - `buff` contains read nodes that point to the\n      //   calculation in `calc`.\n\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\n\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\n\n          let readNode: ReadNode<number | string> | undefined, data: Data\n          if (x.path[0] === \"target\") { // Link the node to target data\n            readNode = getReadNode(x.path.slice(1))\n            data = targetRef\n          } else { // Link the node to source data\n            readNode = x\n            data = result[sourceKey].targetRef\n          }\n          layeredAssignment(calc, x.path, resetData(readNode, data))\n        })\n      })\n    })\n  )\n  mergedData.forEach(([targetKey, data]) => {\n    delete data.teamBuff\n    const { targetRef, buffs } = result[targetKey]\n    const buff = mergeData(buffs)\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\n      // CAUTION\n      // This is safe only because `buff` is created using only `resetData`\n      // and `mergeData`. So every node here is created from either of the\n      // two functions, so the mutation wont't affect existing nodes.\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\n    })\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\n    targetRef[\"target\"] = targetRef\n  })\n  const origin = new UIData(undefined as any, undefined)\n  const uiDataResult = Object.fromEntries(Object.entries(result).map(([key, value]) =>\n    [key, {\n      target: new UIData(value.targetRef, origin),\n      buff: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\n        [key, new UIData(value, origin)]))\n    }]))\n  return uiDataResult\n}\nfunction mergeData(data: Data[]): Data {\n  function internal(data: any[], path: string[]): any {\n    if (data.length <= 1) return data[0]\n    if (data[0].operation) {\n      if (path[0] === \"teamBuff\") path = path.slice(1)\n      const accu = path[0] === \"tally\"\n        ? \"add\" : (objPathValue(input, path) as ReadNode<number> | undefined)?.accu\n      if (accu === undefined) {\n        if (data.length !== 1)\n          throw new Error(`Multiple entries when merging \\`unique\\` for key ${path}`)\n        return data[0]\n      }\n      const result: NumNode = { operation: accu, operands: data }\n      return result\n    } else {\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\n    }\n  }\n  return data.length ? internal(data, []) : {}\n}\n\nfunction computeUIData(data: Data[]): UIData {\n  return new UIData(mergeData(data), undefined)\n}\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\n}\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\n}\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\n  if (data1?.operation || data2?.operation) {\n    const d1 = data1 as NodeDisplay | undefined\n    const d2 = data2 as NodeDisplay | undefined\n\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\n      throw new Error(\"Unmatched structure when comparing UIData\")\n\n    const result: ComparedNodeDisplay = {\n      operation: true,\n      value: 0,\n      isEmpty: true,\n      unit: d2?.unit!,\n      formulas: [],\n      ...d1,\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\n    }\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\n      // In case `string` got involved, just use the other value\n      result.value = d1?.value ?? \"\" as any\n      result.diff = d2?.value ?? \"\" as any\n    }\n    return result\n  }\n\n  if (data1 || data2) {\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\n  }\n}\n\nexport type { NodeDisplay, UIData };\nexport {\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\n  mergeData, computeUIData, valueString, inferInfoMut,\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\n};\n","import { faStar } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Typography } from '@mui/material'\nimport { Rarity } from '../Types/consts'\n\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\n  </Typography>\n\nexport {\n  StarIcon,\n  Stars\n}\n","import { faDiceD20 } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faAnemo, faAtk, faCdReductionPrimary, faCdReductionSecondary, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRechargePrimary, faEnergyRechargeSecondary, faGeo, faHealingBonus, faHpPrimary, faHpSecondary, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\nimport { objectKeyMap } from '../Util/Util'\nimport ColorText from './ColoredText'\n\nexport function HPIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faHpPrimary as any} />\n    <FontAwesomeIcon icon={faHpSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function CdRedIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faCdReductionPrimary as any} />\n    <FontAwesomeIcon icon={faCdReductionSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function EnerRechIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faEnergyRechargePrimary as any} />\n    <FontAwesomeIcon icon={faEnergyRechargeSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\nexport const uncoloredEleIcons = {\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\n} as const\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} >{uncoloredEleIcons[key]}</ColorText>)\n\nconst StatIcon = {\n  characterHP: <HPIcon />,\n  finalHP: <HPIcon />,\n  hp_: <HPIcon />,\n  hp: <HPIcon />,\n\n  baseATK: <FontAwesomeIcon icon={faAtk as any} />,\n  characterATK: <FontAwesomeIcon icon={faAtk as any} />,\n  finalATK: <FontAwesomeIcon icon={faAtk as any} />,\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\n\n  characterDEF: <FontAwesomeIcon icon={faDef as any} />,\n  finalDEF: <FontAwesomeIcon icon={faDef as any} />,\n  def_: <FontAwesomeIcon icon={faDef as any} />,\n  def: <FontAwesomeIcon icon={faDef as any} />,\n\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\n  critDMG_: <FontAwesomeIcon icon={faDiceD20 as any} />,\n  enerRech_: <EnerRechIcon />,\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\n\n  cdRed_: <CdRedIcon />,\n\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\n\n  ...coloredEleIcon,\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [[`${ele}_dmg_`, coloredEleIcon[ele]], [`${ele}_res_`, coloredEleIcon[ele]]]))\n}\n\nexport default StatIcon\n","import { Translate } from '../../Components/Translate';\nimport { Data } from '../../Formula/type';\nimport { Rarity, WeaponKey, WeaponTypeKey } from '../../Types/consts';\nimport { DocumentSection } from '../../Types/sheet';\nimport { ICachedWeapon } from '../../Types/weapon_WR';\nimport { ascensionMaxLevel } from '../LevelData';\nimport type { WeaponData } from 'pipeline';\nconst weaponSheets = import('.').then(imp => imp.default)\n\nexport interface IWeaponSheet {\n  icon: string,\n  iconAwaken: string,\n  document: DocumentSection[],\n}\n\nexport default class WeaponSheet {\n  readonly key: WeaponKey;\n  readonly sheet: IWeaponSheet;\n  readonly data: Data;\n  readonly rarity: Rarity;\n  readonly weaponType: WeaponTypeKey;\n  constructor(key: string, weaponSheet: IWeaponSheet, weaponData: WeaponData, data: Data) {\n    this.rarity = weaponData.rarity\n    this.weaponType = weaponData.weaponType\n    this.key = key as WeaponKey\n    this.sheet = weaponSheet\n    this.data = data\n  }\n  static get = (weaponKey: WeaponKey | \"\"): Promise<WeaponSheet> | undefined => weaponKey ? weaponSheets.then(w => w[weaponKey]) : undefined\n  static get getAll() { return weaponSheets }\n  static getWeaponsOfType = (sheets: StrictDict<WeaponKey, WeaponSheet>, weaponType: string): Dict<WeaponKey, WeaponSheet> => Object.fromEntries(Object.entries(sheets).filter(([key, sheet]) => (sheet as WeaponSheet).weaponType === weaponType))\n  static getLevelString = (weapon: ICachedWeapon): string => `${weapon.level}/${ascensionMaxLevel[weapon.ascension]}`\n  tr = (strKey: string) => <Translate ns={`weapon_${this.key}_gen`} key18={strKey} />\n  get name() { return this.tr(\"name\") }\n  //when there is no substat, assume there is no passive.\n  get passiveName() { return this.rarity > 2 ? this.tr(\"passiveName\") : \"\" }\n  get description() { return this.tr(\"description\") }\n  passiveDescription = (refineIndex: number) => this.rarity > 2 ? this.tr(`passiveDescription.${refineIndex}`) : \"\"\n  get img() { return this.sheet.icon }\n  get imgAwaken() { return this.sheet.iconAwaken }\n  get document() { return this.sheet.document }\n}\n","import { Close } from \"@mui/icons-material\";\nimport { Button, ButtonProps } from \"@mui/material\";\nimport { useTranslation } from \"react-i18next\";\ntype CloseButtonProps = ButtonProps & {\n  large?: boolean\n}\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\n  const { t } = useTranslation(\"ui\")\n  if (large)\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\n    <Close />\n  </Button>\n}","import { uiInput } from \".\"\nimport ColorText from \"../Components/ColoredText\"\nimport KeyMap, { KeyMapPrefix, Unit } from \"../KeyMap\"\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\nimport { allOperations } from \"./optimization\"\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\n\nconst shouldWrap = true\n\nexport function valueString(value: number, unit: Unit, fixed = -1): string {\n  if (!isFinite(value)) {\n    if (value > 0) return `\\u221E`\n    if (value < 0) return `-\\u221E`\n    return 'NaN'\n  }\n  if (unit === \"%\") value *= 100\n  else unit = '' as any\n  if (Number.isInteger(value)) fixed = 0\n  else if (fixed === -1) {\n    if (unit === \"%\") fixed = 1\n    else fixed = Math.abs(value) < 10 ? 3 : Math.abs(value) < 1000 ? 2 : Math.abs(value) < 10000 ? 1 : 0\n  }\n  return `${value.toFixed(fixed)}${unit}`\n}\nexport interface NodeDisplay<V = number> {\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\n  operation: true\n  prefix?: KeyMapPrefix\n  key?: string\n  value: V\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\n  isEmpty: boolean\n  unit: Unit\n  variant?: Variant\n  formula?: Displayable\n  formulas: Displayable[]\n}\n\nexport class UIData {\n  origin: UIData\n  children = new Map<Data, UIData>()\n\n  data: Data[]\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\n\n  display: any = undefined\n  teamBuff: any = undefined\n\n  constructor(data: Data, parent: UIData | undefined) {\n    if (data === undefined) {\n      // Secret *origin* initializer\n      this.data = []\n      this.origin = this\n    } else {\n      if (!parent)\n        parent = new UIData(undefined as any, undefined)\n\n      this.data = [data, ...parent.data]\n      this.origin = parent.origin\n    }\n  }\n\n  getDisplay(): {\n    [key: string]: DisplaySub<NodeDisplay>\n  } {\n    if (!this.display) this.display = this.getAll([\"display\"])\n    return this.display\n  }\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\n    if (!this.teamBuff) {\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\n      // Convert `input` to `uiInput`\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\n        if (node) layeredAssignment(result, path, node)\n      })\n      this.teamBuff = result\n    }\n    return this.teamBuff\n  }\n  getAll(prefix: string[]): any {\n    const result = {}\n    for (const data of this.data) {\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\n    }\n    return result\n  }\n  get(node: NumNode): NodeDisplay\n  get(node: StrNode): NodeDisplay<string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\n    if (node === undefined) {\n      console.trace(\"Please report this bug with this trace\")\n      return { operation: true, value: undefined, isEmpty: true, unit: \"flat\", formulas: [] }\n    }\n    const old = this.processed.get(node)\n    if (old) return old\n\n    const result = computeNodeDisplay(this.computeNode(node))\n    this.processed.set(node, result)\n    return result\n  }\n  private computeNode(node: NumNode): ContextNodeDisplay\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\n    const old = this.nodes.get(node)\n    if (old) return old\n\n    const { operation, info } = node\n    let result: ContextNodeDisplay<number | string | undefined>\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        result = this._compute(node); break\n      case \"threshold\": result = this._threshold(node); break\n      case \"const\": result = this._constant(node.value); break\n      case \"subscript\": result = this._subscript(node); break\n      case \"read\": result = this._read(node); break\n      case \"data\": result = this._data(node); break\n      case \"match\": result = this._match(node); break\n      case \"lookup\": result = this._lookup(node); break\n      case \"prio\": {\n        const first = node.operands.find(x => this.computeNode(x).value !== undefined)\n        if (first) result = this.computeNode(first)\n        else result = illformed\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n\n    if (info) {\n      const { key, prefix, source, variant, asConst } = info\n      let { pivot } = info\n      result = { ...result }\n\n      // Pivot all keyed nodes for debugging\n      // if (key) pivot = true\n\n      if (key) result.key = key\n      if (prefix) result.prefix = prefix\n      if (source) result.source = source\n      if (variant) result.variant = variant\n      if (pivot) result.pivot = pivot\n\n      if (asConst) {\n        delete result.formula\n        delete result.assignment\n        result.dependencies = new Set()\n      }\n      if (result.pivot || !result.formula)\n        result.mayNeedWrapping = false\n    }\n    createDisplay(result)\n\n    this.nodes.set(node, result)\n    return result\n  }\n\n  private readAll(path: readonly string[]): ContextNodeDisplay<number | string | undefined>[] {\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x).map(x => this.computeNode(x))\n  }\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\n    return data && this.computeNode(data)\n  }\n\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\n    const { path } = node\n    const result = (node.accu === undefined)\n      ? this.readFirst(path) ?? (node.type === \"string\" ? this._constant(undefined) : illformed)\n      : this._accumulate(node.accu, this.readAll(path) as ContextNodeDisplay[])\n    return result\n  }\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const key = this.computeNode(node.operands[0]).value\n    const selected = node.table[key!] ?? node.operands[1]\n    if (!selected)\n      throw new Error(`Lookup Fail with key ${key}`)\n    return this.computeNode(selected)\n  }\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\n    const matching = v1.value === v2.value\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\n      ? makeEmpty(result.value) : result\n  }\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const [valueNode, thresholdNode, pass, fail] = node.operands\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\n    return value.value >= threshold.value ? this.computeNode(pass) : makeEmpty(this.computeNode(fail).value)\n  }\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    let child = this.children.get(node.data)\n    if (!child) {\n      child = new UIData(node.data, node.reset ? this.origin : this)\n      this.children.set(node.data, child)\n    }\n    return child.computeNode(node.operands[0])\n  }\n  private _compute(node: ComputeNode): ContextNodeDisplay {\n    const { operation, operands } = node\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\n  }\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\n    const operand = this.computeNode(node.operands[0])\n    const value = node.list[operand.value] ?? NaN\n    return this._constant(value)\n  }\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\n    return {\n      value, pivot: false,\n      empty: false,\n      mayNeedWrapping: false,\n      dependencies: new Set(),\n    }\n  }\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\n    let variant: Variant | undefined\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        variant = mergeVariants(operands); break\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n        const identity = allOperations[operation]([])\n        if (process.env.NODE_ENV !== \"development\")\n          operands = operands.filter(operand => operand.value !== identity)\n        if (!operands.length)\n          return variant ? { ...this._constant(identity), variant } : this._constant(identity)\n    }\n\n    let formula: { display: Displayable, dependencies: Displayable[] }\n    let mayNeedWrapping = false\n    switch (operation) {\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap }}`; break\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\n      case \"res\": {\n        const base = operands[0].value\n        if (base < 0) {\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\n          mayNeedWrapping = true\n        }\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\n        else {\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\n          mayNeedWrapping = true\n        }\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\":\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\n        else if (operation === \"add\") mayNeedWrapping = true\n    }\n\n    const value = allOperations[operation](operands.map(x => x.value))\n    const dependencies = new Set([...operands.flatMap(x =>\n      x.pivot && x.assignment\n        ? [x.assignment, ...x.dependencies]\n        : [...x.dependencies])])\n    const result: ContextNodeDisplay = {\n      formula: formula.display,\n      empty: operands.every(x => x.empty),\n      value, mayNeedWrapping,\n      pivot: false, dependencies,\n    }\n    if (variant) result.variant = variant\n    return result\n  }\n}\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\n  const dependencies = new Set<Displayable>()\n  const predisplay: Displayable[] = []\n\n  strings.forEach((string, i) => {\n    predisplay.push(string)\n\n    const key = list[i]\n    if (key) {\n      const { operands, shouldWrap, separator = \", \" } = key\n      operands.forEach((item, i, array) => {\n        let itemFormula: Displayable\n        if (!item.pivot && item.formula) itemFormula = item.formula\n        else itemFormula = createFormulaComponent(item)\n\n        if (shouldWrap && item.mayNeedWrapping) {\n          predisplay.push(\"( \")\n          predisplay.push(itemFormula)\n          predisplay.push(\" )\")\n        } else {\n          predisplay.push(itemFormula)\n        }\n        if (i + 1 < array.length) predisplay.push(separator)\n        item.dependencies.forEach(x => dependencies.add(x))\n      })\n    }\n  })\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\n}\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): ContextNodeDisplay<V>[\"variant\"] {\n  const unique = new Set(operands.map(x => x.variant))\n  if (unique.size > 1) unique.delete(undefined)\n  if (unique.size > 1) unique.delete(\"physical\")\n  return unique.values().next().value\n}\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\n  const { key, prefix, dependencies, value, variant, formula, assignment, empty } = node\n  return {\n    operation: true,\n    key, value, variant, prefix,\n    isEmpty: empty,\n    unit: (key && KeyMap.unit(key)) || \"flat\",\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\n  }\n}\n\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, key ? KeyMap.unit(key) : \"flat\")}</ColorText>\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.getNoUnit(key!)}</ColorText>{sourceDisplay}</>\n\n    if (formula)\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\n}\n/*/\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = valueString(value, key ? KeyMap.unit(key) : \"flat\")\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? ` ${source}` : \"\"\n    node.name = `${prefixDisplay}${KeyMap.getNoUnit(key!)}${sourceDisplay}`\n\n    if (formula)\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return (components as string[]).join(\"\")\n}\n//*/\n\ninterface ContextNodeDisplay<V = number> {\n  key?: Info[\"key\"]\n  prefix?: Info[\"prefix\"]\n  source?: Info[\"source\"]\n  variant?: Info[\"variant\"]\n\n  pivot: boolean\n  empty: boolean\n\n  value: V\n\n  dependencies: Set<Displayable>\n\n  mayNeedWrapping: boolean\n\n  // Don't set these manually outside of `UIData.computeNode`\n  name?: Displayable\n  valueDisplay?: Displayable\n  formula?: Displayable\n  assignment?: Displayable\n}\n\nconst illformed: ContextNodeDisplay = {\n  value: NaN, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\n  return {\n    value: emptyValue, pivot: false, empty: true, dependencies: new Set(), mayNeedWrapping: false\n  }\n}\n","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\nimport { Suspense } from \"react\"\nimport CardLight from \"./Card/CardLight\"\n\nconst ScrollModal = styled(Modal)(({ theme }) => ({\n  overflow: \"scroll\",\n  paddingTop: theme.spacing(2),\n  paddingBottom: theme.spacing(2),\n\n}))\nconst ModalContainer = styled(Container)(({ theme }) => ({\n  padding: 0,\n  minHeight: \"100%\",\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"auto\"\n  }\n}))\n\ntype ModalWrapperProps = ModalProps & {\n  containerProps?: ContainerProps\n}\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\n  return <ScrollModal {...props}>\n    <ModalContainer {...containerProps}>\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\n        {children}\n      </Suspense>\n    </ModalContainer>\n  </ScrollModal>\n}","import { useCallback, useState } from \"react\"\n\nexport default function useForceUpdate(): [object, () => void] {\n  const [stateDirty, update] = useState({})\n  const forceUpdateHook = useCallback(() => update({}), [])\n  return [stateDirty, forceUpdateHook]\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\n\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\ntype SolidToggleButtonGroupPropsPartial = {\n  baseColor?: ButtonProps[\"color\"];\n  selectedColor?: ButtonProps[\"color\"];\n}\n\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"primary\", selectedColor = \"success\" }) => ({\n  '& .MuiToggleButtonGroup-grouped': {\n    '&': {\n      backgroundColor: theme.palette[baseColor].main,\n      color: theme.palette[baseColor].contrastText,\n    },\n    '&:hover': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected': {\n      backgroundColor: theme.palette[selectedColor].main,\n      color: theme.palette[selectedColor].contrastText,\n    },\n    '&.Mui-selected:hover': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n    '&.Mui-disabled': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected.Mui-disabled': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n  },\n}));\n\nexport default SolidToggleButtonGroup","import { ReactNode } from \"react\";\n\ntype Prop = {\n  condition: boolean,\n  wrapper: (children: ReactNode) => ReactNode\n  falseWrapper?: (children: ReactNode) => ReactNode\n  children: ReactNode\n}\n// Wrap children with element provided by wrapper func when condition is true.\nexport default function ConditionalWrapper({ condition, wrapper, falseWrapper, children }: Prop) {\n  return (condition ? wrapper(children) : (falseWrapper ? falseWrapper(children) : children)) as JSX.Element;\n}","import { crystalizeLevelMultipliers, transformativeReactionLevelMultipliers, transformativeReactions } from \"../StatConstants\";\nimport { objectKeyMap } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { frac, infoMut, prod, subscript, sum, unit } from \"./utils\";\n\nconst asConst = true as const\n\nconst crystalizeMulti1 = subscript(input.lvl, crystalizeLevelMultipliers)\nconst crystalizeElemas = prod(4000 / 9, frac(input.total.eleMas, 1400))\nconst crystalizeHit = infoMut(prod(sum(unit, /** + Crystalize bonus */ crystalizeElemas), crystalizeMulti1), { /** Crystalize Shield HP */ })\n\nconst transMulti1 = subscript(input.lvl, transformativeReactionLevelMultipliers)\nconst transMulti2 = prod(16, frac(input.total.eleMas, 2000))\nconst trans = {\n  ...objectKeyMap([\"overloaded\", \"electrocharged\", \"superconduct\", \"shattered\"] as const, reaction => {\n    const { multi, variants: [ele] } = transformativeReactions[reaction]\n    return infoMut(prod(\n      infoMut(prod(multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total[`${reaction}_dmg_`]),\n      input.enemy[`${ele}_resMulti`]),\n      { key: `${reaction}_hit`, variant: reaction })\n  }),\n  swirl: objectKeyMap(transformativeReactions.swirl.variants, ele => infoMut(\n    prod(\n      infoMut(prod(transformativeReactions.swirl.multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total.swirl_dmg_),\n      input.enemy[`${ele}_resMulti`]),\n    { key: `${ele}_swirl_hit`, variant: ele }))\n}\nexport const reactions = {\n  anemo: {\n    electroSwirl: trans.swirl.electro,\n    pyroSwirl: trans.swirl.pyro,\n    cryoSwirl: trans.swirl.cryo,\n    hydroSwirl: trans.swirl.hydro,\n    shattered: trans.shattered,\n  },\n  geo: {\n    ...objectKeyMap([\"pyro\", \"electro\", \"cryo\", \"hydro\"] as const, _ =>\n      prod(2.5, crystalizeHit)),\n    shattered: trans.shattered,\n  },\n  electro: {\n    overloaded: trans.overloaded,\n    electrocharged: trans.electrocharged,\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n  hydro: {\n    electrocharged: trans.electrocharged,\n    shattered: trans.shattered,\n  },\n  pyro: {\n    overloaded: trans.overloaded,\n    shattered: trans.shattered,\n  },\n  cryo: {\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        if (!first)\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = fold(first, context)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined)\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined)\n          result = fold(operands[0], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { ArtifactRarity, ArtifactSetKey, CharacterKey, ElementKey, SlotKey } from \"./consts\";\n\nexport interface IArtifact {\n  setKey: ArtifactSetKey,\n  slotKey: SlotKey,\n  level: number,\n  rarity: ArtifactRarity,\n  mainStatKey: MainStatKey,\n  location: CharacterKey | \"\",\n  lock: boolean,\n  substats: ISubstat[],\n\n  // GO-specific\n  exclude: boolean,\n}\nexport interface ICachedArtifact extends IArtifact {\n  id: string,\n  mainStatVal: number,\n  substats: ICachedSubstat[],\n}\n\nexport interface ISubstat {\n  key: SubstatKey | \"\"\n  value: number\n}\nexport interface ICachedSubstat extends ISubstat {\n  rolls: number[],\n  efficiency: number,\n}\n/**\n * @deprecated use values in KeyMap\n */\nexport type StatKey = MainStatKey | SubstatKey | ReactionDMGStatKey | MoveDMGStatKey | ElementalRESStatKey | ElementalEnemyRESStatKey | SpecializedStatKey\n\ntype ElementalRESStatKey = `${ElementKey | \"physical\"}_res_`\ntype ElementalEnemyRESStatKey = `${ElementKey | \"physical\"}_enemyRes_`\ntype ReactionDMGStatKey = \"overloaded_dmg_\" | \"shattered_dmg_\" | \"electrocharged_dmg_\" | \"superconduct_dmg_\" | \"swirl_dmg_\" | \"vaporize_dmg_\" | \"melt_dmg_\" | \"burning_dmg_\" | \"crystalize_dmg_\"\ntype MoveDMGStatKey = \"normal_dmg_\" | \"charged_dmg_\" | \"skill_dmg_\" | \"burst_dmg_\"\n\nexport const allMainStatKeys = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"heal_\"] as const\nexport const allSubstats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def_\", \"def\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\",] as const\n\n// TODO: Check if these actually applies\n// TODO: do these belong here?\ntype SpecializedStatKey = \"normal_critRate_\" | \"charged_critRate_\" | \"skill_critRate_\" | \"burst_critRate_\" | \"plunging_dmg_\" | \"shield_\" | \"enemyDefRed_\" | \"skillCDRed_\" | \"incHeal_\" | \"weakspotDMG_\" | \"dmg_\" | \"moveSPD_\" | \"staminaDec_\" | \"atkSPD_\" | \"cdRed_\" | \"finalHP\" | \"finalATK\" | \"finalDEF\" | \"staminaGlidingDec_\" | \"staminaSprintDec_\" | \"staminaChargedDec_\" | \"autoBoost\" | \"skillBoost\" | \"burstBoost\"\n\nexport type MainStatKey = typeof allMainStatKeys[number]\nexport type SubstatKey = typeof allSubstats[number]\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  return formulas.map(check)\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  return formulas.map(f => check(f, baseContextId))\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n"],"sourceRoot":""}