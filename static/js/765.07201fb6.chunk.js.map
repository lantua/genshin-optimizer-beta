{"version":3,"file":"static/js/765.07201fb6.chunk.js","mappings":"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","sources":["Assets/Assets.ts","Components/Card/CardDark.tsx","Components/Card/CardLight.tsx","Components/CloseButton.tsx","Components/DropdownMenu/DropdownButton.tsx","Components/Image/ImgIcon.tsx","Components/ModalWrapper.tsx","Components/SolidToggleButtonGroup.tsx","Components/SqBadge.tsx","Components/StarDisplay.tsx","Components/StatIcon.tsx","Data/Characters/CharacterSheet.tsx","Data/Characters/dataUtil.tsx","Formula/uiData.tsx","Formula/api.tsx","Formula/index.ts","Formula/internal.ts","Formula/optimization.ts","Formula/reaction.ts","Formula/utils.ts","ReactHooks/useForceUpdate.tsx","ReactHooks/usePromise.tsx"],"sourcesContent":["import bow from './icon_bow.png'\nimport catalyst from './icon_catalyst.png'\nimport claymore from './icon_claymore.png'\nimport polearm from './icon_polearm.png'\nimport sword from './icon_sword.png'\n\nimport fragile from './Item_Fragile_Resin.png'\nimport condensed from './Item_Condensed_Resin.png'\n\n//EXP BOOKS\nimport advice from './Item_Wanderer\\'s_Advice.png'\nimport wit from './Item_Hero\\'s_Wit.png'\nimport experience from './Item_Adventurer\\'s_Experience.png'\n\nconst Assets = {\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\n  resin: {\n    fragile,\n    condensed\n  },\n  exp_books: {\n    advice,\n    wit,\n    experience,\n  }\n};\nexport default Assets;","import { Card, styled } from \"@mui/material\";\n\nconst CardDark = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentDark.main\n}));\n\nexport default CardDark","import { Card, styled } from \"@mui/material\";\n\nconst CardLight = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentLight.main\n}));\n\nexport default CardLight","import { Close } from \"@mui/icons-material\";\nimport { Button, ButtonProps } from \"@mui/material\";\nimport { useTranslation } from \"react-i18next\";\ntype CloseButtonProps = ButtonProps & {\n  large?: boolean\n}\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\n  const { t } = useTranslation(\"ui\")\n  if (large)\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\n    <Close />\n  </Button>\n}","import { KeyboardArrowDown } from \"@mui/icons-material\";\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\nimport { Suspense, useCallback, useState } from \"react\";\n\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\n  title: React.ReactNode,\n  id?: string,\n  children: React.ReactNode\n}\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n  const open = Boolean(anchorEl);\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\n    [setAnchorEl],\n  )\n  const handleClose = useCallback(\n    () => setAnchorEl(null),\n    [setAnchorEl],\n  )\n\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\n    <Button\n      {...props}\n      id={id}\n      aria-controls=\"basic-menu\"\n      aria-haspopup=\"true\"\n      aria-expanded={open ? 'true' : undefined}\n      onClick={handleClick}\n      endIcon={<KeyboardArrowDown />}\n    >\n      {title}\n    </Button>\n    <Menu\n      id=\"basic-menu\"\n      anchorEl={anchorEl}\n      open={open}\n      onClose={handleClose}\n      MenuListProps={{\n        'aria-labelledby': id,\n      }}\n      onClick={handleClose}\n    >\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\n        {children}\n      </Suspense>\n    </Menu>\n  </Suspense>\n}","import { styled } from \"@mui/material\"\ninterface ImgIconProps {\n  size?: number;\n}\nconst ImgIcon = styled(\"img\", {\n  name: 'ImgIcon',\n  slot: 'Root',\n})<ImgIconProps>(({ size = 1 }) => ({\n  display: \"inline-block\",\n  width: \"auto\",\n  height: `${size * 1.2}em`,\n  verticalAlign: \"text-bottom\"\n}))\n\nexport default ImgIcon","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\nimport { Suspense } from \"react\"\nimport CardLight from \"./Card/CardLight\"\n\nconst ScrollModal = styled(Modal)(({ theme }) => ({\n  overflow: \"scroll\",\n  paddingTop: theme.spacing(2),\n  paddingBottom: theme.spacing(2),\n\n}))\nconst ModalContainer = styled(Container)(({ theme }) => ({\n  padding: 0,\n  minHeight: \"100%\",\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"auto\"\n  }\n}))\n\ntype ModalWrapperProps = ModalProps & {\n  containerProps?: ContainerProps\n}\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\n  return <ScrollModal {...props}>\n    <ModalContainer {...containerProps}>\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\n        {children}\n      </Suspense>\n    </ModalContainer>\n  </ScrollModal>\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\n\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\ntype SolidToggleButtonGroupPropsPartial = {\n  baseColor?: ButtonProps[\"color\"];\n  selectedColor?: ButtonProps[\"color\"];\n}\n\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"primary\", selectedColor = \"success\" }) => ({\n  '& .MuiToggleButtonGroup-grouped': {\n    '&': {\n      backgroundColor: theme.palette[baseColor].main,\n      color: theme.palette[baseColor].contrastText,\n    },\n    '&:hover': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected': {\n      backgroundColor: theme.palette[selectedColor].main,\n      color: theme.palette[selectedColor].contrastText,\n    },\n    '&.Mui-selected:hover': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n    '&.Mui-disabled': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected.Mui-disabled': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n  },\n}));\n\nexport default SolidToggleButtonGroup","import { styled } from \"@mui/material\";\n\nconst SqBadge = styled(\"span\", {\n  name: 'SqBadge',\n  slot: 'Root',\n})(({ theme, color = \"primary\" }) => ({\n  display: \"inline-block\",\n  padding: \".25em .4em\",\n  fontSize: \"75%\",\n  fontWeight: 700,\n  lineHeight: 1,\n  textAlign: \"center\",\n  whiteSpace: \"nowrap\",\n  verticalAlign: \"baseline\",\n  borderRadius: \".25em\",\n  backgroundColor: theme.palette[color]?.main,\n  color: theme.palette[color]?.contrastText\n}))\nexport default SqBadge","import { faStar } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Typography } from '@mui/material'\nimport { Rarity } from '../Types/consts'\n\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\n  </Typography>\n\nexport {\n  StarIcon,\n  Stars\n}\n","import { faDiceD20 } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faAnemo, faAtk, faCdReductionPrimary, faCdReductionSecondary, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRechargePrimary, faEnergyRechargeSecondary, faGeo, faHealingBonus, faHpPrimary, faHpSecondary, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\nimport { objectKeyMap } from '../Util/Util'\nimport ColorText from './ColoredText'\n\nexport function HPIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faHpPrimary as any} />\n    <FontAwesomeIcon icon={faHpSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function CdRedIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faCdReductionPrimary as any} />\n    <FontAwesomeIcon icon={faCdReductionSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\n\nexport function EnerRechIcon() {\n  return <span className=\"fa-layers \">\n    <FontAwesomeIcon icon={faEnergyRechargePrimary as any} />\n    <FontAwesomeIcon icon={faEnergyRechargeSecondary as any} style={{ color: \"grey\" }} />\n  </span>\n}\nexport const uncoloredEleIcons = {\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\n} as const\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} >{uncoloredEleIcons[key]}</ColorText>)\n\nconst StatIcon = {\n  characterHP: <HPIcon />,\n  finalHP: <HPIcon />,\n  hp_: <HPIcon />,\n  hp: <HPIcon />,\n\n  baseATK: <FontAwesomeIcon icon={faAtk as any} />,\n  characterATK: <FontAwesomeIcon icon={faAtk as any} />,\n  finalATK: <FontAwesomeIcon icon={faAtk as any} />,\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\n\n  characterDEF: <FontAwesomeIcon icon={faDef as any} />,\n  finalDEF: <FontAwesomeIcon icon={faDef as any} />,\n  def_: <FontAwesomeIcon icon={faDef as any} />,\n  def: <FontAwesomeIcon icon={faDef as any} />,\n\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\n  critDMG_: <FontAwesomeIcon icon={faDiceD20 as any} />,\n  enerRech_: <EnerRechIcon />,\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\n\n  cdRed_: <CdRedIcon />,\n\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\n\n  ...coloredEleIcon,\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [[`${ele}_dmg_`, coloredEleIcon[ele]], [`${ele}_res_`, coloredEleIcon[ele]]]))\n}\n\nexport default StatIcon\n","import ImgIcon from \"../../Components/Image/ImgIcon\";\nimport { ascensionMaxLevel } from \"../LevelData\";\nimport { Data } from \"../../Formula/type\";\nimport { TalentSheet, TalentSheetElement, TalentSheetElementKey } from \"../../Types/character_WR\";\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\nimport SqBadge from \"../../Components/SqBadge\";\nimport Assets from \"../../Assets/Assets\";\nimport IConditional from \"../../Types/IConditional_WR\";\nimport { IFieldDisplay } from \"../../Types/IFieldDisplay_WR\";\n\nconst characterSheets = import('.').then(imp => imp.default)\n\ninterface ICharacterSheetBase {\n  name: Displayable\n  cardImg: string\n  thumbImg: string\n  thumbImgSide: string\n  barImg?: string\n  bannerImg?: string\n  rarity: Rarity\n  weaponTypeKey: WeaponTypeKey\n  gender: string\n  constellationName: Displayable\n  title: Displayable\n}\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\n  elementKey: ElementKey\n  talent: TalentSheet\n}\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\n  talents: Dict<ElementKey, TalentSheet>\n}\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\n\nexport default class CharacterSheet {\n  sheet: ICharacterSheet;\n  data: Data;\n  constructor(charSheet: ICharacterSheet, data: Data) {\n    this.sheet = charSheet\n    this.data = data\n  }\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\n  static get getAll() { return characterSheets }\n  get name() { return this.sheet.name }\n  get nameWIthIcon() { return <span><ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> {this.name}</span> }\n  get cardImg() { return this.sheet.cardImg }\n  get thumbImg() { return this.sheet.thumbImg }\n  get thumbImgSide() { return this.sheet.thumbImgSide }\n  get bannerImg() { return this.sheet.bannerImg }\n  get rarity() { return this.sheet.rarity }\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\n  get constellationName() { return this.sheet.constellationName }\n\n  isMelee = () => {\n    const weaponTypeKey = this.sheet.weaponTypeKey\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\n  }\n  get isTraveler() {\n    return \"talents\" in this.sheet\n  }\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\n    if (\"talent\" in this.sheet) return this.sheet.talent\n    else return this.sheet.talents[eleKey]\n  }\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\n\n  static getLevelString = (level: number, ascension: number): string =>\n    `${level}/${ascensionMaxLevel[ascension]}`\n}\n\nexport const talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, fields?: IFieldDisplay[], conditional?: IConditional): TalentSheetElement => ({\n  name: tr(`${talentKey}.name`),\n  img,\n  sections: [{\n    text: tr(`${talentKey}.description`),\n    fields,\n    conditional,\n  }],\n})\n\nconst talentStrMap: Record<TalentSheetElementKey, string> = {\n  auto: \"Auto\",\n  skill: \"Skill\",\n  burst: \"Burst\",\n  passive: \"Passive\",\n  passive1: \"Ascension 1\",\n  passive2: \"Ascension 4\",\n  passive3: \"Passive\",\n  sprint: \"Sprint\",\n  constellation1: \"C1\",\n  constellation2: \"C2\",\n  constellation3: \"C3\",\n  constellation4: \"C4\",\n  constellation5: \"C5\",\n  constellation6: \"C6\"\n}\nexport const conditionalHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IConditional[\"header\"] => {\n  return {\n    title: tr(`${talentKey}.name`),\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\n    action: <SqBadge color=\"success\">{talentStrMap[talentKey]}</SqBadge>,\n  }\n}\n\nexport const normalSrc = (weaponKey: WeaponTypeKey) => Assets.weaponTypes[weaponKey]\n","import { input } from \"../../Formula\";\nimport { inferInfoMut, mergeData } from \"../../Formula/api\";\nimport { reactions } from \"../../Formula/reaction\";\nimport { Data, DisplaySub, NumNode } from \"../../Formula/type\";\nimport { constant, data, equalStr, infoMut, prod, stringPrio, subscript, sum, unit } from \"../../Formula/utils\";\nimport { allMainStatKeys, allSubstats, MainStatKey } from \"../../Types/artifact\";\nimport { CharacterKey, ElementKey, Region } from \"../../Types/consts\";\nimport { layeredAssignment, objectKeyMap, objectMap } from \"../../Util/Util\";\nimport _charCurves from \"./expCurve_gen.json\";\n\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\n\n// TODO: Remove this conversion after changing the file format\nconst charCurves = objectMap(_charCurves, value => [0, ...Object.values(value)])\n\nconst commonBasic = objectKeyMap([...allSubstats, \"heal_\"], key => input.total[key])\ncommonBasic.critRate_ = input.total.cappedCritRate\n\nconst inferredHitEle = stringPrio(\n  // Inferred Element\n  equalStr(input.weaponType, \"catalyst\", input.charEle),\n  equalStr(input.hit.move, \"skill\", input.charEle),\n  equalStr(input.hit.move, \"burst\", input.charEle),\n  input.infusion,\n  input.team.infusion,\n  \"physical\",\n)\n\nfunction getTalentType(move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\") {\n  switch (move) {\n    case \"normal\": case \"charged\": case \"plunging\": return \"auto\";\n    case \"skill\": return \"skill\";\n    case \"burst\": return \"burst\";\n  }\n}\n\n/** Note: `additional` applies only to this formula */\nexport function customDmgNode(base: NumNode, move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\" | \"elemental\", additional: Data = {}): NumNode {\n  return data(input.hit.dmg, mergeData([{\n    hit: { base, move: constant(move), ele: additional?.hit?.ele ? undefined : inferredHitEle },\n  }, additional]))\n}\n/** Note: `additional` applies only to this formula */\nexport function customShieldNode(base: NumNode, additional?: Data): NumNode {\n  const shieldNode = prod(base, sum(unit, input.total.shield_))\n  return additional ? data(shieldNode, additional) : shieldNode\n}\n/** Note: `additional` applies only to this formula */\nexport function dmgNode(base: MainStatKey, lvlMultiplier: number[], move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\", additional: Data = {}): NumNode {\n  const talentType = getTalentType(move)\n  return customDmgNode(prod(subscript(input.total[`${talentType}Index`], lvlMultiplier, { key: '_' }), input.total[base]), move, additional)\n}\n/** Note: `additional` applies only to this formula */\nexport function shieldNode(base: MainStatKey, percent: NumNode | number, flat: NumNode | number, additional?: Data): NumNode {\n  return customShieldNode(sum(prod(percent, input.total[base]), flat), additional)\n}\n/** Note: `additional` applies only to this formula */\nexport function shieldNodeTalent(base: MainStatKey, baseMultiplier: number[], flat: number[], move: \"normal\" | \"charged\" | \"plunging\" | \"skill\" | \"burst\", additional?: Data): NumNode {\n  const talentType = getTalentType(move)\n  const talentIndex = input.total[`${talentType}Index`]\n  return customShieldNode(sum(\n    prod(subscript(talentIndex, baseMultiplier, { key: '_' }), input.total[base]),\n    subscript(talentIndex, flat)\n  ), additional)\n}\nexport function dataObjForCharacterSheet(\n  key: CharacterKey,\n  element: ElementKey | undefined,\n  region: Region | undefined,\n  gen: {\n    weaponTypeKey: string,\n    base: { hp: number, atk: number, def: number },\n    curves: { [key in string]?: string },\n    ascensions: { props: { [key in string]?: number } }[]\n  },\n  display: { [key: string]: DisplaySub },\n  additional: Data = {},\n): Data {\n  function curve(base: number, lvlCurve: string): NumNode {\n    return prod(base, subscript(input.lvl, charCurves[lvlCurve]))\n  }\n  display.basic = { ...commonBasic }\n  const data: Data = {\n    charKey: constant(key),\n    base: {},\n    weaponType: constant(gen.weaponTypeKey),\n    premod: {},\n    display,\n  }\n  if (element) {\n    data.charEle = constant(element)\n    data.teamBuff = { tally: { [element]: constant(1) } }\n    data.display!.basic[`${element}_dmg_`] = input.total[`${element}_dmg_`]\n    data.display!.reaction = reactions[element]\n  }\n  if (region)\n    layeredAssignment(data, [\"teamBuff\", \"tally\", region], constant(1))\n  if (gen.weaponTypeKey !== \"catalyst\") {\n    if (!data.display!.basic) data.display!.basic = {}\n    data.display!.basic!.physical_dmg_ = input.total.physical_dmg_\n  }\n\n  let foundSpecial: boolean | undefined\n  for (const stat of [...allMainStatKeys, \"def\" as const]) {\n    const list: NumNode[] = []\n    if (gen.curves[stat])\n      list.push(curve(gen.base[stat], gen.curves[stat]!))\n    const asc = gen.ascensions.some(x => x.props[stat])\n    if (asc)\n      list.push(subscript(input.asc, gen.ascensions.map(x => x.props[stat] ?? NaN)))\n\n    if (!list.length) continue\n\n    const result = infoMut(list.length === 1 ? list[0] : sum(...list), { key: stat, prefix: \"char\", asConst: true })\n    if (stat.endsWith(\"_dmg_\")) result.info!.variant = stat.slice(0, -5) as any\n    if (stat === \"atk\" || stat === \"def\" || stat === \"hp\")\n      data.base![stat] = result\n    else {\n      if (foundSpecial) throw new Error(\"Duplicated Char Special\")\n      foundSpecial = true\n      data.special = result\n      data.premod![stat] = input.special\n    }\n  }\n\n  return mergeData([data, inferInfoMut(additional)])\n}\n","import { uiInput } from \".\"\nimport ColorText from \"../Components/ColoredText\"\nimport KeyMap, { KeyMapPrefix, Unit, valueString } from \"../KeyMap\"\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\nimport { allOperations } from \"./optimization\"\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\n\nconst shouldWrap = true\nexport interface NodeDisplay<V = number> {\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\n  operation: true\n  prefix?: KeyMapPrefix\n  key?: string\n  value: V\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\n  isEmpty: boolean\n  unit: Unit\n  variant?: Variant\n  formula?: Displayable\n  formulas: Displayable[]\n}\n\nexport class UIData {\n  origin: UIData\n  children = new Map<Data, UIData>()\n\n  data: Data[]\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\n\n  display: any = undefined\n  teamBuff: any = undefined\n\n  constructor(data: Data, parent: UIData | undefined) {\n    if (data === undefined) {\n      // Secret *origin* initializer\n      this.data = []\n      this.origin = this\n    } else {\n      if (!parent)\n        parent = new UIData(undefined as any, undefined)\n\n      this.data = [data, ...parent.data]\n      this.origin = parent.origin\n    }\n  }\n\n  getDisplay(): {\n    [key: string]: DisplaySub<NodeDisplay>\n  } {\n    if (!this.display) this.display = this.getAll([\"display\"])\n    return this.display\n  }\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\n    if (!this.teamBuff) {\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\n      // Convert `input` to `uiInput`\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\n        if (node) layeredAssignment(result, path, node)\n      })\n      this.teamBuff = result\n    }\n    return this.teamBuff\n  }\n  getAll(prefix: string[]): any {\n    const result = {}\n    for (const data of this.data) {\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\n    }\n    return result\n  }\n  get(node: NumNode): NodeDisplay\n  get(node: StrNode): NodeDisplay<string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\n    if (node === undefined) {\n      console.trace(\"Please report this bug with this trace\")\n      return { operation: true, value: undefined, isEmpty: true, unit: \"flat\", formulas: [] }\n    }\n    const old = this.processed.get(node)\n    if (old) return old\n\n    const result = computeNodeDisplay(this.computeNode(node))\n    this.processed.set(node, result)\n    return result\n  }\n  private computeNode(node: NumNode): ContextNodeDisplay\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\n    const old = this.nodes.get(node)\n    if (old) return old\n\n    const { operation, info } = node\n    let result: ContextNodeDisplay<number | string | undefined>\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        result = this._compute(node); break\n      case \"threshold\": result = this._threshold(node); break\n      case \"const\": result = this._constant(node.value); break\n      case \"subscript\": result = this._subscript(node); break\n      case \"read\": result = this._read(node); break\n      case \"data\": result = this._data(node); break\n      case \"match\": result = this._match(node); break\n      case \"lookup\": result = this._lookup(node); break\n      case \"prio\": result = this._prio(node.operands); break\n      default: assertUnreachable(operation)\n    }\n\n    if (info) {\n      const { key, prefix, source, variant, asConst } = info\n      let { pivot } = info\n      result = { ...result }\n\n      // Pivot all keyed nodes for debugging\n      // if (key) pivot = true\n\n      if (key) result.key = key\n      if (prefix) result.prefix = prefix\n      if (source) result.source = source\n      if (variant) result.variant = variant\n      if (pivot) result.pivot = pivot\n\n      if (asConst) {\n        delete result.formula\n        delete result.assignment\n        result.dependencies = new Set()\n      }\n      if (result.pivot || !result.formula)\n        result.mayNeedWrapping = false\n    }\n    createDisplay(result)\n\n    this.nodes.set(node, result)\n    return result\n  }\n\n  private prereadAll(path: readonly string[]): (NumNode | StrNode)[] {\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x)\n  }\n  private readAll(path: readonly string[]): ContextNodeDisplay<number | string | undefined>[] {\n    return this.prereadAll(path).map(x => this.computeNode(x))\n  }\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\n    return data && this.computeNode(data)\n  }\n\n  private _prio(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\n    const first = nodes.find(node => this.computeNode(node).value !== undefined)\n    return first ? this.computeNode(first) : illformedStr\n  }\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\n    const { path } = node\n    const result = (node.accu === undefined)\n      ? this.readFirst(path) ?? (node.type === \"string\" ? illformedStr : illformed)\n      : node.accu === \"prio\"\n        ? this._prio(this.prereadAll(path) as StrNode[])\n        : this._accumulate(node.accu, this.readAll(path) as ContextNodeDisplay[])\n    return result\n  }\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const key = this.computeNode(node.operands[0]).value\n    const selected = node.table[key!] ?? node.operands[1]\n    if (!selected)\n      throw new Error(`Lookup Fail with key ${key}`)\n    return this.computeNode(selected)\n  }\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\n    const matching = v1.value === v2.value\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\n      ? makeEmpty(result.value) : result\n  }\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const [valueNode, thresholdNode, pass, fail] = node.operands\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\n    return (value.value >= threshold.value)\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\n  }\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    let child = this.children.get(node.data)\n    if (!child) {\n      child = new UIData(node.data, node.reset ? this.origin : this)\n      this.children.set(node.data, child)\n    }\n    return child.computeNode(node.operands[0])\n  }\n  private _compute(node: ComputeNode): ContextNodeDisplay {\n    const { operation, operands } = node\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\n  }\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\n    const operand = this.computeNode(node.operands[0])\n    const value = node.list[operand.value] ?? NaN\n    return this._constant(value)\n  }\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\n    return {\n      value, pivot: false,\n      empty: false,\n      mayNeedWrapping: false,\n      dependencies: new Set(),\n    }\n  }\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\n    let variant: Variant | undefined\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        variant = mergeVariants(operands); break\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n        const identity = allOperations[operation]([])\n        if (process.env.NODE_ENV !== \"development\")\n          operands = operands.filter(operand => operand.value !== identity)\n        if (!operands.length)\n          return variant ? { ...this._constant(identity), variant } : this._constant(identity)\n    }\n\n    let formula: { display: Displayable, dependencies: Displayable[] }\n    let mayNeedWrapping = false\n    switch (operation) {\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap }}`; break\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\n      case \"res\": {\n        const base = operands[0].value\n        if (base < 0) {\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\n          mayNeedWrapping = true\n        }\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\n        else {\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\n          mayNeedWrapping = true\n        }\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\":\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\n        else if (operation === \"add\") mayNeedWrapping = true\n    }\n\n    const value = allOperations[operation](operands.map(x => x.value))\n    const dependencies = new Set([...operands.flatMap(x =>\n      x.pivot && x.assignment\n        ? [x.assignment, ...x.dependencies]\n        : [...x.dependencies])])\n    const result: ContextNodeDisplay = {\n      formula: formula.display,\n      empty: operands.every(x => x.empty),\n      value, mayNeedWrapping,\n      pivot: false, dependencies,\n    }\n    if (variant) result.variant = variant\n    return result\n  }\n}\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\n  const dependencies = new Set<Displayable>()\n  const predisplay: Displayable[] = []\n\n  strings.forEach((string, i) => {\n    predisplay.push(string)\n\n    const key = list[i]\n    if (key) {\n      const { operands, shouldWrap, separator = \", \" } = key\n      operands.forEach((item, i, array) => {\n        let itemFormula: Displayable\n        if (!item.pivot && item.formula) itemFormula = item.formula\n        else itemFormula = createFormulaComponent(item)\n\n        if (shouldWrap && item.mayNeedWrapping) {\n          predisplay.push(\"( \")\n          predisplay.push(itemFormula)\n          predisplay.push(\" )\")\n        } else {\n          predisplay.push(itemFormula)\n        }\n        if (i + 1 < array.length) predisplay.push(separator)\n        item.dependencies.forEach(x => dependencies.add(x))\n      })\n    }\n  })\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\n}\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): ContextNodeDisplay<V>[\"variant\"] {\n  const unique = new Set(operands.map(x => x.variant))\n  if (unique.size > 1) unique.delete(undefined)\n  if (unique.size > 1) unique.delete(\"physical\")\n  return unique.values().next().value\n}\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\n  const { key, prefix, dependencies, value, variant, formula, assignment, empty } = node\n  return {\n    operation: true,\n    key, value, variant, prefix,\n    isEmpty: empty,\n    unit: (key && KeyMap.unit(key)) || \"flat\",\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\n  }\n}\n\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, key ? KeyMap.unit(key) : \"flat\")}</ColorText>\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.getNoUnit(key!)}</ColorText>{sourceDisplay}</>\n\n    if (formula)\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  //TODO: change formula size in the formula display element instead\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\n}\n/*/\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { key, value, formula, prefix, source, variant } = node\n  if (typeof value !== \"number\") return\n  node.valueDisplay = valueString(value, key ? KeyMap.unit(key) : \"flat\")\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? ` ${source}` : \"\"\n    node.name = `${prefixDisplay}${KeyMap.getNoUnit(key!)}${sourceDisplay}`\n\n    if (formula)\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return (components as string[]).join(\"\")\n}\n//*/\n\ninterface ContextNodeDisplay<V = number> {\n  key?: Info[\"key\"]\n  prefix?: Info[\"prefix\"]\n  source?: Info[\"source\"]\n  variant?: Info[\"variant\"]\n\n  pivot: boolean\n  empty: boolean\n\n  value: V\n\n  dependencies: Set<Displayable>\n\n  mayNeedWrapping: boolean\n\n  // Don't set these manually outside of `UIData.computeNode`\n  name?: Displayable\n  valueDisplay?: Displayable\n  formula?: Displayable\n  assignment?: Displayable\n}\n\nconst illformed: ContextNodeDisplay = {\n  value: NaN, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nconst illformedStr: ContextNodeDisplay<string | undefined> = {\n  value: undefined, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\n  return {\n    value: emptyValue, pivot: false, empty: true, dependencies: new Set(), mayNeedWrapping: false\n  }\n}\n","import Artifact from \"../Data/Artifacts/Artifact\";\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\nimport { ICachedCharacter } from \"../Types/character_WR\";\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\nimport { ICachedWeapon } from \"../Types/weapon\";\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { reactions } from \"./reaction\";\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\nimport { NodeDisplay, UIData } from \"./uiData\";\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\n\nconst asConst = true as const, pivot = true as const\n\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\n    if (path[0] === \"teamBuff\") path = path.slice(1)\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\n    if (reference)\n      x.info = { ...reference.info, prefix: undefined, source }\n    else if (path[0] !== \"tally\")\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\n  })\n\n  return data\n}\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\n  stats.push([art.mainStatKey, mainStatVal])\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\n  return {\n    art: {\n      ...Object.fromEntries(stats.map(([key, value]) =>\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\n      [art.slotKey]: {\n        id: constant(art.id), set: constant(art.setKey)\n      },\n    },\n    artSet: {\n      [art.setKey]: constant(1)\n    }\n  }\n}\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\n  const result: Data = {\n    lvl: constant(char.level),\n    constellation: constant(char.constellation),\n    asc: constant(char.ascension),\n\n    premod: {\n      auto: constant(char.talent.auto),\n      skill: constant(char.talent.skill),\n      burst: constant(char.talent.burst),\n    },\n    enemy: {\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\n    },\n    hit: {\n      hitMode: constant(char.hitMode)\n    },\n    customBonus: {},\n  }\n\n  for (const [key, value] of Object.entries(char.bonusStats))\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\n\n  if (char.enemyOverride.enemyDefRed_)\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_)\n  if (char.enemyOverride.enemyDefIgn_)\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_)\n  if (char.elementKey) {\n    result.charEle = constant(char.elementKey)\n    result.display = {\n      basic: { [`${char.elementKey}_dmg_`]: input.total[`${char.elementKey}_dmg_`] },\n      reaction: reactions[char.elementKey]\n    }\n    layeredAssignment(result, [\"teamBuff\", \"tally\", char.elementKey], constant(1))\n  }\n\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\n    layeredAssignment(result, keys, constant(x)))\n  return result\n}\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\n  return {\n    weapon: {\n      lvl: constant(weapon.level),\n      asc: constant(weapon.ascension),\n      refinement: constant(weapon.refinement),\n      refineIndex: constant(weapon.refinement - 1)\n    },\n  }\n}\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\n  // May the goddess of wisdom bless any and all souls courageous\n  // enough to attempt for the understanding of this abomination.\n\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\n  const result = Object.fromEntries(mergedData.map(([key]) =>\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\n\n  const customReadNodes = {}\n  function getReadNode(path: readonly string[]): ReadNode<number> {\n    const base = (path[0] === \"teamBuff\")\n      ? objPathValue(teamBuff, path.slice(1))\n      : objPathValue(input, path)\n    if (base) return base\n    const custom = objPathValue(customReadNodes, path)\n    if (custom) return custom\n    const newNode = customRead(path)\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\n    layeredAssignment(customReadNodes, path, newNode)\n    return newNode\n  }\n\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\n    mergedData.forEach(([sourceKey, source]) => {\n      const sourceBuff = source.teamBuff\n      // Create new copy of `calc` as we're mutating it later\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\n      buffs.push(buff)\n      calcs[sourceKey] = calc\n\n      // This construction creates a `Data` representing buff\n      // from `source` applying to `target`. It has 3 data:\n      // - `target` contains the reference for the final\n      //   data. It is not populated at this stage,\n      // - `calc` contains the calculation of the buffs,\n      // - `buff` contains read nodes that point to the\n      //   calculation in `calc`.\n\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\n\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\n\n          let readNode: ReadNode<number | string> | undefined, data: Data\n          if (x.path[0] === \"target\") { // Link the node to target data\n            readNode = getReadNode(x.path.slice(1))\n            data = targetRef\n          } else { // Link the node to source data\n            readNode = x\n            data = result[sourceKey].targetRef\n          }\n          layeredAssignment(calc, x.path, resetData(readNode, data))\n        })\n      })\n    })\n  )\n  mergedData.forEach(([targetKey, data]) => {\n    delete data.teamBuff\n    const { targetRef, buffs } = result[targetKey]\n    const buff = mergeData(buffs)\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\n      // CAUTION\n      // This is safe only because `buff` is created using only `resetData`\n      // and `mergeData`. So every node here is created from either of the\n      // two functions, so the mutation wont't affect existing nodes.\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\n    })\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\n    targetRef[\"target\"] = targetRef\n  })\n  const origin = new UIData(undefined as any, undefined)\n  const uiDataResult = Object.fromEntries(Object.entries(result).map(([key, value]) =>\n    [key, {\n      target: new UIData(value.targetRef, origin),\n      buff: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\n        [key, new UIData(value, origin)]))\n    }]))\n  return uiDataResult\n}\nfunction mergeData(data: Data[]): Data {\n  function internal(data: any[], path: string[]): any {\n    if (data.length <= 1) return data[0]\n    if (data[0].operation) {\n      if (path[0] === \"teamBuff\") path = path.slice(1)\n      const accu = path[0] === \"tally\"\n        ? \"add\" : (objPathValue(input, path) as ReadNode<number> | undefined)?.accu\n      if (accu === undefined) {\n        if (data.length !== 1)\n          throw new Error(`Multiple entries when merging \\`unique\\` for key ${path}`)\n        return data[0]\n      }\n      const result: NumNode = { operation: accu, operands: data }\n      return result\n    } else {\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\n    }\n  }\n  return data.length ? internal(data, []) : {}\n}\n\nfunction computeUIData(data: Data[]): UIData {\n  return new UIData(mergeData(data), undefined)\n}\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\n}\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\n}\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\n  if (data1?.operation || data2?.operation) {\n    const d1 = data1 as NodeDisplay | undefined\n    const d2 = data2 as NodeDisplay | undefined\n\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\n      throw new Error(\"Unmatched structure when comparing UIData\")\n\n    const result: ComparedNodeDisplay = {\n      operation: true,\n      value: 0,\n      isEmpty: true,\n      unit: d2?.unit!,\n      formulas: [],\n      ...d1,\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\n    }\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\n      // In case `string` got involved, just use the other value\n      result.value = d1?.value ?? \"\" as any\n      result.diff = d2?.value ?? \"\" as any\n    }\n    return result\n  }\n\n  if (data1 || data2) {\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\n  }\n}\n\nexport type { NodeDisplay, UIData };\nexport {\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\n  mergeData, computeUIData, inferInfoMut,\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\n};\n","import { allEleEnemyResKeys } from \"../KeyMap\"\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\nimport { constant, equalStr, frac, infoMut, lookup, max, min, naught, percent, prod, read, res, setReadNodeKeys, stringRead, sum, unit } from \"./utils\"\n\nconst asConst = true as const, pivot = true as const\n\nconst allElements = allElementsWithPhy\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\", \"elemental\"] as const\nconst allArtModStats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\"] as const\nconst allArtNonModStats = [\"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"heal_\"] as const\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\nconst allMisc = [\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\", \"dmgRed_\"\n] as const\n\nconst allModStats = [\n  ...allArtModStats,\n  ...([\"all\", \"burning\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\n]\nconst allNonModStats = [\n  ...allArtNonModStats,\n  ...([\"all\", ...allMoves] as const).map(x => `${x}_dmgInc` as const),\n  ...([...allElements] as const).map(x => `${x}_critDMG_` as const),\n  ...allElements.map(x => `${x}_res_` as const),\n  ...allMoves.map(x => `${x}_critRate_` as const),\n  ...allEleEnemyResKeys,\n  \"enemyDefRed_\" as const,\n  ...allMisc,\n]\n\nconst talent = objectKeyMap(allTalents, _ => read())\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\n\nfor (const ele of allElements) {\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_dmg_`].info!.variant = ele\n}\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\n  allModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\n}\n\nfunction withDefaultInfo<T>(info: Info, value: T): T {\n  value = deepClone(value)\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\n  return value\n}\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\n  })\n}\n\n/** All read nodes */\nconst input = setReadNodeKeys(deepClone({\n  activeCharKey: stringRead(),\n  charKey: stringRead(), charEle: stringRead(), infusion: stringRead(), weaponType: stringRead(),\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\n\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\n    ...allModStatNodes, ...allNonModStatNodes,\n  }),\n  bonus: { ...talent },\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\n    ...allModStatNodes, ...allNonModStatNodes,\n    /** Total Crit Rate capped to [0%, 100%] */\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\n  }),\n\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\n    ...objectKeyMap(allArtModStats, key => allModStatNodes[key]),\n    ...objectKeyMap(allArtNonModStats, key => allNonModStatNodes[key]),\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\n  }),\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\n\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\n    key: stringRead(), type: stringRead(),\n\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\n    main: read(), sub: read(), sub2: read(),\n  }),\n\n  team: { infusion: stringRead(\"prio\") },\n\n  enemy: {\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\n\n    level: read(undefined, { key: \"enemyLevel\" }),\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\n    defRed: read(undefined),\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\n  },\n\n  hit: {\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\n    base: read(\"add\", { key: \"base\" }),\n\n    dmgBonus: read(undefined, { key: \"dmg_\", pivot }),\n    dmgInc: read(undefined, { key: \"dmgInc\", pivot }),\n    dmg: read(),\n  },\n}))\n\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\n\n// Adjust `info` for printing\nmarkAccu('add', {\n  bonus, customBonus, premod, art,\n  total: objectKeyMap(allModStats, stat => total[stat]),\n})\nbonus.auto.info = { key: \"autoBoost\" }\nbonus.skill.info = { key: \"skillBoost\" }\nbonus.burst.info = { key: \"burstBoost\" }\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\ndelete total.critRate_.info!.pivot\ntotal.critRate_.info!.prefix = \"uncapped\"\n\n// Nodes that are not used anywhere else but `common` below\n\n/** Base Amplifying Bonus */\nconst baseAmpBonus = sum(unit, prod(25 / 9, frac(total.eleMas, 1400)))\n/** Effective reaction, taking into account the hit's element */\nexport const effectiveReaction = lookup(hit.ele, {\n  pyro: lookup(hit.reaction, { vaporize: constant(\"vaporize\"), melt: constant(\"melt\") }, undefined),\n  hydro: equalStr(hit.reaction, \"vaporize\", \"vaporize\"),\n  cryo: equalStr(hit.reaction, \"melt\", \"melt\"),\n}, undefined)\n\nconst common: Data = {\n  premod: {\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\n    ...objectKeyMap([...allModStats, ...allArtNonModStats] as const, key => {\n      const operands: NumNode[] = []\n      switch (key) {\n        case \"atk\": case \"def\": case \"hp\":\n          operands.push(prod(base[key], sum(unit, premod[`${key}_`])))\n          break\n        case \"critRate_\":\n          operands.push(percent(0.05, { key, prefix: \"default\" }),\n            lookup(hit.move, objectKeyMap(allMoves, move => customBonus[`${move}_critRate_`]), 0))\n          break\n        case \"critDMG_\":\n          operands.push(percent(0.5, { key, prefix: \"default\" }),\n            lookup(hit.ele, objectKeyMap(allElements, ele => customBonus[`${ele}_critDMG_`]), 0))\n          break\n        case \"enerRech_\":\n          operands.push(percent(1, { key, prefix: \"default\" }))\n          break\n      }\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\n    }),\n  },\n  total: {\n    ...objectKeyMap(allTalents, talent => premod[talent]),\n    ...objectKeyMap(allModStats, key => premod[key]),\n    ...objectKeyMap(allNonModStats, key => premod[key]),\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\n\n    cappedCritRate: max(min(total.critRate_, unit), naught),\n  },\n\n  hit: {\n    dmgBonus: sum(\n      total.all_dmg_,\n      lookup(effectiveReaction, objectKeyMap(allAmplifying, reaction => total[`${reaction}_dmg_`]), naught),\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\n    ),\n    dmgInc: sum(\n      total.all_dmgInc,\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\n    ),\n    dmg: prod(\n      sum(hit.base, hit.dmgInc),\n      sum(unit, hit.dmgBonus),\n      lookup(hit.hitMode, {\n        hit: unit,\n        critHit: sum(unit, total.critDMG_),\n        avgHit: sum(unit, prod(total.cappedCritRate, total.critDMG_)),\n      }, NaN),\n      enemy.def,\n      lookup(hit.ele,\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\n      lookup(effectiveReaction, {\n        melt: lookup(hit.ele, {\n          pyro: prod(2, baseAmpBonus),\n          cryo: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"melt_dmg_\" }),\n        vaporize: lookup(hit.ele, {\n          hydro: prod(2, baseAmpBonus),\n          pyro: prod(1.5, baseAmpBonus),\n        }, 1, { key: \"vaporize_dmg_\" }),\n      }, 1),\n    ),\n  },\n\n  enemy: {\n    // TODO: shred cap of 90%\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(unit, prod(-1, enemy.defRed)), sum(unit, prod(-1, enemy.defIgn)))),\n    defRed: total.enemyDefRed_,\n    ...objectKeyValueMap(allElements, ele =>\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\n  },\n}\n\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\nconst tally = setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"])\n\n/**\n * List of `input` nodes, rearranged to conform to the needs of the\n * UI code. This is a separate list so that the evolution of the UIs\n * does not rely on the structure of `input`. So the UI code can rearrange\n * nodes as it sees fit without requiring updates to data sheets, which\n * pertains ~90% of all `input`-related code, and so are very sensitive\n * to any changes to `input`. For zero overhead, use the nodes directly\n * from `input` instead of a copy.\n */\nconst uiInput = input\n\nexport {\n  input, uiInput, common, customBonus,\n\n  target, tally,\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        if (!first)\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = fold(first, context)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"prio\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined)\n          result = fold(operands[0], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { absorbableEle } from \"../Data/Characters/dataUtil\";\nimport { crystallizeLevelMultipliers, transformativeReactionLevelMultipliers, transformativeReactions } from \"../StatConstants\";\nimport { objectKeyMap } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { frac, infoMut, percent, prod, subscript, sum, unit } from \"./utils\";\n\nconst asConst = true as const\n\nconst crystallizeMulti1 = subscript(input.lvl, crystallizeLevelMultipliers)\nconst crystallizeElemas = prod(4000 / 9, frac(input.total.eleMas, 1400))\nconst crystallizeHit = infoMut(prod(sum(unit, /** + Crystallize bonus */ crystallizeElemas), crystallizeMulti1), { key: \"crystallize\", variant: \"geo\" })\n\nconst transMulti1 = subscript(input.lvl, transformativeReactionLevelMultipliers)\nconst transMulti2 = prod(16, frac(input.total.eleMas, 2000))\nconst trans = {\n  ...objectKeyMap([\"overloaded\", \"electrocharged\", \"superconduct\", \"shattered\"] as const, reaction => {\n    const { multi, variants: [ele] } = transformativeReactions[reaction]\n    return infoMut(prod(\n      infoMut(prod(multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total[`${reaction}_dmg_`]),\n      input.enemy[`${ele}_resMulti`]),\n      { key: `${reaction}_hit`, variant: reaction })\n  }),\n  swirl: objectKeyMap(transformativeReactions.swirl.variants, ele => infoMut(\n    prod(\n      infoMut(prod(transformativeReactions.swirl.multi, transMulti1), { asConst }),\n      sum(unit, transMulti2, input.total.swirl_dmg_),\n      input.enemy[`${ele}_resMulti`]),\n    { key: `${ele}_swirl_hit`, variant: ele }))\n}\nexport const reactions = {\n  anemo: {\n    electroSwirl: trans.swirl.electro,\n    pyroSwirl: trans.swirl.pyro,\n    cryoSwirl: trans.swirl.cryo,\n    hydroSwirl: trans.swirl.hydro,\n    shattered: trans.shattered,\n  },\n  geo: {\n    crystallize: crystallizeHit,\n    ...Object.fromEntries(absorbableEle.map(e => [`${e}Crystallize`,\n    infoMut(prod(percent(2.5), crystallizeHit), { key: `${e}_crystallize`, variant: e })])),\n    shattered: trans.shattered,\n  },\n  electro: {\n    overloaded: trans.overloaded,\n    electrocharged: trans.electrocharged,\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n  hydro: {\n    electrocharged: trans.electrocharged,\n    shattered: trans.shattered,\n  },\n  pyro: {\n    overloaded: trans.overloaded,\n    shattered: trans.shattered,\n  },\n  cryo: {\n    superconduct: trans.superconduct,\n    shattered: trans.shattered,\n  },\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const unit = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/*\n * Deprecated\n */\n\n/**\n * value >= threshold ? value : emptyValue\n * @deprecated Use `greaterEq`, `lessEq`, or `greaterEqStr` instead\n */\nexport function threshold(value: Num, threshold: Num, pass: Str, fail: Str, info?: Info): StrNode\nexport function threshold(value: Num, threshold: Num, pass: Num, fail: Num, info?: Info): NumNode\nexport function threshold(value: Num, threshold: Num, pass: Num | Str, fail: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(value), intoV(threshold), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n/**\n * value >= threshold ? addition : 0\n * @deprecated Use `greaterEq` or `lessEq` instead\n */\nexport function threshold_add(value: Num, thres: Num, addition: Num, info?: Info): NumNode {\n  return threshold(value, thres, addition, 0, info)\n}\n\n/**\n * `v1` === `v2` ? `match` : 0\n * @deprecated Use `equal` instead\n */\nexport function match(v1: Str, v2: Str, match: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/**\n * `v1` === `v2` ? 0 : `unmatch`\n * @deprecated Use `unequal` instead\n */\nexport function unmatch(v1: Str, v2: Str, unmatch: Num, info?: Info): NumNode {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(unmatch)], info, emptyOn: \"match\" }\n}\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n","import { useCallback, useState } from \"react\"\n\nexport default function useForceUpdate(): [object, () => void] {\n  const [stateDirty, update] = useState({})\n  const forceUpdateHook = useCallback(() => update({}), [])\n  return [stateDirty, forceUpdateHook]\n}","import { useEffect, useState } from \"react\";\n\nexport default function usePromise<T>(promise: Promise<T> | undefined, dependencies: any[]): T | undefined {\n  const [res, setRes] = useState<T | undefined>(undefined);\n  useEffect(() => {\n    let pending = true\n    promise?.then(res => pending && setRes(() => res), console.error) ?? setRes(undefined)\n    return () => {\n      pending = false\n      setRes(undefined)\n    }\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\n  return res\n}"],"names":["Assets","weaponTypes","bow","catalyst","claymore","polearm","sword","resin","fragile","condensed","exp_books","advice","wit","experience","CardDark","styled","Card","backgroundColor","theme","palette","contentDark","main","CardLight","contentLight","CloseButton","large","props","t","useTranslation","color","startIcon","sx","p","minWidth","DropdownButton","title","children","id","useState","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","Suspense","fallback","endIcon","width","undefined","onClick","onClose","MenuListProps","height","ImgIcon","name","slot","size","display","verticalAlign","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","padding","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","variant","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","contrastText","dark","SqBadge","fontSize","fontWeight","lineHeight","textAlign","whiteSpace","borderRadius","StarIcon","icon","faStar","Stars","stars","colored","component","Array","keys","map","_","i","HPIcon","className","faHpPrimary","faHpSecondary","style","CdRedIcon","faCdReductionPrimary","faCdReductionSecondary","EnerRechIcon","faEnergyRechargePrimary","faEnergyRechargeSecondary","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","hydro","faHydro","pyro","faPyro","cryo","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","objectKeyMap","Object","key","StatIcon","characterHP","finalHP","hp_","hp","baseATK","faAtk","characterATK","finalATK","atk_","atk","characterDEF","faDef","finalDEF","def_","def","eleMas","faElementalMastery","critRate_","faCritRate","critDMG_","faDiceD20","enerRech_","heal_","faHealingBonus","cdRed_","shield_","faShieldStrength","stamina","faMaxStamina","fromEntries","flatMap","ele","characterSheets","then","imp","default","CharacterSheet","charSheet","data","sheet","isMelee","weaponTypeKey","getTalent","eleKey","talent","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","charKey","c","getLevelString","level","ascension","ascensionMaxLevel","talentTemplate","tr","img","fields","conditional","sections","text","talentStrMap","auto","skill","burst","passive","passive1","passive2","passive3","sprint","constellation1","constellation2","constellation3","constellation4","constellation5","constellation6","conditionalHeader","m","action","normalSrc","weaponKey","absorbableEle","charCurves","objectMap","_charCurves","value","values","commonBasic","allSubstats","input","inferredHitEle","stringPrio","equalStr","getTalentType","move","customDmgNode","base","additional","mergeData","hit","constant","customShieldNode","shieldNode","prod","sum","unit","dmgNode","lvlMultiplier","talentType","subscript","shieldNodeTalent","baseMultiplier","flat","talentIndex","dataObjForCharacterSheet","element","region","gen","curve","lvlCurve","basic","foundSpecial","weaponType","premod","charEle","teamBuff","tally","reaction","reactions","layeredAssignment","physical_dmg_","stat","list","curves","push","ascensions","some","x","NaN","length","result","infoMut","prefix","asConst","endsWith","info","slice","Error","special","allMainStatKeys","inferInfoMut","shouldWrap","UIData","parent","origin","Map","nodes","processed","getAll","calculated","crawlObject","uiInput","operation","path","node","objPathValue","console","trace","isEmpty","formulas","old","dependencies","formula","assignment","empty","KeyMap","computeNodeDisplay","computeNode","set","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","_prio","operands","assertUnreachable","source","pivot","Set","mayNeedWrapping","valueDisplay","valueString","prefixDisplay","sourceDisplay","createDisplay","filter","prereadAll","find","first","illformedStr","accu","readFirst","type","illformed","_accumulate","readAll","selected","table","v1Node","v2Node","matchNode","unmatchNode","v1","v2","matching","emptyOn","makeEmpty","valueNode","thresholdNode","pass","fail","threshold","child","reset","operand","unique","delete","next","mergeVariants","identity","allOperations","fStr","separator","every","strings","predisplay","forEach","string","item","array","itemFormula","createFormulaComponent","add","mergeFormulaComponents","components","emptyValue","reference","error","dataObjForArtifact","art","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatKey","Math","max","min","stats","substats","accurateValue","percent","slotKey","setKey","artSet","dataObjForCharacter","char","lvl","constellation","asc","enemy","allElementsWithPhy","enemyOverride","enemyLevel","hitMode","customBonus","entries","bonusStats","enemyDefRed_","enemyDefIgn_","defIgn","dataObjForWeapon","weapon","refinement","refineIndex","setReadNodeKeys","deepClone","uiDataForTeam","teamData","activeCharKey","mergedData","targetRef","buffs","calcs","customReadNodes","getReadNode","custom","newNode","customRead","sourceKey","sourceBuff","buff","calc","resetData","readNode","targetKey","assign","target","internal","computeUIData","allElements","allTalents","allMoves","allArtModStats","allArtNonModStats","allTransformative","allAmplifying","allModStats","allNonModStats","allEleEnemyResKeys","read","allModStatNodes","allNonModStatNodes","withDefaultInfo","stringRead","infusion","bonus","total","objectKeyValueMap","cappedCritRate","allSlotKeys","allArtifactSets","sub","sub2","team","defRed","dmgBonus","dmgInc","dmg","baseAmpBonus","frac","effectiveReaction","lookup","vaporize","melt","common","naught","all_dmg_","all_dmgInc","critHit","avgHit","res","allRegions","forEachNodes","topDown","bottomUp","visiting","visited","traverse","has","mapFormulas","topDownMap","bottomUpMap","topDownMapped","bottomUpMapped","check","arrayEqual","a","b","allCommutativeMonoidOperations","reduce","mul","sum_frac","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","f","flattened","dep","elementCounts","wrap","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","nextContextMap","fold","context","numericOperands","formulaOperands","folded","numericValue","isFinite","index","op","match","unmatch","nextContext","crystallizeMulti1","crystallizeLevelMultipliers","crystallizeElemas","crystallizeHit","transMulti1","transformativeReactionLevelMultipliers","transMulti2","trans","transformativeReactions","multi","variants","swirl","electroSwirl","pyroSwirl","cryoSwirl","hydroSwirl","shattered","crystallize","e","overloaded","electrocharged","superconduct","Number","MAX_VALUE","Infinity","defaultV","intoV","intoOps","equal","unequal","greaterEq","greaterEqStr","lessThan","nodeList","customStringRead","matchFull","useForceUpdate","stateDirty","update","usePromise","promise","setRes","useEffect","pending"],"sourceRoot":""}