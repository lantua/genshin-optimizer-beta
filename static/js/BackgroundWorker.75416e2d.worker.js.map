{"version":3,"file":"static/js/BackgroundWorker.75416e2d.worker.js","mappings":"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A,OACA,QACA,SACA,OACA,YACA,cACA,OACA,OACA,YACA,SACA,OACA,QACA,UACA,YACA,eACA,QACA,YACA,OACA,UACA,SACA,UACA,SACA,OACA,kBACA,gBACA,OACA,SACA,UACA,OACA,oBACA,QACA,QACA,cACA,UACA,SACA,UACA,gBACA,QACA,kBACA,SACA,OACA,aAwBWC,GAtBqB,UAC7BD,EAD6B,CAEhC,aAoBuB,UAZI,CAC3B,iBACA,eACA,mBACA,mBAE2B,CAC3B,iBACA,eACA,mBACA,qBAM2B,UACxBA,EADwB,EAExBC,IAoKqB,UAjKQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,eACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,eACA,+BCoDeC,GAAAA,EAAAA,IAAAA,KAoBAC,GA3TjB,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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/SplitWorker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nexport default function _regeneratorRuntime() {\n  \"use strict\";\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  };\n\n  var exports = {},\n      Op = Object.prototype,\n      hasOwn = Op.hasOwnProperty,\n      $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n      iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n      asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n      toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n        generator = Object.create(protoGenerator.prototype),\n        context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n      NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n            value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n\n      reject(record.arg);\n    }\n\n    var previousPromise;\n\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          for (; ++i < iterable.length;) {\n            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n          }\n\n          return next.value = undefined, next.done = !0, next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n            record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n              hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\r\nexport function getRandomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\nexport function getRandomIntInclusive(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\r\n}\r\nexport function getRandomArbitrary(min, max) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Assumes that the object entries are all primitives + objects\r\n * shallow copy the object,\r\n * deep copy the\r\n * @param obj\r\n * @returns\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (!obj) return obj\r\n  if (!Object.keys(obj).length) return {} as T\r\n  const ret = { ...obj }\r\n  Object.entries(obj).forEach(([k, v]: any) => {\r\n    if (typeof v !== \"object\") return\r\n    ret[k] = JSON.parse(JSON.stringify(v))\r\n  })\r\n  return ret\r\n}\r\n\r\nexport const clamp = (val, low, high) => {\r\n  if (val < low) return low;\r\n  if (val > high) return high;\r\n  return val\r\n}\r\nexport const getArrLastElement = (arr) =>\r\n  arr.length ? arr[arr.length - 1] : null\r\n\r\nexport const clamp01 = (val) => clamp(val, 0, 1)\r\nexport const clampPercent = (val) => clamp(val, 0, 100)\r\n\r\n//use to pretty print timestamps, or anything really.\r\nexport function strPadLeft(string, pad, length) {\r\n  return (new Array(length + 1).join(pad) + string).slice(-length);\r\n}\r\n\r\n//fuzzy compare strings. longer the distance, the higher the mismatch.\r\nexport function hammingDistance(str1, str2) {\r\n  var dist = 0;\r\n  str1 = str1.toLowerCase();\r\n  str2 = str2.toLowerCase();\r\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\r\n    let match = true\r\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\r\n      match = false\r\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\r\n      match = true\r\n    if (!match) dist++\r\n  }\r\n  return dist;\r\n}\r\n\r\n//multiplies every numerical value in the obj by a multiplier.\r\nexport function objMultiplication(obj, multi) {\r\n  if (multi === 1) return obj\r\n  Object.keys(obj).forEach((prop: any) => {\r\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\r\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\r\n  })\r\n  return obj\r\n}\r\n\r\n//assign obj.[keys...] = value\r\nexport function layeredAssignment(obj, keys: readonly string[], value) {\r\n  keys.reduce((accu, key, i, arr) => {\r\n    if (i === arr.length - 1) return (accu[key] = value)\r\n    if (!accu[key]) accu[key] = {}\r\n    return accu[key]\r\n  }, obj)\r\n  return obj\r\n}\r\n//get the value in a nested object, giving array of path\r\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\r\n  if (!obj || !keys) return undefined;\r\n  !Array.isArray(keys) && console.error(keys)\r\n  return keys.reduce((a, k) => a?.[k], obj)\r\n}\r\n//delete the value denoted by the path. Will also delete empty objects as well.\r\nexport function deletePropPath(obj, path) {\r\n  const tempPath = [...path]\r\n  const lastKey = tempPath.pop()\r\n  const objPathed = objPathValue(obj, tempPath)\r\n  delete objPathed?.[lastKey];\r\n}\r\n\r\nexport function objClearEmpties(o) {\r\n  for (const k in o) {\r\n    if (typeof o[k] !== \"object\") continue\r\n    objClearEmpties(o[k])\r\n    if (!Object.keys(o[k]).length) delete o[k];\r\n  }\r\n}\r\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\r\n  if (validate(obj, keys)) cb(obj, keys)\r\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\r\n}\r\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\r\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\r\n\r\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\r\n  return typeof value === \"function\" ? (value as any)(arg) : value\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(items.map(t => map(t))) as any\r\n}\r\n\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\r\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\r\n  return Object.fromEntries(Object.entries(obj).map(\r\n    ([k, v], i) => [k, fn(v, k, i)]\r\n  )) as any\r\n}\r\n\r\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\r\n  for (let i = from; i <= to; i++) yield i;\r\n};\r\n\r\n/** range of [from, to], inclusive */\r\nexport function range(from: number, to: number): number[] {\r\n  return [...rangeGen(from, to)]\r\n}\r\n\r\nexport function assertUnreachable(value: never): never {\r\n  throw new Error(`Should not reach this with value ${value}`)\r\n}\r\n\r\n/** Will change `arr` in-place */\r\nexport function toggleInArr<T>(arr: T[], value: T) {\r\n  const ind = arr.indexOf(value)\r\n  if (ind < 0) arr.push(value)\r\n  else arr.splice(ind, 1)\r\n}\r\n\r\nexport function toggleArr<T>(arr: T[], value: T) {\r\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\r\n}\r\n\r\nexport function deepFreeze(obj: any, layers: number = 5) {\r\n  if (layers === 0) return\r\n  if (typeof obj === \"object\")\r\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\r\n}\r\n\r\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\r\n  if (newIndex < 0 || newIndex >= arr.length) return arr\r\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\r\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n  return arr\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\r\n\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype Any = Num | Str\r\n\r\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\r\nexport const one = percent(1), naught = percent(0)\r\nexport const none = constant(\"none\")\r\n\r\nexport function constant(value: number, info?: Info): NumNode\r\nexport function constant(value: string | undefined, info?: Info): StrNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\r\n  return { operation: \"const\", operands: [], value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): NumNode {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { key: \"_\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\r\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\r\n  return { operation: \"lookup\", operands, table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Num[]): NumNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Num[]): NumNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Num[]): NumNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Num[]): NumNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Num, c: Num): NumNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Num): NumNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? eq : neq */\r\nexport function compareEq(v1: Num, v2: Num, eq: Num, neq: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function compareEq(v1: Num, v2: Num, eq: Str, neq: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Num, neq: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Str, neq: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function compareEq(v1: Num | Str, v2: Num | Str, eq: Num | Str, neq: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)], info }\r\n}\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<NumNode | StrNode, StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 != v2 ? pass : `undefined` */\r\nexport function unequalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function unequalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function unequalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<NumNode | StrNode, StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(undefined), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\r\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\r\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\n/**\r\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\r\n */\r\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: Any[]): AnyNode[]\r\nfunction intoOps(values: Any[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: Num | Str): NumNode | StrNode\r\nfunction intoV(value: Any): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\n\r\ntype _NodeList = {\r\n  [key: string]: NodeList\r\n} & {\r\n  operation?: never\r\n}\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n\r\n/**\r\n * `v1` === `v2` ? `match` : `unmatch`\r\n * @deprecated Use `equal`, `unequal`, `equalStr`, or `compareEq` instead\r\n */\r\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\r\n}\r\n","import { AnyNode, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\r\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\r\n\r\n  function traverse(formula: (NumNode | StrNode)) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\r\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\r\n  const visiting = new Set<(NumNode | StrNode)>()\r\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n\r\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\r\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\r\n  const visiting = new Set<AnyNode>()\r\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n\r\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\r\n    let topDownMapping = topDownByContext.get(parentContextId)\r\n    if (!topDownMapping) {\r\n      topDownMapping = new Map()\r\n      topDownByContext.set(parentContextId, topDownMapping)\r\n    }\r\n\r\n    let topDown = topDownMapping.get(formula)\r\n    if (topDown) return topDown\r\n    let topDownContextId: number\r\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n\r\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\r\n    if (!bottomUpMapping) {\r\n      bottomUpMapping = new Map()\r\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\r\n    }\r\n\r\n    let bottomUp = bottomUpMapping.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    visiting.add(topDown)\r\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\r\n    visiting.delete(topDown)\r\n\r\n    bottomUpMapping.set(topDown, bottomUp)\r\n    topDownMapping.set(formula, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\r\n    const operands = formula.operands.map(f => check(f, contextId))\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(f => check(f, baseContextId))\r\n  return arrayEqual(formulas, result) ? formulas : result\r\n}\r\n\r\ntype ContextID = number\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import type { ArtifactBuildData } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\r\nimport { assertUnreachable, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], initial: ArtifactBuildData[\"values\"], binding: (readNode: ReadNode<number> | ReadNode<string | undefined>) => string, slotCount: number): (_: ArtifactBuildData[]) => number[] {\r\n  let body = `\r\n\"use strict\";\r\n// copied from the code above\r\nfunction res(res) {\r\n  if (res < 0) return 1 - res / 2\r\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n  return 1 - res\r\n}\r\nconst x0=0`; // making sure `const` has at least one entry\r\n\r\n  let i = 1;\r\n  const names = new Map<NumNode | StrNode, string>()\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation, operands } = f, name = `x${i++}`, operandNames = operands.map(x => names.get(x)!)\r\n    names.set(f, name)\r\n    switch (operation) {\r\n      case \"read\": {\r\n        const key = binding(f)\r\n        let arr = new Array(slotCount).fill(null).map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\r\n        if (initial[key] && initial[key] !== 0) {\r\n          arr = [initial[key].toString(), ...arr]\r\n        }\r\n        body += `,${name}=${arr.join('+')}`\r\n        break\r\n      }\r\n      case \"const\": names.set(f, `(${f.value})`); break\r\n      case \"add\": case \"mul\": body += `,${name}=${operandNames.join(operation === \"add\" ? \"+\" : \"*\")}`; break\r\n      case \"min\": case \"max\": body += `,${name}=Math.${operation}(${operandNames})`; break\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandNames\r\n        body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\r\n        break\r\n      }\r\n      case \"res\": body += `,${name}=res(${operandNames[0]})`; break\r\n      case \"sum_frac\": body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`; break\r\n\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\": case \"small\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n  body += `;\\nreturn [${formulas.map(f => names.get(f)!)}]`\r\n  return new (Function as any)(`b`, body)\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? fold(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = fold(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\r\n        if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = fold(operands[operands.length - 1], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\r\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\r\nexport const allAmpReactions = [\"vaporize\", \"melt\",] as const\r\nexport const allAdditiveReactions = [\"spread\", \"aggravate\"] as const\r\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\r\nexport const allRarities = [5, 4, 3, 2, 1] as const\r\nexport const allArtifactRarities = [5, 4, 3] as const\r\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\r\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\r\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\r\nexport const allInfusionAuraElements = [\"pyro\", 'cryo'] as const\r\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\r\nexport const allRollColorKeys = ['roll1', 'roll2', 'roll3', 'roll4', 'roll5', 'roll6'] as const\r\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\r\nexport const allRefinement = [1, 2, 3, 4, 5] as const\r\nexport const substatType = [\"max\", \"mid\", \"min\"] as const\r\n\r\nexport const allArtifactSets = [\r\n  \"Adventurer\",\r\n  \"ArchaicPetra\",\r\n  \"Berserker\",\r\n  \"BlizzardStrayer\",\r\n  \"BloodstainedChivalry\",\r\n  \"BraveHeart\",\r\n  \"CrimsonWitchOfFlames\",\r\n  \"DeepwoodMemories\",\r\n  \"DefendersWill\",\r\n  \"EchoesOfAnOffering\",\r\n  \"EmblemOfSeveredFate\",\r\n  \"Gambler\",\r\n  \"GildedDreams\",\r\n  \"GladiatorsFinale\",\r\n  \"HeartOfDepth\",\r\n  \"HuskOfOpulentDreams\",\r\n  \"Instructor\",\r\n  \"Lavawalker\",\r\n  \"LuckyDog\",\r\n  \"MaidenBeloved\",\r\n  \"MartialArtist\",\r\n  \"NoblesseOblige\",\r\n  \"OceanHuedClam\",\r\n  \"PaleFlame\",\r\n  \"PrayersForDestiny\",\r\n  \"PrayersForIllumination\",\r\n  \"PrayersForWisdom\",\r\n  \"PrayersToSpringtime\",\r\n  \"ResolutionOfSojourner\",\r\n  \"RetracingBolide\",\r\n  \"Scholar\",\r\n  \"ShimenawasReminiscence\",\r\n  \"TenacityOfTheMillelith\",\r\n  \"TheExile\",\r\n  \"ThunderingFury\",\r\n  \"Thundersoother\",\r\n  \"TinyMiracle\",\r\n  \"TravelingDoctor\",\r\n  \"VermillionHereafter\",\r\n  \"ViridescentVenerer\",\r\n  \"WanderersTroupe\",\r\n] as const\r\nexport const nonTravelerCharacterKeys = [\r\n  \"Albedo\",\r\n  \"Amber\",\r\n  \"Barbara\",\r\n  \"Beidou\",\r\n  \"Bennett\",\r\n  \"Chongyun\",\r\n  \"Diluc\",\r\n  \"Diona\",\r\n  \"Fischl\",\r\n  \"Ganyu\",\r\n  \"HuTao\",\r\n  \"Jean\",\r\n  \"Kaeya\",\r\n  \"Keqing\",\r\n  \"Klee\",\r\n  \"KujouSara\",\r\n  \"KukiShinobu\",\r\n  \"Lisa\",\r\n  \"Mona\",\r\n  \"Ningguang\",\r\n  \"Noelle\",\r\n  \"Qiqi\",\r\n  \"Razor\",\r\n  \"Sucrose\",\r\n  \"Tartaglia\",\r\n  \"RaidenShogun\",\r\n  \"Venti\",\r\n  \"Xiangling\",\r\n  \"Xiao\",\r\n  \"Xingqiu\",\r\n  \"Xinyan\",\r\n  \"Rosaria\",\r\n  \"Yanfei\",\r\n  \"Eula\",\r\n  \"KaedeharaKazuha\",\r\n  \"KamisatoAyaka\",\r\n  \"Sayu\",\r\n  \"Shenhe\",\r\n  \"Yoimiya\",\r\n  \"Aloy\",\r\n  \"SangonomiyaKokomi\",\r\n  \"Thoma\",\r\n  \"Gorou\",\r\n  \"AratakiItto\",\r\n  \"YaeMiko\",\r\n  \"YunJin\",\r\n  \"Zhongli\",\r\n  \"KamisatoAyato\",\r\n  \"Yelan\",\r\n  \"ShikanoinHeizou\",\r\n  \"Collei\",\r\n  \"Dori\",\r\n  \"Tighnari\",\r\n] as const\r\nexport const locationCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  \"Traveler\",\r\n] as const\r\nexport const travelerElements = [\r\n  \"anemo\",\r\n  \"geo\",\r\n  \"electro\",\r\n  \"dendro\"\r\n] as const\r\nexport const travelerFKeys = [\r\n  \"TravelerFAnemo\",\r\n  \"TravelerFGeo\",\r\n  \"TravelerFElectro\",\r\n  \"TravelerFDendro\",\r\n] as const\r\nexport const travelerMKeys = [\r\n  \"TravelerMAnemo\",\r\n  \"TravelerMGeo\",\r\n  \"TravelerMElectro\",\r\n  \"TravelerMDendro\",\r\n] as const\r\nexport const travelerKeys = [\r\n  ...travelerFKeys,\r\n  ...travelerMKeys,\r\n] as const\r\nexport const allCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  ...travelerKeys\r\n] as const\r\n\r\nexport const allWeaponSwordKeys = [\r\n  \"AmenomaKageuchi\",\r\n  \"AquilaFavonia\",\r\n  \"BlackcliffLongsword\",\r\n  \"CinnabarSpindle\",\r\n  \"CoolSteel\",\r\n  \"KagotsurubeIsshin\",\r\n  \"DarkIronSword\",\r\n  \"DullBlade\",\r\n  \"FavoniusSword\",\r\n  \"FesteringDesire\",\r\n  \"FilletBlade\",\r\n  \"FreedomSworn\",\r\n  \"HaranGeppakuFutsu\",\r\n  \"HarbingerOfDawn\",\r\n  \"IronSting\",\r\n  \"LionsRoar\",\r\n  \"MistsplitterReforged\",\r\n  \"PrimordialJadeCutter\",\r\n  \"PrototypeRancour\",\r\n  \"RoyalLongsword\",\r\n  \"SacrificialSword\",\r\n  \"SapwoodBlade\",\r\n  \"SilverSword\",\r\n  \"SkyriderSword\",\r\n  \"SkywardBlade\",\r\n  \"SummitShaper\",\r\n  \"SwordOfDescension\",\r\n  \"TheAlleyFlash\",\r\n  \"TheBlackSword\",\r\n  \"TheFlute\",\r\n  \"TravelersHandySword\",\r\n] as const\r\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\r\n\r\nexport const allWeaponClaymoreKeys = [\r\n  \"Akuoumaru\",\r\n  \"BlackcliffSlasher\",\r\n  \"BloodtaintedGreatsword\",\r\n  \"DebateClub\",\r\n  \"FavoniusGreatsword\",\r\n  \"FerrousShadow\",\r\n  \"ForestRegalia\",\r\n  \"KatsuragikiriNagamasa\",\r\n  \"LithicBlade\",\r\n  \"LuxuriousSeaLord\",\r\n  \"OldMercsPal\",\r\n  \"PrototypeArchaic\",\r\n  \"Rainslasher\",\r\n  \"RedhornStonethresher\",\r\n  \"RoyalGreatsword\",\r\n  \"SacrificialGreatsword\",\r\n  \"SerpentSpine\",\r\n  \"SkyriderGreatsword\",\r\n  \"SkywardPride\",\r\n  \"SnowTombedStarsilver\",\r\n  \"SongOfBrokenPines\",\r\n  \"TheBell\",\r\n  \"TheUnforged\",\r\n  \"WasterGreatsword\",\r\n  \"Whiteblind\",\r\n  \"WhiteIronGreatsword\",\r\n  \"WolfsGravestone\",\r\n] as const\r\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\r\n\r\nexport const allWeaponPolearmKeys = [\r\n  \"BeginnersProtector\",\r\n  \"BlackcliffPole\",\r\n  \"BlackTassel\",\r\n  \"CalamityQueller\",\r\n  \"CrescentPike\",\r\n  \"Deathmatch\",\r\n  \"DragonsBane\",\r\n  \"DragonspineSpear\",\r\n  \"EngulfingLightning\",\r\n  \"FavoniusLance\",\r\n  \"Halberd\",\r\n  \"IronPoint\",\r\n  \"KitainCrossSpear\",\r\n  \"LithicSpear\",\r\n  \"Moonpiercer\",\r\n  \"PrimordialJadeWingedSpear\",\r\n  \"PrototypeStarglitter\",\r\n  \"RoyalSpear\",\r\n  \"SkywardSpine\",\r\n  \"StaffOfHoma\",\r\n  \"TheCatch\",\r\n  \"VortexVanquisher\",\r\n  \"WavebreakersFin\",\r\n  \"WhiteTassel\",\r\n] as const\r\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\r\n\r\nexport const allWeaponBowKeys = [\r\n  \"AlleyHunter\",\r\n  \"AmosBow\",\r\n  \"AquaSimulacra\",\r\n  \"BlackcliffWarbow\",\r\n  \"CompoundBow\",\r\n  \"ElegyForTheEnd\",\r\n  \"FadingTwilight\",\r\n  \"FavoniusWarbow\",\r\n  \"Hamayumi\",\r\n  \"HuntersBow\",\r\n  \"HuntersPath\",\r\n  \"KingsSquire\",\r\n  \"Messenger\",\r\n  \"MitternachtsWaltz\",\r\n  \"MouunsMoon\",\r\n  \"PolarStar\",\r\n  \"Predator\",\r\n  \"PrototypeCrescent\",\r\n  \"RavenBow\",\r\n  \"RecurveBow\",\r\n  \"RoyalBow\",\r\n  \"Rust\",\r\n  \"SacrificialBow\",\r\n  \"SeasonedHuntersBow\",\r\n  \"SharpshootersOath\",\r\n  \"SkywardHarp\",\r\n  \"Slingshot\",\r\n  \"TheStringless\",\r\n  \"TheViridescentHunt\",\r\n  \"ThunderingPulse\",\r\n  \"EndOfTheLine\",\r\n  \"WindblumeOde\",\r\n] as const\r\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\r\n\r\nexport const allWeaponCatalystKeys = [\r\n  \"ApprenticesNotes\",\r\n  \"BlackcliffAgate\",\r\n  \"DodocoTales\",\r\n  \"EmeraldOrb\",\r\n  \"EverlastingMoonglow\",\r\n  \"EyeOfPerception\",\r\n  \"FavoniusCodex\",\r\n  \"Frostbearer\",\r\n  \"FruitOfFulfillment\",\r\n  \"HakushinRing\",\r\n  \"KagurasVerity\",\r\n  \"LostPrayerToTheSacredWinds\",\r\n  \"MagicGuide\",\r\n  \"MappaMare\",\r\n  \"MemoryOfDust\",\r\n  \"OathswornEye\",\r\n  \"OtherworldlyStory\",\r\n  \"PocketGrimoire\",\r\n  \"PrototypeAmber\",\r\n  \"RoyalGrimoire\",\r\n  \"SacrificialFragments\",\r\n  \"SkywardAtlas\",\r\n  \"SolarPearl\",\r\n  \"TheWidsith\",\r\n  \"ThrillingTalesOfDragonSlayers\",\r\n  \"TwinNephrite\",\r\n  \"WineAndSong\",\r\n] as const\r\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\r\n\r\nexport const allWeaponKeys = [\r\n  ...allWeaponSwordKeys,\r\n  ...allWeaponClaymoreKeys,\r\n  ...allWeaponPolearmKeys,\r\n  ...allWeaponBowKeys,\r\n  ...allWeaponCatalystKeys,\r\n] as const\r\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\r\n\r\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"dendro_dmg_\"] as const\r\n\r\nexport type HitModeKey = typeof allHitModes[number]\r\nexport type Region = typeof allRegions[number]\r\nexport type AmpReactionKey = typeof allAmpReactions[number]\r\nexport type AdditiveReactionKey = typeof allAdditiveReactions[number]\r\nexport type SetNum = typeof allArtifactSetCount[number]\r\nexport type Rarity = typeof allRarities[number]\r\nexport type ArtifactRarity = typeof allArtifactRarities[number]\r\nexport type SlotKey = typeof allSlotKeys[number]\r\nexport type ElementKey = typeof allElements[number]\r\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\r\nexport type InfusionAuraElements = typeof allInfusionAuraElements[number]\r\nexport type ArtifactSetKey = typeof allArtifactSets[number]\r\nexport type CharacterKey = typeof allCharacterKeys[number]\r\nexport type LocationCharacterKey = typeof locationCharacterKeys[number]\r\nexport type TravelerKey = typeof travelerKeys[number]\r\nexport type TravelerElementKey = typeof travelerElements[number]\r\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\r\nexport type RollColorKey = typeof allRollColorKeys[number]\r\nexport type Ascension = typeof allAscension[number]\r\nexport type Refinement = typeof allRefinement[number]\r\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\r\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\r\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\r\n  pyro: [\"vaporize\", \"melt\"],\r\n  hydro: [\"vaporize\"],\r\n  cryo: [\"melt\"],\r\n  anemo: [\"vaporize\", \"melt\"],\r\n}\r\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> = {\r\n  dendro: [\"spread\"],\r\n  electro: [\"aggravate\"],\r\n  anemo: [\"aggravate\"],\r\n}\r\n\r\nexport type SubstatType = typeof substatType[number]\r\n\r\nexport function charKeyToLocCharKey(charKey: CharacterKey): LocationCharacterKey {\r\n  if (travelerKeys.includes(charKey as TravelerKey)) return \"Traveler\"\r\n  return charKey as LocationCharacterKey\r\n}\r\n\r\nexport function TravelerToElement(key: TravelerKey, element: TravelerElementKey): TravelerKey {\r\n  return key.slice(0, 9) + element.toUpperCase().slice(0, 1) + element.slice(1) as TravelerKey\r\n}\r\n\r\nexport function TravelerGender(key: TravelerKey, gender: \"F\" | \"M\"): TravelerKey {\r\n  return key.slice(0, 8) + gender + key.slice(9) as TravelerKey\r\n}\r\n\r\nexport type LocationKey = LocationCharacterKey | \"\"\r\n\r\nexport function charKeyToCharName(ck: CharacterKey): string {\r\n  return ck.startsWith(\"Traveler\") ? ck.slice(0, 9) : ck\r\n}\r\n","import { ArtSetExclusion } from \"../../../../Database/Data/BuildsettingData\";\r\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\r\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\r\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\r\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\r\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\r\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\r\n\r\ntype DynMinMax = { [key in string]: MinMax }\r\ntype MinMax = { min: number, max: number }\r\n\r\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\r\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  let should = forced\r\n  /** If `key` makes progress, all operations in `value` should be performed */\r\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\r\n    pruneOrder: { pruneNodeRange: true },\r\n    pruneArtRange: { pruneNodeRange: true },\r\n    pruneNodeRange: { reaffine: true },\r\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\r\n  }\r\n  let count = 0\r\n  while (Object.values(should).some(x => x) && count++ < 20) {\r\n    if (should.pruneOrder) {\r\n      delete should.pruneOrder\r\n      const newArts = pruneOrder(arts, numTop, exclusion)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneOrder }\r\n      }\r\n    }\r\n    if (should.pruneArtRange) {\r\n      delete should.pruneArtRange\r\n      const newArts = pruneArtRange(nodes, arts, minimum)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneArtRange }\r\n      }\r\n    }\r\n    if (should.pruneNodeRange) {\r\n      delete should.pruneNodeRange\r\n      const newNodes = pruneNodeRange(nodes, arts)\r\n      if (nodes !== newNodes) {\r\n        nodes = newNodes\r\n        should = { ...should, ...deps.pruneNodeRange }\r\n      }\r\n    }\r\n    if (should.reaffine) {\r\n      delete should.reaffine\r\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\r\n      if (nodes !== newNodes || arts !== newArts) {\r\n        nodes = newNodes\r\n        arts = newArts\r\n        should = { ...should, ...deps.reaffine }\r\n      }\r\n    }\r\n  }\r\n  return { nodes, arts }\r\n}\r\n\r\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\r\n\r\n  function visit(node: NumNode, isAffine: boolean) {\r\n    if (isAffine) affineNodes.add(node)\r\n    else node.operands.forEach(_op => {\r\n      const op = _op as NumNode\r\n      affineNodes.has(op) && topLevelAffine.add(op)\r\n    })\r\n  }\r\n\r\n  const dynKeys = new Set<string>()\r\n\r\n  forEachNodes(nodes, _ => { }, f => {\r\n    const operation = f.operation\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\r\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\r\n        dynKeys.add(f.path[1])\r\n        visit(f, true)\r\n        break\r\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\r\n      case \"mul\": {\r\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\r\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\r\n        break\r\n      }\r\n      case \"const\":\r\n        if (typeof f.value === \"string\" || f.value === undefined)\r\n          throw new Error(`Found constant ${f.value} while compacting`)\r\n        visit(f as NumNode, true); break\r\n      case \"res\": case \"threshold\": case \"sum_frac\":\r\n      case \"max\": case \"min\": visit(f, false); break\r\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\r\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\r\n    Object.keys(arts.base).length === dynKeys.size)\r\n    return { nodes, arts }\r\n\r\n  let current = -1\r\n  function nextDynKey(): string {\r\n    while (dynKeys.has(`${++current}`));\r\n    return `${current}`\r\n  }\r\n\r\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\r\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\r\n  const affineMap = new Map(affine.map(node => [node,\r\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\r\n      ? node\r\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\r\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\r\n\r\n  function reaffineArt(stat: DynStat): DynStat {\r\n    const values = constantFold([...affineMap.keys()], {\r\n      dyn: objectMap(stat, (value) => constant(value))\r\n    } as any, _ => true)\r\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\r\n  }\r\n  const result = {\r\n    nodes, arts: {\r\n      base: reaffineArt(arts.base),\r\n      values: objectKeyMap(allSlotKeys, slot =>\r\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\r\n    }\r\n  }\r\n  const offsets = Object.entries(reaffineArt({}))\r\n  for (const arts of Object.values(result.arts.values))\r\n    for (const { values } of arts)\r\n      for (const [key, baseValue] of offsets)\r\n        values[key] -= baseValue\r\n  return result\r\n}\r\n/** Remove artifacts that cannot be in top `numTop` builds */\r\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\r\n  let progress = false\r\n  const noRainbow = !exclusion.rainbow?.length\r\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\r\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\r\n  const values = objectKeyMap(allSlotKeys, slot => {\r\n    const list = arts.values[slot]\r\n    const newList = list.filter(art => {\r\n      let count = 0\r\n      return list.every(other => {\r\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\r\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\r\n        if (greaterEqual && (greater || other.id > art.id) &&\r\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\r\n          count++\r\n        return count < numTop\r\n      })\r\n    })\r\n    if (newList.length !== list.length) progress = true\r\n    return newList\r\n  })\r\n  return progress ? { base: arts.base, values } : arts\r\n}\r\n/** Remove artifacts that cannot reach `minimum` in any build */\r\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const wrap = { arts }\r\n  while (true) {\r\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\r\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\r\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\r\n\r\n    let progress = false\r\n    const values = objectKeyMap(allSlotKeys, slot => {\r\n      const result = wrap.arts.values[slot].filter(art => {\r\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\r\n        const newRange = computeNodeRange(nodes, read)\r\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\r\n      })\r\n      if (result.length !== wrap.arts.values[slot].length)\r\n        progress = true\r\n      return result\r\n    })\r\n    if (!progress) break\r\n    wrap.arts = { base: wrap.arts.base, values }\r\n  }\r\n  return wrap.arts\r\n}\r\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n  const nodeRange = computeNodeRange(nodes, reads)\r\n\r\n  return mapFormulas(nodes, f => {\r\n    const { operation } = f\r\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\r\n    switch (operation) {\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandRanges\r\n        if (value.min >= threshold.max) return f.operands[2]\r\n        else if (value.max < threshold.min) return f.operands[3]\r\n        if (pass.max === pass.min &&\r\n          fail.max === fail.min &&\r\n          pass.min === fail.min && isFinite(pass.min))\r\n          return constant(pass.max)\r\n        break\r\n      }\r\n      case \"min\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\r\n        break\r\n      }\r\n      case \"max\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every(op2 => op1.max >= op2.min)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\r\n        break\r\n      }\r\n    }\r\n    return f\r\n  }, f => f)\r\n}\r\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  ranges.forEach(range => {\r\n    Object.entries(range).forEach(([key, value]) => {\r\n      if (result[key]) {\r\n        result[key].min += value.min\r\n        result[key].max += value.max\r\n      } else result[key] = { ...value }\r\n    })\r\n  })\r\n  return result\r\n}\r\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  if (arts.length) {\r\n    Object.keys(arts[0].values)\r\n      .filter(key => arts.every(art => art.values[key]))\r\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\r\n    arts.forEach(({ values }) => {\r\n      for (const [key, value] of Object.entries(values)) {\r\n        if (!result[key]) result[key] = { min: 0, max: value }\r\n        else {\r\n          if (result[key].max < value) result[key].max = value\r\n          if (result[key].min > value) result[key].min = value\r\n        }\r\n      }\r\n    })\r\n  }\r\n  return result\r\n}\r\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\r\n  const range = new Map<NumNode, MinMax>()\r\n\r\n  forEachNodes(nodes, _ => { }, _f => {\r\n    const f = _f as NumNode\r\n    const { operation } = f\r\n    const operands = f.operands.map(op => range.get(op)!)\r\n    let current: MinMax\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.path[0] !== \"dyn\")\r\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\r\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\r\n        break\r\n      case \"const\": current = computeMinMax([f.value]); break\r\n      case \"subscript\": current = computeMinMax(f.list); break\r\n      case \"add\": case \"min\": case \"max\":\r\n        current = {\r\n          min: allOperations[operation](operands.map(x => x.min)),\r\n          max: allOperations[operation](operands.map(x => x.max)),\r\n        }; break\r\n      case \"res\": current = {\r\n        min: allOperations[operation]([operands[0].max]),\r\n        max: allOperations[operation]([operands[0].min]),\r\n      }; break\r\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\r\n        accu.min * current.min, accu.min * current.max,\r\n        accu.max * current.min, accu.max * current.max,\r\n      ])); break\r\n      case \"threshold\":\r\n        if (operands[0].min >= operands[1].max) current = operands[2]\r\n        else if (operands[0].max < operands[1].min) current = operands[3]\r\n        else current = computeMinMax([], [operands[2], operands[3]])\r\n        break\r\n      case \"sum_frac\": {\r\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\r\n        if (sum.min <= 0 && sum.max >= 0)\r\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\r\n        else\r\n          // TODO: Check this\r\n          current = computeMinMax([\r\n            x.min / sum.min, x.min / sum.max,\r\n            x.max / sum.min, x.max / sum.max\r\n          ])\r\n        break\r\n      }\r\n      case \"data\": case \"lookup\": case \"match\":\r\n        throw new Error(`Unsupported ${operation} node`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n    range.set(f, current)\r\n  })\r\n  return range\r\n}\r\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\r\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\r\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\r\n  return { min, max }\r\n}\r\n\r\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\r\n  return {\r\n    base: arts.base,\r\n    values: objectKeyMap(allSlotKeys, slot => {\r\n      const filter = filters[slot]\r\n      switch (filter.kind) {\r\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\r\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\r\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\r\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\r\n}\r\nexport function mergePlot(plots: PlotData[]): PlotData {\r\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\r\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\r\n  while (keys.size > maxCount) {\r\n    scale *= reductionScaling\r\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\r\n  }\r\n  const result: PlotData = {}\r\n  for (const plot of plots)\r\n    for (const build of Object.values(plot)) {\r\n      const x = Math.round(build.plot! / scale) * scale\r\n      if (!result[x] || result[x]!.value < build.value)\r\n        result[x] = build\r\n    }\r\n  return result\r\n}\r\n\r\nexport function countBuilds(arts: ArtifactsBySlot): number {\r\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\r\n}\r\n\r\n\r\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\r\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\r\n  filter_loop: for (const filter of filters) {\r\n    for (const [slot, f] of Object.entries(filter)) {\r\n      const available = artSets[slot]!\r\n      switch (f.kind) {\r\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\r\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\r\n        case \"id\": break\r\n      }\r\n    }\r\n    yield filter\r\n  }\r\n}\r\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\r\n  return new Set(exclusion?.includes(2)\r\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\r\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\r\n}\r\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\r\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\r\n  /**\r\n   * This generation algorithm is separated into two parts:\r\n   * - \"Shape\" generation\r\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\r\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\r\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\r\n   * - Shape filling\r\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\r\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\r\n   */\r\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\r\n  let shapes: number[][] = []\r\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\r\n    if (current.length === 5) {\r\n      if (allowedRainbows.has(rainbows.length))\r\n        shapes.push(current)\r\n      return\r\n    }\r\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\r\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\r\n  }\r\n  populateShapes([0], new Set([0]), [0])\r\n  function indexOfShape(shape: number[], replacing: number) {\r\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\r\n      return undefined\r\n    shape = [...shape]\r\n    shape[replacing] = 5\r\n    return shape.reduce((a, b) => a * 6 + b, 0)\r\n  }\r\n  for (let replacing = 4; replacing >= 0; replacing--) {\r\n    const required: Map<number, number> = new Map()\r\n    for (const shape of shapes) {\r\n      const id = indexOfShape(shape, replacing)\r\n      if (id === undefined) continue\r\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\r\n    }\r\n    for (const [id, remaining] of required.entries()) {\r\n      if (remaining === 0) {\r\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\r\n        shape[replacing] = 5\r\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\r\n        shapes.push(shape)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shapes are now calculated and merged, proceed to fill in the sets\r\n\r\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\r\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\r\n\r\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\r\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\r\n\r\n  function* check(shape: number[]) {\r\n    const used: Set<ArtifactSetKey> = new Set()\r\n    let groupped: number[][] = [], rainbows: number[] = []\r\n    for (const i of shape) {\r\n      groupped.push([])\r\n      if (i === 5) rainbows.push(groupped.length - 1)\r\n      else groupped[i].push(groupped.length - 1)\r\n    }\r\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\r\n    let usableRainbows = rainbows.length\r\n\r\n    // Inception.. because js doesn't like functions inside a for-loop\r\n    function* check(i: number) {\r\n      if (i === groupped.length)\r\n        return yield* check_free(0)\r\n\r\n      for (const set of artSets) {\r\n        if (used.has(set)) continue\r\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\r\n        let requiredRainbows = 0\r\n\r\n        if (allowedSet && !allowedSet.has(length)) {\r\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\r\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\r\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\r\n        }\r\n\r\n        used.add(set)\r\n        counts[set] = groupped[i].length\r\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\r\n        usableRainbows -= requiredRainbows\r\n\r\n        yield* check(i + 1)\r\n\r\n        usableRainbows += requiredRainbows\r\n        counts[set] = 0\r\n        used.delete(set)\r\n      }\r\n    }\r\n    // We separate filling rainbow slots from groupped slots because it has an entirely\r\n    // different set of rules regarding what can be filled and what states to be kept.\r\n    function* check_free(i: number) {\r\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\r\n      let required = 0\r\n      for (const set of artSets) {\r\n        const allowedSet = allowedCounts[set], count = counts[set]\r\n        if (!allowedSet) continue\r\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\r\n        else if (!allowedSet.has(count)) {\r\n          required += [...allowedSet].find(x => x > count)! - count\r\n          missing.push(set)\r\n        }\r\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\r\n      }\r\n      if (required > remaining) return\r\n      if (i === rainbows.length) {\r\n        yield { ...result }\r\n        return\r\n      }\r\n      if (required === remaining) {\r\n        for (const set of missing) {\r\n          counts[set]++\r\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n          yield* check_free(i + 1)\r\n          counts[set]--\r\n        }\r\n        return\r\n      }\r\n      for (const set of [...isolated, ...missing]) {\r\n        counts[set]++\r\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n        yield* check_free(i + 1)\r\n        counts[set]--\r\n      }\r\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\r\n      yield* check_free(i + 1)\r\n    }\r\n    yield* check(0)\r\n  }\r\n  for (const shape of shapes) yield* check(shape)\r\n}\r\n\r\nexport type RequestFilter = StrictDict<SlotKey,\r\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"id\", ids: Set<string> }\r\n>\r\n\r\nexport type DynStat = { [key in string]: number }\r\nexport type ArtifactBuildData = {\r\n  id: string\r\n  set?: ArtifactSetKey\r\n  values: DynStat\r\n}\r\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\r\n\r\nexport type PlotData = Dict<number, Build>\r\nexport interface Build {\r\n  value: number\r\n  plot?: number\r\n  artifactIds: string[]\r\n}\r\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import { optimize, precompute } from '../../../../Formula/optimization';\r\nimport type { NumNode } from '../../../../Formula/type';\r\nimport type { InterimResult, Setup } from './BackgroundWorker';\r\nimport { ArtifactBuildData, ArtifactsBySlot, Build, countBuilds, filterArts, mergePlot, PlotData, pruneAll, RequestFilter } from './common';\r\n\r\nexport class ComputeWorker {\r\n  builds: Build[] = []\r\n  buildValues: number[] | undefined = undefined\r\n  plotData: PlotData | undefined\r\n  threshold: number = -Infinity\r\n  maxBuilds: number\r\n  min: number[]\r\n\r\n  arts: ArtifactsBySlot\r\n  nodes: NumNode[]\r\n\r\n  callback: (interim: InterimResult) => void\r\n\r\n  constructor({ arts, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n    this.min = filters.map(x => x.min)\r\n    this.maxBuilds = maxBuilds\r\n    this.callback = callback\r\n    this.nodes = filters.map(x => x.value)\r\n    this.nodes.push(optimizationTarget)\r\n    if (plotBase) {\r\n      this.plotData = {}\r\n      this.nodes.push(plotBase)\r\n    }\r\n    this.nodes = optimize(this.nodes, {}, _ => false)\r\n  }\r\n\r\n  compute(newThreshold: number, filter: RequestFilter) {\r\n    if (this.threshold > newThreshold) this.threshold = newThreshold\r\n    const { min, interimReport } = this, self = this // `this` in nested functions means different things\r\n    let preArts = filterArts(this.arts, filter)\r\n    const totalCount = countBuilds(preArts)\r\n\r\n    let nodes = this.nodes;\r\n    ({ nodes, arts: preArts } = pruneAll(nodes, min, preArts, this.maxBuilds, {}, {\r\n      pruneArtRange: true, pruneNodeRange: true,\r\n    }))\r\n    const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\r\n    const compute = precompute(nodes, preArts.base, f => f.path[1], arts.length)\r\n\r\n    const buffer = Array<ArtifactBuildData>(arts.length)\r\n    const count = { tested: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\r\n\r\n    function permute(i: number) {\r\n      if (i < 0) {\r\n        const result = compute(buffer)\r\n        if (min.every((m, i) => (m <= result[i]))) {\r\n          const value = result[min.length], { builds, plotData, maxBuilds } = self\r\n          let build: Build | undefined\r\n          if (value >= self.threshold) {\r\n            build = { value, artifactIds: buffer.map(x => x.id) }\r\n            builds.push(build)\r\n          }\r\n          if (plotData) {\r\n            const x = result[min.length + 1]\r\n            if (!plotData[x] || plotData[x]!.value < value) {\r\n              if (!build) build = { value, artifactIds: buffer.map(x => x.id) }\r\n              build.plot = x\r\n              plotData[x] = build\r\n            }\r\n          }\r\n        }\r\n        else count.failed += 1\r\n        return\r\n      }\r\n      arts[i].forEach(art => {\r\n        buffer[i] = art\r\n        permute(i - 1)\r\n      })\r\n      if (i === 0) {\r\n        count.tested += arts[0].length\r\n        if (count.tested > 1 << 16)\r\n          interimReport(count)\r\n      }\r\n    }\r\n\r\n    permute(arts.length - 1)\r\n    this.interimReport(count)\r\n  }\r\n\r\n  refresh(force: boolean): void {\r\n    const { maxBuilds } = this\r\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\r\n      this.plotData = mergePlot([this.plotData!])\r\n\r\n    if (this.builds.length >= 1000 || force) {\r\n      this.builds = this.builds\r\n        .sort((a, b) => b.value - a.value)\r\n        .slice(0, maxBuilds)\r\n      this.buildValues = this.builds.map(x => x.value)\r\n      this.threshold = Math.max(this.threshold, this.buildValues[maxBuilds - 1] ?? -Infinity)\r\n    }\r\n  }\r\n  interimReport = (count: { tested: number, failed: number, skipped: number }) => {\r\n    this.refresh(false)\r\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\r\n    this.buildValues = undefined\r\n    count.tested = 0\r\n    count.failed = 0\r\n    count.skipped = 0\r\n  }\r\n}\r\n","import { ArtSetExclusion } from '../../../../Database/Data/BuildsettingData'\r\nimport { NumNode } from '../../../../Formula/type'\r\nimport { assertUnreachable } from '../../../../Util/Util'\r\nimport { ArtifactsBySlot, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\r\nimport { ComputeWorker } from \"./ComputeWorker\"\r\nimport { SplitWorker } from \"./SplitWorker\"\r\n\r\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\r\n\r\nonmessage = ({ data }: { data: WorkerCommand }) => {\r\n  const command = data.command\r\n  let result: WorkerResult\r\n  switch (command) {\r\n    case \"setup\":\r\n      id = data.id\r\n      const splitID = `split${id}`, computeID = `compute${id}`\r\n      splitWorker = new SplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\r\n      computeWorker = new ComputeWorker(data, interim => postMessage({ id, source: computeID, ...interim }))\r\n      result = { command: \"iterate\" }\r\n      break\r\n    case \"split\":\r\n      if (data.filter) splitWorker.addFilter(data.filter)\r\n      let total = 0, split = splitWorker.split(data.threshold, data.minCount)\r\n      while (split && split.count <= 50_000 && total <= 500_000) {\r\n        total += split.count\r\n        computeWorker.compute(-Infinity, split.filter)\r\n        split = splitWorker.split(-Infinity, data.minCount)\r\n      }\r\n      result = { command: \"split\", filter: split?.filter }\r\n      break\r\n    case \"iterate\":\r\n      const { threshold, filter } = data\r\n      computeWorker.compute(threshold, filter)\r\n      result = { command: \"iterate\" }\r\n      break\r\n    case \"finalize\":\r\n      computeWorker.refresh(true)\r\n      const { builds, plotData } = computeWorker\r\n      result = { command: \"finalize\", builds, plotData }\r\n      break\r\n    case \"count\":\r\n      {\r\n        const { exclusion } = data, arts = computeWorker.arts\r\n        const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\r\n        let counts = data.arts.map(_ => 0)\r\n        for (const perm of setPerm)\r\n          data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\r\n        result = { command: \"count\", counts }\r\n        break\r\n      }\r\n    default: assertUnreachable(command)\r\n  }\r\n  postMessage({ id, ...result });\r\n}\r\n\r\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Count\r\nexport type WorkerResult = SourcedInterimResult | SplitResult | IterateResult | FinalizeResult | CountResult\r\n\r\nexport interface Setup {\r\n  command: \"setup\"\r\n\r\n  id: number\r\n  arts: ArtifactsBySlot\r\n\r\n  optimizationTarget: NumNode\r\n  filters: { value: NumNode, min: number }[]\r\n  plotBase: NumNode | undefined,\r\n  maxBuilds: number\r\n}\r\nexport interface Split {\r\n  command: \"split\"\r\n  threshold: number\r\n  minCount: number\r\n  filter?: RequestFilter\r\n}\r\nexport interface Iterate {\r\n  command: \"iterate\"\r\n  threshold: number\r\n  filter: RequestFilter\r\n}\r\n\r\nexport interface Finalize {\r\n  command: \"finalize\"\r\n}\r\nexport interface Count {\r\n  command: \"count\"\r\n  arts: ArtifactsBySlot[]\r\n  exclusion: ArtSetExclusion\r\n}\r\nexport interface SplitResult {\r\n  command: \"split\"\r\n  filter: RequestFilter | undefined\r\n}\r\nexport interface IterateResult {\r\n  command: \"iterate\"\r\n}\r\nexport interface FinalizeResult {\r\n  command: \"finalize\"\r\n  builds: Build[]\r\n  plotData?: PlotData\r\n}\r\nexport interface CountResult {\r\n  command: \"count\"\r\n  counts: number[]\r\n}\r\nexport interface InterimResult {\r\n  command: \"interim\"\r\n  buildValues: number[] | undefined\r\n  /** The number of builds since last report, including failed builds */\r\n  tested: number\r\n  /** The number of builds that does not meet the min-filter requirement since last report */\r\n  failed: number\r\n  skipped: number\r\n}\r\nexport interface SourcedInterimResult extends InterimResult {\r\n  /** the source of the message, must be unique for each source of `buildValues` */\r\n  source: string\r\n}\r\n","import type { NumNode } from '../../../../Formula/type';\r\nimport { allSlotKeys } from '../../../../Types/consts';\r\nimport type { InterimResult, Setup } from './BackgroundWorker';\r\nimport { ArtifactsBySlot, countBuilds, filterArts, RequestFilter } from './common';\r\n\r\nexport class SplitWorker {\r\n  min: number[]\r\n\r\n  arts: ArtifactsBySlot\r\n  nodes: NumNode[]\r\n\r\n  filters: { count: number, filter: RequestFilter }[] = []\r\n\r\n  callback: (interim: InterimResult) => void\r\n\r\n  constructor({ arts, optimizationTarget, filters }: Setup, callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n    this.min = filters.map(x => x.min)\r\n    this.nodes = filters.map(x => x.value)\r\n    this.callback = callback\r\n\r\n    this.min.push(-Infinity)\r\n    this.nodes.push(optimizationTarget)\r\n  }\r\n  addFilter(filter: RequestFilter) {\r\n    const count = countBuilds(filterArts(this.arts, filter))\r\n    this.filters.push({ count, filter })\r\n  }\r\n  split(newThreshold: number, minCount: number) {\r\n    if (this.min[this.min.length - 1] > newThreshold) this.min[this.min.length - 1] = newThreshold\r\n\r\n    while (this.filters.length) {\r\n      const { count, filter } = this.filters.pop()!\r\n      if (count <= minCount) return { count, filter }\r\n      splitBySetOrID(this.arts, filter, minCount).forEach(filter => this.addFilter(filter))\r\n    }\r\n  }\r\n}\r\n\r\nfunction splitBySetOrID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, sets: new Set(arts.values[slot].map(x => x.set)) }))\r\n    .filter(({ sets }) => sets.size > 1)\r\n  if (!candidates.length)\r\n    return splitByID(arts, filter, limit)\r\n  const { sets, slot } = candidates.reduce((a, b) => a.sets.size < b.sets.size ? a : b)\r\n  return [...sets].map(set => ({ ...filter, [slot]: { kind: \"required\", sets: new Set([set]) } }))\r\n}\r\nfunction splitByID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n  const count = countBuilds(arts)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, length: arts.values[slot].length }))\r\n    .filter(x => x.length > 1)\r\n  const { slot, length } = candidates.reduce((a, b) => a.length < b.length ? a : b)\r\n\r\n  const numChunks = Math.ceil(count / limit)\r\n  const boundedNumChunks = Math.min(numChunks, length)\r\n  const chunk = Array(boundedNumChunks).fill(0).map(_ => new Set<string>())\r\n  arts.values[slot].forEach(({ id }, i) => chunk[i % boundedNumChunks].add(id))\r\n  return chunk.map(ids => ({ ...filter, [slot]: { kind: \"id\", ids } }))\r\n}\r\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","isArray","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","iter","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_typeof","_regeneratorRuntime","exports","Op","hasOwn","hasOwnProperty","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","undefined","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","_i","_s","_arr","_n","_d","objPathValue","console","reduce","a","k","objectKeyMap","map","fromEntries","objectMap","entries","v","rangeGen","to","range","assertUnreachable","constant","NaN","percent","operation","operands","Number","MAX_VALUE","Infinity","min","intoOps","max","customRead","path","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","b","every","allCommutativeMonoidOperations","x","Math","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","common","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","v1","v2","match","unmatch","list","accu","nextContext","allSlotKeys","nonTravelerCharacterKeys","travelerKeys","filterFeasiblePerm","artSetPerm","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","_","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","baseValue","pruneOrder","numTop","exclusion","progress","noRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","greaterEqual","greater","some","pruneArtRange","minimum","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","pruneNodeRange","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","reads","_f","computeMinMax","c","sum","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","_artSets","artSets","available","exclusionToAllowed","populateShapes","indexOfShape","shape","check_free","remaining","rainbows","isolated","missing","rejected","required","allowedSet","allowedCounts","groupped","used","requiredRainbows","l","usableRainbows","sort","replacing","allowedRainbows","shapes","noFilter","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","splitWorker","computeWorker","ComputeWorker","callback","optimizationTarget","plotBase","maxBuilds","builds","buildValues","plotData","interimReport","refresh","command","tested","failed","skipped","optimize","newThreshold","preArts","totalCount","forced","should","deps","newArts","newNodes","pruneAll","compute","initial","binding","slotCount","body","names","operandNames","join","Function","precompute","buffer","permute","m","build","artifactIds","plot","force","plots","scale","round","mergePlot","SplitWorker","minCount","splitBySetOrID","addFilter","_arts","limit","numChunks","ceil","boundedNumChunks","chunk","splitByID","onmessage","splitID","computeID","interim","postMessage","split","setPerm","perm"],"sourceRoot":""}